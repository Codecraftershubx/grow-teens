
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Flashcard
 * 
 */
export type Flashcard = $Result.DefaultSelection<Prisma.$FlashcardPayload>
/**
 * Model FlashcardInteraction
 * 
 */
export type FlashcardInteraction = $Result.DefaultSelection<Prisma.$FlashcardInteractionPayload>
/**
 * Model FlashcardCollection
 * 
 */
export type FlashcardCollection = $Result.DefaultSelection<Prisma.$FlashcardCollectionPayload>
/**
 * Model FlashcardCollectionItem
 * 
 */
export type FlashcardCollectionItem = $Result.DefaultSelection<Prisma.$FlashcardCollectionItemPayload>
/**
 * Model ChatbotSession
 * 
 */
export type ChatbotSession = $Result.DefaultSelection<Prisma.$ChatbotSessionPayload>
/**
 * Model ChatbotMessage
 * 
 */
export type ChatbotMessage = $Result.DefaultSelection<Prisma.$ChatbotMessagePayload>
/**
 * Model ChatbotFeedback
 * 
 */
export type ChatbotFeedback = $Result.DefaultSelection<Prisma.$ChatbotFeedbackPayload>
/**
 * Model ChatbotSessionAnalytics
 * 
 */
export type ChatbotSessionAnalytics = $Result.DefaultSelection<Prisma.$ChatbotSessionAnalyticsPayload>
/**
 * Model SavedAnswer
 * 
 */
export type SavedAnswer = $Result.DefaultSelection<Prisma.$SavedAnswerPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model UserSkill
 * 
 */
export type UserSkill = $Result.DefaultSelection<Prisma.$UserSkillPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseTags
 * 
 */
export type CourseTags = $Result.DefaultSelection<Prisma.$CourseTagsPayload>
/**
 * Model LearningOutcome
 * 
 */
export type LearningOutcome = $Result.DefaultSelection<Prisma.$LearningOutcomePayload>
/**
 * Model CourseRequirement
 * 
 */
export type CourseRequirement = $Result.DefaultSelection<Prisma.$CourseRequirementPayload>
/**
 * Model CourseModule
 * 
 */
export type CourseModule = $Result.DefaultSelection<Prisma.$CourseModulePayload>
/**
 * Model ContentUnit
 * 
 */
export type ContentUnit = $Result.DefaultSelection<Prisma.$ContentUnitPayload>
/**
 * Model UnitAttachment
 * 
 */
export type UnitAttachment = $Result.DefaultSelection<Prisma.$UnitAttachmentPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model ModuleProgress
 * 
 */
export type ModuleProgress = $Result.DefaultSelection<Prisma.$ModuleProgressPayload>
/**
 * Model UnitProgress
 * 
 */
export type UnitProgress = $Result.DefaultSelection<Prisma.$UnitProgressPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model QuestionAnswer
 * 
 */
export type QuestionAnswer = $Result.DefaultSelection<Prisma.$QuestionAnswerPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model ExerciseSubmission
 * 
 */
export type ExerciseSubmission = $Result.DefaultSelection<Prisma.$ExerciseSubmissionPayload>
/**
 * Model CourseReview
 * 
 */
export type CourseReview = $Result.DefaultSelection<Prisma.$CourseReviewPayload>
/**
 * Model MentorshipProgram
 * 
 */
export type MentorshipProgram = $Result.DefaultSelection<Prisma.$MentorshipProgramPayload>
/**
 * Model Mentorship
 * 
 */
export type Mentorship = $Result.DefaultSelection<Prisma.$MentorshipPayload>
/**
 * Model MentorshipSession
 * 
 */
export type MentorshipSession = $Result.DefaultSelection<Prisma.$MentorshipSessionPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventRegistration
 * 
 */
export type EventRegistration = $Result.DefaultSelection<Prisma.$EventRegistrationPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model CommunityMember
 * 
 */
export type CommunityMember = $Result.DefaultSelection<Prisma.$CommunityMemberPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model Sponsor
 * 
 */
export type Sponsor = $Result.DefaultSelection<Prisma.$SponsorPayload>
/**
 * Model Sponsorship
 * 
 */
export type Sponsorship = $Result.DefaultSelection<Prisma.$SponsorshipPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Assessment
 * 
 */
export type Assessment = $Result.DefaultSelection<Prisma.$AssessmentPayload>
/**
 * Model AssessmentQuestion
 * 
 */
export type AssessmentQuestion = $Result.DefaultSelection<Prisma.$AssessmentQuestionPayload>
/**
 * Model UserAssessmentAttempt
 * 
 */
export type UserAssessmentAttempt = $Result.DefaultSelection<Prisma.$UserAssessmentAttemptPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Subscriber
 * 
 */
export type Subscriber = $Result.DefaultSelection<Prisma.$SubscriberPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  TEEN: 'TEEN',
  MENTOR: 'MENTOR',
  SPONSORS: 'SPONSORS',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  PREFER_NOT_TO_SAY: 'PREFER_NOT_TO_SAY'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const DifficultyLevel: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
  EXPERT: 'EXPERT'
};

export type DifficultyLevel = (typeof DifficultyLevel)[keyof typeof DifficultyLevel]


export const MessageRole: {
  USER: 'USER',
  ASSISTANT: 'ASSISTANT'
};

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]


export const CourseType: {
  HEALTH: 'HEALTH',
  TECH: 'TECH',
  FINANCIAL_LITERACY: 'FINANCIAL_LITERACY',
  LEADERSHIP: 'LEADERSHIP',
  ENTREPRENEURSHIP: 'ENTREPRENEURSHIP',
  PERSONAL_DEVELOPMENT: 'PERSONAL_DEVELOPMENT',
  CAREER: 'CAREER',
  CREATIVITY: 'CREATIVITY',
  ACADEMIC: 'ACADEMIC'
};

export type CourseType = (typeof CourseType)[keyof typeof CourseType]


export const ContentType: {
  VIDEO: 'VIDEO',
  TEXT: 'TEXT',
  AUDIO: 'AUDIO',
  INTERACTIVE: 'INTERACTIVE',
  ASSIGNMENT: 'ASSIGNMENT',
  RESOURCE: 'RESOURCE'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const EnrollmentStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  UNENROLLED: 'UNENROLLED',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED'
};

export type EnrollmentStatus = (typeof EnrollmentStatus)[keyof typeof EnrollmentStatus]


export const ExerciseType: {
  WRITTEN: 'WRITTEN',
  FILE_UPLOAD: 'FILE_UPLOAD',
  PROJECT: 'PROJECT',
  CODE: 'CODE',
  REFLECTION: 'REFLECTION'
};

export type ExerciseType = (typeof ExerciseType)[keyof typeof ExerciseType]


export const SessionStatus: {
  SCHEDULED: 'SCHEDULED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  MISSED: 'MISSED'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const CommunityRole: {
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  MEMBER: 'MEMBER'
};

export type CommunityRole = (typeof CommunityRole)[keyof typeof CommunityRole]


export const ProjectStatus: {
  PLANNING: 'PLANNING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ProjectRole: {
  LEADER: 'LEADER',
  MEMBER: 'MEMBER',
  CONTRIBUTOR: 'CONTRIBUTOR',
  OBSERVER: 'OBSERVER'
};

export type ProjectRole = (typeof ProjectRole)[keyof typeof ProjectRole]


export const SponsorshipType: {
  FINANCIAL: 'FINANCIAL',
  IN_KIND: 'IN_KIND',
  COURSE: 'COURSE',
  EVENT: 'EVENT',
  SCHOLARSHIP: 'SCHOLARSHIP'
};

export type SponsorshipType = (typeof SponsorshipType)[keyof typeof SponsorshipType]


export const AchievementCategory: {
  COURSE_COMPLETION: 'COURSE_COMPLETION',
  SKILL_MASTERY: 'SKILL_MASTERY',
  COMMUNITY_CONTRIBUTION: 'COMMUNITY_CONTRIBUTION',
  PROJECT_MILESTONE: 'PROJECT_MILESTONE',
  MENTORSHIP: 'MENTORSHIP',
  LEADERSHIP: 'LEADERSHIP'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]


export const NotificationType: {
  COURSE: 'COURSE',
  MENTORSHIP: 'MENTORSHIP',
  COMMUNITY: 'COMMUNITY',
  ACHIEVEMENT: 'ACHIEVEMENT',
  SYSTEM: 'SYSTEM',
  EVENT: 'EVENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const ResourceType: {
  DOCUMENT: 'DOCUMENT',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  IMAGE: 'IMAGE',
  LINK: 'LINK',
  CODE: 'CODE'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const QuestionType: {
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  SINGLE_CHOICE: 'SINGLE_CHOICE',
  TRUE_FALSE: 'TRUE_FALSE',
  SHORT_ANSWER: 'SHORT_ANSWER',
  ESSAY: 'ESSAY',
  FILE_UPLOAD: 'FILE_UPLOAD'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const FeedbackTarget: {
  USER: 'USER',
  COURSE: 'COURSE',
  MENTOR: 'MENTOR',
  EVENT: 'EVENT',
  RESOURCE: 'RESOURCE'
};

export type FeedbackTarget = (typeof FeedbackTarget)[keyof typeof FeedbackTarget]


export const StatusType: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type StatusType = (typeof StatusType)[keyof typeof StatusType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type DifficultyLevel = $Enums.DifficultyLevel

export const DifficultyLevel: typeof $Enums.DifficultyLevel

export type MessageRole = $Enums.MessageRole

export const MessageRole: typeof $Enums.MessageRole

export type CourseType = $Enums.CourseType

export const CourseType: typeof $Enums.CourseType

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type EnrollmentStatus = $Enums.EnrollmentStatus

export const EnrollmentStatus: typeof $Enums.EnrollmentStatus

export type ExerciseType = $Enums.ExerciseType

export const ExerciseType: typeof $Enums.ExerciseType

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type CommunityRole = $Enums.CommunityRole

export const CommunityRole: typeof $Enums.CommunityRole

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ProjectRole = $Enums.ProjectRole

export const ProjectRole: typeof $Enums.ProjectRole

export type SponsorshipType = $Enums.SponsorshipType

export const SponsorshipType: typeof $Enums.SponsorshipType

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type FeedbackTarget = $Enums.FeedbackTarget

export const FeedbackTarget: typeof $Enums.FeedbackTarget

export type StatusType = $Enums.StatusType

export const StatusType: typeof $Enums.StatusType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flashcard`: Exposes CRUD operations for the **Flashcard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flashcards
    * const flashcards = await prisma.flashcard.findMany()
    * ```
    */
  get flashcard(): Prisma.FlashcardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flashcardInteraction`: Exposes CRUD operations for the **FlashcardInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlashcardInteractions
    * const flashcardInteractions = await prisma.flashcardInteraction.findMany()
    * ```
    */
  get flashcardInteraction(): Prisma.FlashcardInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flashcardCollection`: Exposes CRUD operations for the **FlashcardCollection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlashcardCollections
    * const flashcardCollections = await prisma.flashcardCollection.findMany()
    * ```
    */
  get flashcardCollection(): Prisma.FlashcardCollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flashcardCollectionItem`: Exposes CRUD operations for the **FlashcardCollectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlashcardCollectionItems
    * const flashcardCollectionItems = await prisma.flashcardCollectionItem.findMany()
    * ```
    */
  get flashcardCollectionItem(): Prisma.FlashcardCollectionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbotSession`: Exposes CRUD operations for the **ChatbotSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatbotSessions
    * const chatbotSessions = await prisma.chatbotSession.findMany()
    * ```
    */
  get chatbotSession(): Prisma.ChatbotSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbotMessage`: Exposes CRUD operations for the **ChatbotMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatbotMessages
    * const chatbotMessages = await prisma.chatbotMessage.findMany()
    * ```
    */
  get chatbotMessage(): Prisma.ChatbotMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbotFeedback`: Exposes CRUD operations for the **ChatbotFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatbotFeedbacks
    * const chatbotFeedbacks = await prisma.chatbotFeedback.findMany()
    * ```
    */
  get chatbotFeedback(): Prisma.ChatbotFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbotSessionAnalytics`: Exposes CRUD operations for the **ChatbotSessionAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatbotSessionAnalytics
    * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findMany()
    * ```
    */
  get chatbotSessionAnalytics(): Prisma.ChatbotSessionAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedAnswer`: Exposes CRUD operations for the **SavedAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedAnswers
    * const savedAnswers = await prisma.savedAnswer.findMany()
    * ```
    */
  get savedAnswer(): Prisma.SavedAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSkill`: Exposes CRUD operations for the **UserSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkills
    * const userSkills = await prisma.userSkill.findMany()
    * ```
    */
  get userSkill(): Prisma.UserSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseTags`: Exposes CRUD operations for the **CourseTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTags
    * const courseTags = await prisma.courseTags.findMany()
    * ```
    */
  get courseTags(): Prisma.CourseTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningOutcome`: Exposes CRUD operations for the **LearningOutcome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningOutcomes
    * const learningOutcomes = await prisma.learningOutcome.findMany()
    * ```
    */
  get learningOutcome(): Prisma.LearningOutcomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseRequirement`: Exposes CRUD operations for the **CourseRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseRequirements
    * const courseRequirements = await prisma.courseRequirement.findMany()
    * ```
    */
  get courseRequirement(): Prisma.CourseRequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseModule`: Exposes CRUD operations for the **CourseModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseModules
    * const courseModules = await prisma.courseModule.findMany()
    * ```
    */
  get courseModule(): Prisma.CourseModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentUnit`: Exposes CRUD operations for the **ContentUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentUnits
    * const contentUnits = await prisma.contentUnit.findMany()
    * ```
    */
  get contentUnit(): Prisma.ContentUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitAttachment`: Exposes CRUD operations for the **UnitAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitAttachments
    * const unitAttachments = await prisma.unitAttachment.findMany()
    * ```
    */
  get unitAttachment(): Prisma.UnitAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleProgress`: Exposes CRUD operations for the **ModuleProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleProgresses
    * const moduleProgresses = await prisma.moduleProgress.findMany()
    * ```
    */
  get moduleProgress(): Prisma.ModuleProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitProgress`: Exposes CRUD operations for the **UnitProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitProgresses
    * const unitProgresses = await prisma.unitProgress.findMany()
    * ```
    */
  get unitProgress(): Prisma.UnitProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionAnswer`: Exposes CRUD operations for the **QuestionAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionAnswers
    * const questionAnswers = await prisma.questionAnswer.findMany()
    * ```
    */
  get questionAnswer(): Prisma.QuestionAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseSubmission`: Exposes CRUD operations for the **ExerciseSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseSubmissions
    * const exerciseSubmissions = await prisma.exerciseSubmission.findMany()
    * ```
    */
  get exerciseSubmission(): Prisma.ExerciseSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseReview`: Exposes CRUD operations for the **CourseReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseReviews
    * const courseReviews = await prisma.courseReview.findMany()
    * ```
    */
  get courseReview(): Prisma.CourseReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorshipProgram`: Exposes CRUD operations for the **MentorshipProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorshipPrograms
    * const mentorshipPrograms = await prisma.mentorshipProgram.findMany()
    * ```
    */
  get mentorshipProgram(): Prisma.MentorshipProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorship`: Exposes CRUD operations for the **Mentorship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentorships
    * const mentorships = await prisma.mentorship.findMany()
    * ```
    */
  get mentorship(): Prisma.MentorshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorshipSession`: Exposes CRUD operations for the **MentorshipSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorshipSessions
    * const mentorshipSessions = await prisma.mentorshipSession.findMany()
    * ```
    */
  get mentorshipSession(): Prisma.MentorshipSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventRegistration`: Exposes CRUD operations for the **EventRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRegistrations
    * const eventRegistrations = await prisma.eventRegistration.findMany()
    * ```
    */
  get eventRegistration(): Prisma.EventRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityMember`: Exposes CRUD operations for the **CommunityMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityMembers
    * const communityMembers = await prisma.communityMember.findMany()
    * ```
    */
  get communityMember(): Prisma.CommunityMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsor`: Exposes CRUD operations for the **Sponsor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsor.findMany()
    * ```
    */
  get sponsor(): Prisma.SponsorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsorship`: Exposes CRUD operations for the **Sponsorship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsorships
    * const sponsorships = await prisma.sponsorship.findMany()
    * ```
    */
  get sponsorship(): Prisma.SponsorshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessment`: Exposes CRUD operations for the **Assessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessment.findMany()
    * ```
    */
  get assessment(): Prisma.AssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessmentQuestion`: Exposes CRUD operations for the **AssessmentQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentQuestions
    * const assessmentQuestions = await prisma.assessmentQuestion.findMany()
    * ```
    */
  get assessmentQuestion(): Prisma.AssessmentQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAssessmentAttempt`: Exposes CRUD operations for the **UserAssessmentAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAssessmentAttempts
    * const userAssessmentAttempts = await prisma.userAssessmentAttempt.findMany()
    * ```
    */
  get userAssessmentAttempt(): Prisma.UserAssessmentAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriber`: Exposes CRUD operations for the **Subscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribers
    * const subscribers = await prisma.subscriber.findMany()
    * ```
    */
  get subscriber(): Prisma.SubscriberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Flashcard: 'Flashcard',
    FlashcardInteraction: 'FlashcardInteraction',
    FlashcardCollection: 'FlashcardCollection',
    FlashcardCollectionItem: 'FlashcardCollectionItem',
    ChatbotSession: 'ChatbotSession',
    ChatbotMessage: 'ChatbotMessage',
    ChatbotFeedback: 'ChatbotFeedback',
    ChatbotSessionAnalytics: 'ChatbotSessionAnalytics',
    SavedAnswer: 'SavedAnswer',
    Skill: 'Skill',
    UserSkill: 'UserSkill',
    Course: 'Course',
    CourseTags: 'CourseTags',
    LearningOutcome: 'LearningOutcome',
    CourseRequirement: 'CourseRequirement',
    CourseModule: 'CourseModule',
    ContentUnit: 'ContentUnit',
    UnitAttachment: 'UnitAttachment',
    Enrollment: 'Enrollment',
    ModuleProgress: 'ModuleProgress',
    UnitProgress: 'UnitProgress',
    Quiz: 'Quiz',
    QuizQuestion: 'QuizQuestion',
    QuizAttempt: 'QuizAttempt',
    QuestionAnswer: 'QuestionAnswer',
    Exercise: 'Exercise',
    ExerciseSubmission: 'ExerciseSubmission',
    CourseReview: 'CourseReview',
    MentorshipProgram: 'MentorshipProgram',
    Mentorship: 'Mentorship',
    MentorshipSession: 'MentorshipSession',
    Event: 'Event',
    EventRegistration: 'EventRegistration',
    Community: 'Community',
    CommunityMember: 'CommunityMember',
    Post: 'Post',
    Comment: 'Comment',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    Sponsor: 'Sponsor',
    Sponsorship: 'Sponsorship',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Notification: 'Notification',
    Resource: 'Resource',
    Assessment: 'Assessment',
    AssessmentQuestion: 'AssessmentQuestion',
    UserAssessmentAttempt: 'UserAssessmentAttempt',
    Feedback: 'Feedback',
    Subscriber: 'Subscriber'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "flashcard" | "flashcardInteraction" | "flashcardCollection" | "flashcardCollectionItem" | "chatbotSession" | "chatbotMessage" | "chatbotFeedback" | "chatbotSessionAnalytics" | "savedAnswer" | "skill" | "userSkill" | "course" | "courseTags" | "learningOutcome" | "courseRequirement" | "courseModule" | "contentUnit" | "unitAttachment" | "enrollment" | "moduleProgress" | "unitProgress" | "quiz" | "quizQuestion" | "quizAttempt" | "questionAnswer" | "exercise" | "exerciseSubmission" | "courseReview" | "mentorshipProgram" | "mentorship" | "mentorshipSession" | "event" | "eventRegistration" | "community" | "communityMember" | "post" | "comment" | "project" | "projectMember" | "sponsor" | "sponsorship" | "achievement" | "userAchievement" | "notification" | "resource" | "assessment" | "assessmentQuestion" | "userAssessmentAttempt" | "feedback" | "subscriber"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Flashcard: {
        payload: Prisma.$FlashcardPayload<ExtArgs>
        fields: Prisma.FlashcardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlashcardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlashcardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          findFirst: {
            args: Prisma.FlashcardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlashcardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          findMany: {
            args: Prisma.FlashcardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>[]
          }
          create: {
            args: Prisma.FlashcardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          createMany: {
            args: Prisma.FlashcardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlashcardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>[]
          }
          delete: {
            args: Prisma.FlashcardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          update: {
            args: Prisma.FlashcardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          deleteMany: {
            args: Prisma.FlashcardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlashcardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlashcardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>[]
          }
          upsert: {
            args: Prisma.FlashcardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          aggregate: {
            args: Prisma.FlashcardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlashcard>
          }
          groupBy: {
            args: Prisma.FlashcardGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlashcardGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlashcardCountArgs<ExtArgs>
            result: $Utils.Optional<FlashcardCountAggregateOutputType> | number
          }
        }
      }
      FlashcardInteraction: {
        payload: Prisma.$FlashcardInteractionPayload<ExtArgs>
        fields: Prisma.FlashcardInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlashcardInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlashcardInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>
          }
          findFirst: {
            args: Prisma.FlashcardInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlashcardInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>
          }
          findMany: {
            args: Prisma.FlashcardInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>[]
          }
          create: {
            args: Prisma.FlashcardInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>
          }
          createMany: {
            args: Prisma.FlashcardInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlashcardInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>[]
          }
          delete: {
            args: Prisma.FlashcardInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>
          }
          update: {
            args: Prisma.FlashcardInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>
          }
          deleteMany: {
            args: Prisma.FlashcardInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlashcardInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlashcardInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>[]
          }
          upsert: {
            args: Prisma.FlashcardInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardInteractionPayload>
          }
          aggregate: {
            args: Prisma.FlashcardInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlashcardInteraction>
          }
          groupBy: {
            args: Prisma.FlashcardInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlashcardInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlashcardInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<FlashcardInteractionCountAggregateOutputType> | number
          }
        }
      }
      FlashcardCollection: {
        payload: Prisma.$FlashcardCollectionPayload<ExtArgs>
        fields: Prisma.FlashcardCollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlashcardCollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlashcardCollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>
          }
          findFirst: {
            args: Prisma.FlashcardCollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlashcardCollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>
          }
          findMany: {
            args: Prisma.FlashcardCollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>[]
          }
          create: {
            args: Prisma.FlashcardCollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>
          }
          createMany: {
            args: Prisma.FlashcardCollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlashcardCollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>[]
          }
          delete: {
            args: Prisma.FlashcardCollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>
          }
          update: {
            args: Prisma.FlashcardCollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>
          }
          deleteMany: {
            args: Prisma.FlashcardCollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlashcardCollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlashcardCollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>[]
          }
          upsert: {
            args: Prisma.FlashcardCollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionPayload>
          }
          aggregate: {
            args: Prisma.FlashcardCollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlashcardCollection>
          }
          groupBy: {
            args: Prisma.FlashcardCollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlashcardCollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlashcardCollectionCountArgs<ExtArgs>
            result: $Utils.Optional<FlashcardCollectionCountAggregateOutputType> | number
          }
        }
      }
      FlashcardCollectionItem: {
        payload: Prisma.$FlashcardCollectionItemPayload<ExtArgs>
        fields: Prisma.FlashcardCollectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlashcardCollectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlashcardCollectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>
          }
          findFirst: {
            args: Prisma.FlashcardCollectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlashcardCollectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>
          }
          findMany: {
            args: Prisma.FlashcardCollectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>[]
          }
          create: {
            args: Prisma.FlashcardCollectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>
          }
          createMany: {
            args: Prisma.FlashcardCollectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlashcardCollectionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>[]
          }
          delete: {
            args: Prisma.FlashcardCollectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>
          }
          update: {
            args: Prisma.FlashcardCollectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>
          }
          deleteMany: {
            args: Prisma.FlashcardCollectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlashcardCollectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlashcardCollectionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>[]
          }
          upsert: {
            args: Prisma.FlashcardCollectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardCollectionItemPayload>
          }
          aggregate: {
            args: Prisma.FlashcardCollectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlashcardCollectionItem>
          }
          groupBy: {
            args: Prisma.FlashcardCollectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlashcardCollectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlashcardCollectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<FlashcardCollectionItemCountAggregateOutputType> | number
          }
        }
      }
      ChatbotSession: {
        payload: Prisma.$ChatbotSessionPayload<ExtArgs>
        fields: Prisma.ChatbotSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatbotSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>
          }
          findMany: {
            args: Prisma.ChatbotSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>[]
          }
          create: {
            args: Prisma.ChatbotSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>
          }
          createMany: {
            args: Prisma.ChatbotSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatbotSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>
          }
          update: {
            args: Prisma.ChatbotSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatbotSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>[]
          }
          upsert: {
            args: Prisma.ChatbotSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatbotSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbotSession>
          }
          groupBy: {
            args: Prisma.ChatbotSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotSessionCountAggregateOutputType> | number
          }
        }
      }
      ChatbotMessage: {
        payload: Prisma.$ChatbotMessagePayload<ExtArgs>
        fields: Prisma.ChatbotMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatbotMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          findMany: {
            args: Prisma.ChatbotMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>[]
          }
          create: {
            args: Prisma.ChatbotMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          createMany: {
            args: Prisma.ChatbotMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatbotMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          update: {
            args: Prisma.ChatbotMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatbotMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatbotMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatbotMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbotMessage>
          }
          groupBy: {
            args: Prisma.ChatbotMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotMessageCountAggregateOutputType> | number
          }
        }
      }
      ChatbotFeedback: {
        payload: Prisma.$ChatbotFeedbackPayload<ExtArgs>
        fields: Prisma.ChatbotFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>
          }
          findFirst: {
            args: Prisma.ChatbotFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>
          }
          findMany: {
            args: Prisma.ChatbotFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>[]
          }
          create: {
            args: Prisma.ChatbotFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>
          }
          createMany: {
            args: Prisma.ChatbotFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>[]
          }
          delete: {
            args: Prisma.ChatbotFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>
          }
          update: {
            args: Prisma.ChatbotFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.ChatbotFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.ChatbotFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotFeedbackPayload>
          }
          aggregate: {
            args: Prisma.ChatbotFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbotFeedback>
          }
          groupBy: {
            args: Prisma.ChatbotFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotFeedbackCountAggregateOutputType> | number
          }
        }
      }
      ChatbotSessionAnalytics: {
        payload: Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>
        fields: Prisma.ChatbotSessionAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotSessionAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotSessionAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.ChatbotSessionAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotSessionAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>
          }
          findMany: {
            args: Prisma.ChatbotSessionAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>[]
          }
          create: {
            args: Prisma.ChatbotSessionAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>
          }
          createMany: {
            args: Prisma.ChatbotSessionAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotSessionAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.ChatbotSessionAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>
          }
          update: {
            args: Prisma.ChatbotSessionAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.ChatbotSessionAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotSessionAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotSessionAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.ChatbotSessionAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotSessionAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.ChatbotSessionAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbotSessionAnalytics>
          }
          groupBy: {
            args: Prisma.ChatbotSessionAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotSessionAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotSessionAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotSessionAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SavedAnswer: {
        payload: Prisma.$SavedAnswerPayload<ExtArgs>
        fields: Prisma.SavedAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>
          }
          findFirst: {
            args: Prisma.SavedAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>
          }
          findMany: {
            args: Prisma.SavedAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>[]
          }
          create: {
            args: Prisma.SavedAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>
          }
          createMany: {
            args: Prisma.SavedAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>[]
          }
          delete: {
            args: Prisma.SavedAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>
          }
          update: {
            args: Prisma.SavedAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>
          }
          deleteMany: {
            args: Prisma.SavedAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>[]
          }
          upsert: {
            args: Prisma.SavedAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedAnswerPayload>
          }
          aggregate: {
            args: Prisma.SavedAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedAnswer>
          }
          groupBy: {
            args: Prisma.SavedAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<SavedAnswerCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      UserSkill: {
        payload: Prisma.$UserSkillPayload<ExtArgs>
        fields: Prisma.UserSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          findFirst: {
            args: Prisma.UserSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          findMany: {
            args: Prisma.UserSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>[]
          }
          create: {
            args: Prisma.UserSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          createMany: {
            args: Prisma.UserSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>[]
          }
          delete: {
            args: Prisma.UserSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          update: {
            args: Prisma.UserSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          deleteMany: {
            args: Prisma.UserSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>[]
          }
          upsert: {
            args: Prisma.UserSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          aggregate: {
            args: Prisma.UserSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkill>
          }
          groupBy: {
            args: Prisma.UserSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSkillCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseTags: {
        payload: Prisma.$CourseTagsPayload<ExtArgs>
        fields: Prisma.CourseTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          findFirst: {
            args: Prisma.CourseTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          findMany: {
            args: Prisma.CourseTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>[]
          }
          create: {
            args: Prisma.CourseTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          createMany: {
            args: Prisma.CourseTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>[]
          }
          delete: {
            args: Prisma.CourseTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          update: {
            args: Prisma.CourseTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          deleteMany: {
            args: Prisma.CourseTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>[]
          }
          upsert: {
            args: Prisma.CourseTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          aggregate: {
            args: Prisma.CourseTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseTags>
          }
          groupBy: {
            args: Prisma.CourseTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTagsCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTagsCountAggregateOutputType> | number
          }
        }
      }
      LearningOutcome: {
        payload: Prisma.$LearningOutcomePayload<ExtArgs>
        fields: Prisma.LearningOutcomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningOutcomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningOutcomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          findFirst: {
            args: Prisma.LearningOutcomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningOutcomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          findMany: {
            args: Prisma.LearningOutcomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>[]
          }
          create: {
            args: Prisma.LearningOutcomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          createMany: {
            args: Prisma.LearningOutcomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningOutcomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>[]
          }
          delete: {
            args: Prisma.LearningOutcomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          update: {
            args: Prisma.LearningOutcomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          deleteMany: {
            args: Prisma.LearningOutcomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningOutcomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningOutcomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>[]
          }
          upsert: {
            args: Prisma.LearningOutcomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          aggregate: {
            args: Prisma.LearningOutcomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningOutcome>
          }
          groupBy: {
            args: Prisma.LearningOutcomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningOutcomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningOutcomeCountArgs<ExtArgs>
            result: $Utils.Optional<LearningOutcomeCountAggregateOutputType> | number
          }
        }
      }
      CourseRequirement: {
        payload: Prisma.$CourseRequirementPayload<ExtArgs>
        fields: Prisma.CourseRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>
          }
          findFirst: {
            args: Prisma.CourseRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>
          }
          findMany: {
            args: Prisma.CourseRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>[]
          }
          create: {
            args: Prisma.CourseRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>
          }
          createMany: {
            args: Prisma.CourseRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>[]
          }
          delete: {
            args: Prisma.CourseRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>
          }
          update: {
            args: Prisma.CourseRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>
          }
          deleteMany: {
            args: Prisma.CourseRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseRequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>[]
          }
          upsert: {
            args: Prisma.CourseRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRequirementPayload>
          }
          aggregate: {
            args: Prisma.CourseRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseRequirement>
          }
          groupBy: {
            args: Prisma.CourseRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<CourseRequirementCountAggregateOutputType> | number
          }
        }
      }
      CourseModule: {
        payload: Prisma.$CourseModulePayload<ExtArgs>
        fields: Prisma.CourseModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findFirst: {
            args: Prisma.CourseModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findMany: {
            args: Prisma.CourseModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          create: {
            args: Prisma.CourseModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          createMany: {
            args: Prisma.CourseModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          delete: {
            args: Prisma.CourseModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          update: {
            args: Prisma.CourseModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          deleteMany: {
            args: Prisma.CourseModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          upsert: {
            args: Prisma.CourseModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          aggregate: {
            args: Prisma.CourseModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseModule>
          }
          groupBy: {
            args: Prisma.CourseModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseModuleCountArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleCountAggregateOutputType> | number
          }
        }
      }
      ContentUnit: {
        payload: Prisma.$ContentUnitPayload<ExtArgs>
        fields: Prisma.ContentUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          findFirst: {
            args: Prisma.ContentUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          findMany: {
            args: Prisma.ContentUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>[]
          }
          create: {
            args: Prisma.ContentUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          createMany: {
            args: Prisma.ContentUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>[]
          }
          delete: {
            args: Prisma.ContentUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          update: {
            args: Prisma.ContentUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          deleteMany: {
            args: Prisma.ContentUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>[]
          }
          upsert: {
            args: Prisma.ContentUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          aggregate: {
            args: Prisma.ContentUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentUnit>
          }
          groupBy: {
            args: Prisma.ContentUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentUnitCountArgs<ExtArgs>
            result: $Utils.Optional<ContentUnitCountAggregateOutputType> | number
          }
        }
      }
      UnitAttachment: {
        payload: Prisma.$UnitAttachmentPayload<ExtArgs>
        fields: Prisma.UnitAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>
          }
          findFirst: {
            args: Prisma.UnitAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>
          }
          findMany: {
            args: Prisma.UnitAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>[]
          }
          create: {
            args: Prisma.UnitAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>
          }
          createMany: {
            args: Prisma.UnitAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>[]
          }
          delete: {
            args: Prisma.UnitAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>
          }
          update: {
            args: Prisma.UnitAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.UnitAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.UnitAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAttachmentPayload>
          }
          aggregate: {
            args: Prisma.UnitAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitAttachment>
          }
          groupBy: {
            args: Prisma.UnitAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<UnitAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      ModuleProgress: {
        payload: Prisma.$ModuleProgressPayload<ExtArgs>
        fields: Prisma.ModuleProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          findFirst: {
            args: Prisma.ModuleProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          findMany: {
            args: Prisma.ModuleProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>[]
          }
          create: {
            args: Prisma.ModuleProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          createMany: {
            args: Prisma.ModuleProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>[]
          }
          delete: {
            args: Prisma.ModuleProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          update: {
            args: Prisma.ModuleProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          deleteMany: {
            args: Prisma.ModuleProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>[]
          }
          upsert: {
            args: Prisma.ModuleProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          aggregate: {
            args: Prisma.ModuleProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleProgress>
          }
          groupBy: {
            args: Prisma.ModuleProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleProgressCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleProgressCountAggregateOutputType> | number
          }
        }
      }
      UnitProgress: {
        payload: Prisma.$UnitProgressPayload<ExtArgs>
        fields: Prisma.UnitProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>
          }
          findFirst: {
            args: Prisma.UnitProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>
          }
          findMany: {
            args: Prisma.UnitProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>[]
          }
          create: {
            args: Prisma.UnitProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>
          }
          createMany: {
            args: Prisma.UnitProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>[]
          }
          delete: {
            args: Prisma.UnitProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>
          }
          update: {
            args: Prisma.UnitProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>
          }
          deleteMany: {
            args: Prisma.UnitProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>[]
          }
          upsert: {
            args: Prisma.UnitProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitProgressPayload>
          }
          aggregate: {
            args: Prisma.UnitProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitProgress>
          }
          groupBy: {
            args: Prisma.UnitProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UnitProgressCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      QuestionAnswer: {
        payload: Prisma.$QuestionAnswerPayload<ExtArgs>
        fields: Prisma.QuestionAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuestionAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          findMany: {
            args: Prisma.QuestionAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>[]
          }
          create: {
            args: Prisma.QuestionAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          createMany: {
            args: Prisma.QuestionAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuestionAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          update: {
            args: Prisma.QuestionAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuestionAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>[]
          }
          upsert: {
            args: Prisma.QuestionAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuestionAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionAnswer>
          }
          groupBy: {
            args: Prisma.QuestionAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnswerCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      ExerciseSubmission: {
        payload: Prisma.$ExerciseSubmissionPayload<ExtArgs>
        fields: Prisma.ExerciseSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ExerciseSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          findMany: {
            args: Prisma.ExerciseSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>[]
          }
          create: {
            args: Prisma.ExerciseSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          createMany: {
            args: Prisma.ExerciseSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ExerciseSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          update: {
            args: Prisma.ExerciseSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ExerciseSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ExerciseSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseSubmission>
          }
          groupBy: {
            args: Prisma.ExerciseSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseSubmissionCountAggregateOutputType> | number
          }
        }
      }
      CourseReview: {
        payload: Prisma.$CourseReviewPayload<ExtArgs>
        fields: Prisma.CourseReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          findFirst: {
            args: Prisma.CourseReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          findMany: {
            args: Prisma.CourseReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
          }
          create: {
            args: Prisma.CourseReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          createMany: {
            args: Prisma.CourseReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
          }
          delete: {
            args: Prisma.CourseReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          update: {
            args: Prisma.CourseReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          deleteMany: {
            args: Prisma.CourseReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
          }
          upsert: {
            args: Prisma.CourseReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseReviewPayload>
          }
          aggregate: {
            args: Prisma.CourseReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseReview>
          }
          groupBy: {
            args: Prisma.CourseReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseReviewCountArgs<ExtArgs>
            result: $Utils.Optional<CourseReviewCountAggregateOutputType> | number
          }
        }
      }
      MentorshipProgram: {
        payload: Prisma.$MentorshipProgramPayload<ExtArgs>
        fields: Prisma.MentorshipProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorshipProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorshipProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>
          }
          findFirst: {
            args: Prisma.MentorshipProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorshipProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>
          }
          findMany: {
            args: Prisma.MentorshipProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>[]
          }
          create: {
            args: Prisma.MentorshipProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>
          }
          createMany: {
            args: Prisma.MentorshipProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorshipProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>[]
          }
          delete: {
            args: Prisma.MentorshipProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>
          }
          update: {
            args: Prisma.MentorshipProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>
          }
          deleteMany: {
            args: Prisma.MentorshipProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorshipProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorshipProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>[]
          }
          upsert: {
            args: Prisma.MentorshipProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipProgramPayload>
          }
          aggregate: {
            args: Prisma.MentorshipProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorshipProgram>
          }
          groupBy: {
            args: Prisma.MentorshipProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorshipProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorshipProgramCountArgs<ExtArgs>
            result: $Utils.Optional<MentorshipProgramCountAggregateOutputType> | number
          }
        }
      }
      Mentorship: {
        payload: Prisma.$MentorshipPayload<ExtArgs>
        fields: Prisma.MentorshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          findFirst: {
            args: Prisma.MentorshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          findMany: {
            args: Prisma.MentorshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
          }
          create: {
            args: Prisma.MentorshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          createMany: {
            args: Prisma.MentorshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
          }
          delete: {
            args: Prisma.MentorshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          update: {
            args: Prisma.MentorshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          deleteMany: {
            args: Prisma.MentorshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
          }
          upsert: {
            args: Prisma.MentorshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipPayload>
          }
          aggregate: {
            args: Prisma.MentorshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorship>
          }
          groupBy: {
            args: Prisma.MentorshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorshipCountArgs<ExtArgs>
            result: $Utils.Optional<MentorshipCountAggregateOutputType> | number
          }
        }
      }
      MentorshipSession: {
        payload: Prisma.$MentorshipSessionPayload<ExtArgs>
        fields: Prisma.MentorshipSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorshipSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorshipSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>
          }
          findFirst: {
            args: Prisma.MentorshipSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorshipSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>
          }
          findMany: {
            args: Prisma.MentorshipSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>[]
          }
          create: {
            args: Prisma.MentorshipSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>
          }
          createMany: {
            args: Prisma.MentorshipSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorshipSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>[]
          }
          delete: {
            args: Prisma.MentorshipSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>
          }
          update: {
            args: Prisma.MentorshipSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>
          }
          deleteMany: {
            args: Prisma.MentorshipSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorshipSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorshipSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>[]
          }
          upsert: {
            args: Prisma.MentorshipSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorshipSessionPayload>
          }
          aggregate: {
            args: Prisma.MentorshipSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorshipSession>
          }
          groupBy: {
            args: Prisma.MentorshipSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorshipSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorshipSessionCountArgs<ExtArgs>
            result: $Utils.Optional<MentorshipSessionCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventRegistration: {
        payload: Prisma.$EventRegistrationPayload<ExtArgs>
        fields: Prisma.EventRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findFirst: {
            args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findMany: {
            args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          create: {
            args: Prisma.EventRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          createMany: {
            args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          delete: {
            args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          update: {
            args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          aggregate: {
            args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventRegistration>
          }
          groupBy: {
            args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      CommunityMember: {
        payload: Prisma.$CommunityMemberPayload<ExtArgs>
        fields: Prisma.CommunityMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          findFirst: {
            args: Prisma.CommunityMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          findMany: {
            args: Prisma.CommunityMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>[]
          }
          create: {
            args: Prisma.CommunityMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          createMany: {
            args: Prisma.CommunityMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>[]
          }
          delete: {
            args: Prisma.CommunityMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          update: {
            args: Prisma.CommunityMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          deleteMany: {
            args: Prisma.CommunityMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>[]
          }
          upsert: {
            args: Prisma.CommunityMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          aggregate: {
            args: Prisma.CommunityMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityMember>
          }
          groupBy: {
            args: Prisma.CommunityMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityMemberCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      Sponsor: {
        payload: Prisma.$SponsorPayload<ExtArgs>
        fields: Prisma.SponsorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findFirst: {
            args: Prisma.SponsorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findMany: {
            args: Prisma.SponsorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          create: {
            args: Prisma.SponsorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          createMany: {
            args: Prisma.SponsorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SponsorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          delete: {
            args: Prisma.SponsorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          update: {
            args: Prisma.SponsorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          deleteMany: {
            args: Prisma.SponsorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SponsorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          upsert: {
            args: Prisma.SponsorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          aggregate: {
            args: Prisma.SponsorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsor>
          }
          groupBy: {
            args: Prisma.SponsorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SponsorCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorCountAggregateOutputType> | number
          }
        }
      }
      Sponsorship: {
        payload: Prisma.$SponsorshipPayload<ExtArgs>
        fields: Prisma.SponsorshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>
          }
          findFirst: {
            args: Prisma.SponsorshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>
          }
          findMany: {
            args: Prisma.SponsorshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>[]
          }
          create: {
            args: Prisma.SponsorshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>
          }
          createMany: {
            args: Prisma.SponsorshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SponsorshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>[]
          }
          delete: {
            args: Prisma.SponsorshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>
          }
          update: {
            args: Prisma.SponsorshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>
          }
          deleteMany: {
            args: Prisma.SponsorshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SponsorshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>[]
          }
          upsert: {
            args: Prisma.SponsorshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorshipPayload>
          }
          aggregate: {
            args: Prisma.SponsorshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsorship>
          }
          groupBy: {
            args: Prisma.SponsorshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.SponsorshipCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorshipCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Assessment: {
        payload: Prisma.$AssessmentPayload<ExtArgs>
        fields: Prisma.AssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findFirst: {
            args: Prisma.AssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findMany: {
            args: Prisma.AssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          create: {
            args: Prisma.AssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          createMany: {
            args: Prisma.AssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          delete: {
            args: Prisma.AssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          update: {
            args: Prisma.AssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssessmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          upsert: {
            args: Prisma.AssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessment>
          }
          groupBy: {
            args: Prisma.AssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentCountAggregateOutputType> | number
          }
        }
      }
      AssessmentQuestion: {
        payload: Prisma.$AssessmentQuestionPayload<ExtArgs>
        fields: Prisma.AssessmentQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          findFirst: {
            args: Prisma.AssessmentQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          findMany: {
            args: Prisma.AssessmentQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          create: {
            args: Prisma.AssessmentQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          createMany: {
            args: Prisma.AssessmentQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          delete: {
            args: Prisma.AssessmentQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          update: {
            args: Prisma.AssessmentQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          upsert: {
            args: Prisma.AssessmentQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          aggregate: {
            args: Prisma.AssessmentQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentQuestion>
          }
          groupBy: {
            args: Prisma.AssessmentQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentQuestionCountAggregateOutputType> | number
          }
        }
      }
      UserAssessmentAttempt: {
        payload: Prisma.$UserAssessmentAttemptPayload<ExtArgs>
        fields: Prisma.UserAssessmentAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAssessmentAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAssessmentAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>
          }
          findFirst: {
            args: Prisma.UserAssessmentAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAssessmentAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>
          }
          findMany: {
            args: Prisma.UserAssessmentAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>[]
          }
          create: {
            args: Prisma.UserAssessmentAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>
          }
          createMany: {
            args: Prisma.UserAssessmentAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAssessmentAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>[]
          }
          delete: {
            args: Prisma.UserAssessmentAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>
          }
          update: {
            args: Prisma.UserAssessmentAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>
          }
          deleteMany: {
            args: Prisma.UserAssessmentAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAssessmentAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAssessmentAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>[]
          }
          upsert: {
            args: Prisma.UserAssessmentAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentAttemptPayload>
          }
          aggregate: {
            args: Prisma.UserAssessmentAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAssessmentAttempt>
          }
          groupBy: {
            args: Prisma.UserAssessmentAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAssessmentAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAssessmentAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<UserAssessmentAttemptCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Subscriber: {
        payload: Prisma.$SubscriberPayload<ExtArgs>
        fields: Prisma.SubscriberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findFirst: {
            args: Prisma.SubscriberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findMany: {
            args: Prisma.SubscriberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          create: {
            args: Prisma.SubscriberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          createMany: {
            args: Prisma.SubscriberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          delete: {
            args: Prisma.SubscriberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          update: {
            args: Prisma.SubscriberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          deleteMany: {
            args: Prisma.SubscriberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          upsert: {
            args: Prisma.SubscriberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          aggregate: {
            args: Prisma.SubscriberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriber>
          }
          groupBy: {
            args: Prisma.SubscriberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriberCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    flashcard?: FlashcardOmit
    flashcardInteraction?: FlashcardInteractionOmit
    flashcardCollection?: FlashcardCollectionOmit
    flashcardCollectionItem?: FlashcardCollectionItemOmit
    chatbotSession?: ChatbotSessionOmit
    chatbotMessage?: ChatbotMessageOmit
    chatbotFeedback?: ChatbotFeedbackOmit
    chatbotSessionAnalytics?: ChatbotSessionAnalyticsOmit
    savedAnswer?: SavedAnswerOmit
    skill?: SkillOmit
    userSkill?: UserSkillOmit
    course?: CourseOmit
    courseTags?: CourseTagsOmit
    learningOutcome?: LearningOutcomeOmit
    courseRequirement?: CourseRequirementOmit
    courseModule?: CourseModuleOmit
    contentUnit?: ContentUnitOmit
    unitAttachment?: UnitAttachmentOmit
    enrollment?: EnrollmentOmit
    moduleProgress?: ModuleProgressOmit
    unitProgress?: UnitProgressOmit
    quiz?: QuizOmit
    quizQuestion?: QuizQuestionOmit
    quizAttempt?: QuizAttemptOmit
    questionAnswer?: QuestionAnswerOmit
    exercise?: ExerciseOmit
    exerciseSubmission?: ExerciseSubmissionOmit
    courseReview?: CourseReviewOmit
    mentorshipProgram?: MentorshipProgramOmit
    mentorship?: MentorshipOmit
    mentorshipSession?: MentorshipSessionOmit
    event?: EventOmit
    eventRegistration?: EventRegistrationOmit
    community?: CommunityOmit
    communityMember?: CommunityMemberOmit
    post?: PostOmit
    comment?: CommentOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    sponsor?: SponsorOmit
    sponsorship?: SponsorshipOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    notification?: NotificationOmit
    resource?: ResourceOmit
    assessment?: AssessmentOmit
    assessmentQuestion?: AssessmentQuestionOmit
    userAssessmentAttempt?: UserAssessmentAttemptOmit
    feedback?: FeedbackOmit
    subscriber?: SubscriberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reviews: number
    enrollments: number
    userSkills: number
    menteeRelationships: number
    mentorRelationships: number
    instructedCourses: number
    eventRegistrations: number
    createdCommunities: number
    communityMemberships: number
    posts: number
    comments: number
    createdProjects: number
    projectMemberships: number
    achievements: number
    notifications: number
    uploadedResources: number
    assessmentAttempts: number
    providedFeedback: number
    userInteractions: number
    flashcards: number
    flashcardCollections: number
    chatbotSessions: number
    chatbotFeedback: number
    savedAnswers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    userSkills?: boolean | UserCountOutputTypeCountUserSkillsArgs
    menteeRelationships?: boolean | UserCountOutputTypeCountMenteeRelationshipsArgs
    mentorRelationships?: boolean | UserCountOutputTypeCountMentorRelationshipsArgs
    instructedCourses?: boolean | UserCountOutputTypeCountInstructedCoursesArgs
    eventRegistrations?: boolean | UserCountOutputTypeCountEventRegistrationsArgs
    createdCommunities?: boolean | UserCountOutputTypeCountCreatedCommunitiesArgs
    communityMemberships?: boolean | UserCountOutputTypeCountCommunityMembershipsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    createdProjects?: boolean | UserCountOutputTypeCountCreatedProjectsArgs
    projectMemberships?: boolean | UserCountOutputTypeCountProjectMembershipsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    uploadedResources?: boolean | UserCountOutputTypeCountUploadedResourcesArgs
    assessmentAttempts?: boolean | UserCountOutputTypeCountAssessmentAttemptsArgs
    providedFeedback?: boolean | UserCountOutputTypeCountProvidedFeedbackArgs
    userInteractions?: boolean | UserCountOutputTypeCountUserInteractionsArgs
    flashcards?: boolean | UserCountOutputTypeCountFlashcardsArgs
    flashcardCollections?: boolean | UserCountOutputTypeCountFlashcardCollectionsArgs
    chatbotSessions?: boolean | UserCountOutputTypeCountChatbotSessionsArgs
    chatbotFeedback?: boolean | UserCountOutputTypeCountChatbotFeedbackArgs
    savedAnswers?: boolean | UserCountOutputTypeCountSavedAnswersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMenteeRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentorRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstructedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssessmentAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProvidedFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardInteractionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlashcardCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardCollectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatbotSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatbotFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedAnswerWhereInput
  }


  /**
   * Count Type FlashcardCountOutputType
   */

  export type FlashcardCountOutputType = {
    userInteractions: number
    collections: number
  }

  export type FlashcardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userInteractions?: boolean | FlashcardCountOutputTypeCountUserInteractionsArgs
    collections?: boolean | FlashcardCountOutputTypeCountCollectionsArgs
  }

  // Custom InputTypes
  /**
   * FlashcardCountOutputType without action
   */
  export type FlashcardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCountOutputType
     */
    select?: FlashcardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlashcardCountOutputType without action
   */
  export type FlashcardCountOutputTypeCountUserInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardInteractionWhereInput
  }

  /**
   * FlashcardCountOutputType without action
   */
  export type FlashcardCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardCollectionItemWhereInput
  }


  /**
   * Count Type FlashcardCollectionCountOutputType
   */

  export type FlashcardCollectionCountOutputType = {
    cards: number
  }

  export type FlashcardCollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cards?: boolean | FlashcardCollectionCountOutputTypeCountCardsArgs
  }

  // Custom InputTypes
  /**
   * FlashcardCollectionCountOutputType without action
   */
  export type FlashcardCollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionCountOutputType
     */
    select?: FlashcardCollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlashcardCollectionCountOutputType without action
   */
  export type FlashcardCollectionCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardCollectionItemWhereInput
  }


  /**
   * Count Type ChatbotSessionCountOutputType
   */

  export type ChatbotSessionCountOutputType = {
    messages: number
  }

  export type ChatbotSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatbotSessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatbotSessionCountOutputType without action
   */
  export type ChatbotSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionCountOutputType
     */
    select?: ChatbotSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatbotSessionCountOutputType without action
   */
  export type ChatbotSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotMessageWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    userSkills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | SkillCountOutputTypeCountUserSkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    modules: number
    enrollments: number
    learningOutcomes: number
    requirements: number
    assessments: number
    flashcards: number
    chatbotMessages: number
    savedAnswers: number
    tags: number
    reviews: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    learningOutcomes?: boolean | CourseCountOutputTypeCountLearningOutcomesArgs
    requirements?: boolean | CourseCountOutputTypeCountRequirementsArgs
    assessments?: boolean | CourseCountOutputTypeCountAssessmentsArgs
    flashcards?: boolean | CourseCountOutputTypeCountFlashcardsArgs
    chatbotMessages?: boolean | CourseCountOutputTypeCountChatbotMessagesArgs
    savedAnswers?: boolean | CourseCountOutputTypeCountSavedAnswersArgs
    tags?: boolean | CourseCountOutputTypeCountTagsArgs
    reviews?: boolean | CourseCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLearningOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningOutcomeWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRequirementWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFlashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountChatbotMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotMessageWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSavedAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedAnswerWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagsWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseReviewWhereInput
  }


  /**
   * Count Type CourseModuleCountOutputType
   */

  export type CourseModuleCountOutputType = {
    units: number
    quizzes: number
    exercises: number
    userProgress: number
    flashcards: number
    chatbotMessages: number
  }

  export type CourseModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | CourseModuleCountOutputTypeCountUnitsArgs
    quizzes?: boolean | CourseModuleCountOutputTypeCountQuizzesArgs
    exercises?: boolean | CourseModuleCountOutputTypeCountExercisesArgs
    userProgress?: boolean | CourseModuleCountOutputTypeCountUserProgressArgs
    flashcards?: boolean | CourseModuleCountOutputTypeCountFlashcardsArgs
    chatbotMessages?: boolean | CourseModuleCountOutputTypeCountChatbotMessagesArgs
  }

  // Custom InputTypes
  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModuleCountOutputType
     */
    select?: CourseModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentUnitWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleProgressWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountFlashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountChatbotMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotMessageWhereInput
  }


  /**
   * Count Type ContentUnitCountOutputType
   */

  export type ContentUnitCountOutputType = {
    progress: number
    attachments: number
  }

  export type ContentUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | ContentUnitCountOutputTypeCountProgressArgs
    attachments?: boolean | ContentUnitCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * ContentUnitCountOutputType without action
   */
  export type ContentUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnitCountOutputType
     */
    select?: ContentUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentUnitCountOutputType without action
   */
  export type ContentUnitCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitProgressWhereInput
  }

  /**
   * ContentUnitCountOutputType without action
   */
  export type ContentUnitCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAttachmentWhereInput
  }


  /**
   * Count Type EnrollmentCountOutputType
   */

  export type EnrollmentCountOutputType = {
    moduleProgress: number
    unitProgress: number
    quizAttempts: number
    exerciseSubmissions: number
  }

  export type EnrollmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moduleProgress?: boolean | EnrollmentCountOutputTypeCountModuleProgressArgs
    unitProgress?: boolean | EnrollmentCountOutputTypeCountUnitProgressArgs
    quizAttempts?: boolean | EnrollmentCountOutputTypeCountQuizAttemptsArgs
    exerciseSubmissions?: boolean | EnrollmentCountOutputTypeCountExerciseSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentCountOutputType
     */
    select?: EnrollmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeCountModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleProgressWhereInput
  }

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeCountUnitProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitProgressWhereInput
  }

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeCountExerciseSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
    attempts: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    attempts?: boolean | QuizCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }


  /**
   * Count Type QuizQuestionCountOutputType
   */

  export type QuizQuestionCountOutputType = {
    answers: number
  }

  export type QuizQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type QuizAttemptCountOutputType
   */

  export type QuizAttemptCountOutputType = {
    answers: number
  }

  export type QuizAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizAttemptCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttemptCountOutputType
     */
    select?: QuizAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    submissions: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | ExerciseCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
  }


  /**
   * Count Type MentorshipProgramCountOutputType
   */

  export type MentorshipProgramCountOutputType = {
    relationships: number
  }

  export type MentorshipProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationships?: boolean | MentorshipProgramCountOutputTypeCountRelationshipsArgs
  }

  // Custom InputTypes
  /**
   * MentorshipProgramCountOutputType without action
   */
  export type MentorshipProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgramCountOutputType
     */
    select?: MentorshipProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MentorshipProgramCountOutputType without action
   */
  export type MentorshipProgramCountOutputTypeCountRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
  }


  /**
   * Count Type MentorshipCountOutputType
   */

  export type MentorshipCountOutputType = {
    sessions: number
  }

  export type MentorshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | MentorshipCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipCountOutputType
     */
    select?: MentorshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MentorshipCountOutputType without action
   */
  export type MentorshipCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipSessionWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    registrations: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrations?: boolean | EventCountOutputTypeCountRegistrationsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    members: number
    posts: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | CommunityCountOutputTypeCountMembersArgs
    posts?: boolean | CommunityCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMemberWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }


  /**
   * Count Type SponsorCountOutputType
   */

  export type SponsorCountOutputType = {
    sponsorships: number
  }

  export type SponsorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsorships?: boolean | SponsorCountOutputTypeCountSponsorshipsArgs
  }

  // Custom InputTypes
  /**
   * SponsorCountOutputType without action
   */
  export type SponsorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorCountOutputType
     */
    select?: SponsorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SponsorCountOutputType without action
   */
  export type SponsorCountOutputTypeCountSponsorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorshipWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type AssessmentCountOutputType
   */

  export type AssessmentCountOutputType = {
    questions: number
    attempts: number
  }

  export type AssessmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | AssessmentCountOutputTypeCountQuestionsArgs
    attempts?: boolean | AssessmentCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentCountOutputType
     */
    select?: AssessmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentAttemptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    dateOfBirth: Date | null
    age: number | null
    phone: string | null
    country: string | null
    city: string | null
    bio: string | null
    profileImage: string | null
    gender: $Enums.Gender | null
    isActive: boolean | null
    emailVerified: boolean | null
    verificationToken: string | null
    verificationExpires: Date | null
    lastActive: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    dateOfBirth: Date | null
    age: number | null
    phone: string | null
    country: string | null
    city: string | null
    bio: string | null
    profileImage: string | null
    gender: $Enums.Gender | null
    isActive: boolean | null
    emailVerified: boolean | null
    verificationToken: string | null
    verificationExpires: Date | null
    lastActive: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    dateOfBirth: number
    age: number
    phone: number
    country: number
    city: number
    bio: number
    profileImage: number
    gender: number
    isActive: number
    emailVerified: number
    verificationToken: number
    verificationExpires: number
    lastActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    dateOfBirth?: true
    age?: true
    phone?: true
    country?: true
    city?: true
    bio?: true
    profileImage?: true
    gender?: true
    isActive?: true
    emailVerified?: true
    verificationToken?: true
    verificationExpires?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    dateOfBirth?: true
    age?: true
    phone?: true
    country?: true
    city?: true
    bio?: true
    profileImage?: true
    gender?: true
    isActive?: true
    emailVerified?: true
    verificationToken?: true
    verificationExpires?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    dateOfBirth?: true
    age?: true
    phone?: true
    country?: true
    city?: true
    bio?: true
    profileImage?: true
    gender?: true
    isActive?: true
    emailVerified?: true
    verificationToken?: true
    verificationExpires?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    dateOfBirth: Date | null
    age: number | null
    phone: string | null
    country: string | null
    city: string | null
    bio: string | null
    profileImage: string | null
    gender: $Enums.Gender | null
    isActive: boolean
    emailVerified: boolean
    verificationToken: string | null
    verificationExpires: Date | null
    lastActive: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    dateOfBirth?: boolean
    age?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    bio?: boolean
    profileImage?: boolean
    gender?: boolean
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    userSkills?: boolean | User$userSkillsArgs<ExtArgs>
    menteeRelationships?: boolean | User$menteeRelationshipsArgs<ExtArgs>
    mentorRelationships?: boolean | User$mentorRelationshipsArgs<ExtArgs>
    instructedCourses?: boolean | User$instructedCoursesArgs<ExtArgs>
    eventRegistrations?: boolean | User$eventRegistrationsArgs<ExtArgs>
    createdCommunities?: boolean | User$createdCommunitiesArgs<ExtArgs>
    communityMemberships?: boolean | User$communityMembershipsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    uploadedResources?: boolean | User$uploadedResourcesArgs<ExtArgs>
    assessmentAttempts?: boolean | User$assessmentAttemptsArgs<ExtArgs>
    providedFeedback?: boolean | User$providedFeedbackArgs<ExtArgs>
    userInteractions?: boolean | User$userInteractionsArgs<ExtArgs>
    flashcards?: boolean | User$flashcardsArgs<ExtArgs>
    flashcardCollections?: boolean | User$flashcardCollectionsArgs<ExtArgs>
    chatbotSessions?: boolean | User$chatbotSessionsArgs<ExtArgs>
    chatbotFeedback?: boolean | User$chatbotFeedbackArgs<ExtArgs>
    savedAnswers?: boolean | User$savedAnswersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    dateOfBirth?: boolean
    age?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    bio?: boolean
    profileImage?: boolean
    gender?: boolean
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    dateOfBirth?: boolean
    age?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    bio?: boolean
    profileImage?: boolean
    gender?: boolean
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    dateOfBirth?: boolean
    age?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    bio?: boolean
    profileImage?: boolean
    gender?: boolean
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationExpires?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "role" | "dateOfBirth" | "age" | "phone" | "country" | "city" | "bio" | "profileImage" | "gender" | "isActive" | "emailVerified" | "verificationToken" | "verificationExpires" | "lastActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    userSkills?: boolean | User$userSkillsArgs<ExtArgs>
    menteeRelationships?: boolean | User$menteeRelationshipsArgs<ExtArgs>
    mentorRelationships?: boolean | User$mentorRelationshipsArgs<ExtArgs>
    instructedCourses?: boolean | User$instructedCoursesArgs<ExtArgs>
    eventRegistrations?: boolean | User$eventRegistrationsArgs<ExtArgs>
    createdCommunities?: boolean | User$createdCommunitiesArgs<ExtArgs>
    communityMemberships?: boolean | User$communityMembershipsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    uploadedResources?: boolean | User$uploadedResourcesArgs<ExtArgs>
    assessmentAttempts?: boolean | User$assessmentAttemptsArgs<ExtArgs>
    providedFeedback?: boolean | User$providedFeedbackArgs<ExtArgs>
    userInteractions?: boolean | User$userInteractionsArgs<ExtArgs>
    flashcards?: boolean | User$flashcardsArgs<ExtArgs>
    flashcardCollections?: boolean | User$flashcardCollectionsArgs<ExtArgs>
    chatbotSessions?: boolean | User$chatbotSessionsArgs<ExtArgs>
    chatbotFeedback?: boolean | User$chatbotFeedbackArgs<ExtArgs>
    savedAnswers?: boolean | User$savedAnswersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      reviews: Prisma.$CourseReviewPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      userSkills: Prisma.$UserSkillPayload<ExtArgs>[]
      menteeRelationships: Prisma.$MentorshipPayload<ExtArgs>[]
      mentorRelationships: Prisma.$MentorshipPayload<ExtArgs>[]
      instructedCourses: Prisma.$CoursePayload<ExtArgs>[]
      eventRegistrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
      createdCommunities: Prisma.$CommunityPayload<ExtArgs>[]
      communityMemberships: Prisma.$CommunityMemberPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      createdProjects: Prisma.$ProjectPayload<ExtArgs>[]
      projectMemberships: Prisma.$ProjectMemberPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      uploadedResources: Prisma.$ResourcePayload<ExtArgs>[]
      assessmentAttempts: Prisma.$UserAssessmentAttemptPayload<ExtArgs>[]
      providedFeedback: Prisma.$FeedbackPayload<ExtArgs>[]
      userInteractions: Prisma.$FlashcardInteractionPayload<ExtArgs>[]
      flashcards: Prisma.$FlashcardPayload<ExtArgs>[]
      flashcardCollections: Prisma.$FlashcardCollectionPayload<ExtArgs>[]
      chatbotSessions: Prisma.$ChatbotSessionPayload<ExtArgs>[]
      chatbotFeedback: Prisma.$ChatbotFeedbackPayload<ExtArgs>[]
      savedAnswers: Prisma.$SavedAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      dateOfBirth: Date | null
      age: number | null
      phone: string | null
      country: string | null
      city: string | null
      bio: string | null
      profileImage: string | null
      gender: $Enums.Gender | null
      isActive: boolean
      emailVerified: boolean
      verificationToken: string | null
      verificationExpires: Date | null
      lastActive: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSkills<T extends User$userSkillsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menteeRelationships<T extends User$menteeRelationshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$menteeRelationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentorRelationships<T extends User$mentorRelationshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$mentorRelationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructedCourses<T extends User$instructedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$instructedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventRegistrations<T extends User$eventRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCommunities<T extends User$createdCommunitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCommunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communityMemberships<T extends User$communityMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$communityMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdProjects<T extends User$createdProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMemberships<T extends User$projectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedResources<T extends User$uploadedResourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assessmentAttempts<T extends User$assessmentAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$assessmentAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providedFeedback<T extends User$providedFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$providedFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userInteractions<T extends User$userInteractionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userInteractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flashcards<T extends User$flashcardsArgs<ExtArgs> = {}>(args?: Subset<T, User$flashcardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flashcardCollections<T extends User$flashcardCollectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$flashcardCollectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatbotSessions<T extends User$chatbotSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatbotSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatbotFeedback<T extends User$chatbotFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$chatbotFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedAnswers<T extends User$savedAnswersArgs<ExtArgs> = {}>(args?: Subset<T, User$savedAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly age: FieldRef<"User", 'Int'>
    readonly phone: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly verificationExpires: FieldRef<"User", 'DateTime'>
    readonly lastActive: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    where?: CourseReviewWhereInput
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    cursor?: CourseReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.userSkills
   */
  export type User$userSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    where?: UserSkillWhereInput
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    cursor?: UserSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * User.menteeRelationships
   */
  export type User$menteeRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    cursor?: MentorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * User.mentorRelationships
   */
  export type User$mentorRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    cursor?: MentorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * User.instructedCourses
   */
  export type User$instructedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.eventRegistrations
   */
  export type User$eventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * User.createdCommunities
   */
  export type User$createdCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    cursor?: CommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * User.communityMemberships
   */
  export type User$communityMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    where?: CommunityMemberWhereInput
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    cursor?: CommunityMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.createdProjects
   */
  export type User$createdProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.projectMemberships
   */
  export type User$projectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.uploadedResources
   */
  export type User$uploadedResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * User.assessmentAttempts
   */
  export type User$assessmentAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    where?: UserAssessmentAttemptWhereInput
    orderBy?: UserAssessmentAttemptOrderByWithRelationInput | UserAssessmentAttemptOrderByWithRelationInput[]
    cursor?: UserAssessmentAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssessmentAttemptScalarFieldEnum | UserAssessmentAttemptScalarFieldEnum[]
  }

  /**
   * User.providedFeedback
   */
  export type User$providedFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.userInteractions
   */
  export type User$userInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    where?: FlashcardInteractionWhereInput
    orderBy?: FlashcardInteractionOrderByWithRelationInput | FlashcardInteractionOrderByWithRelationInput[]
    cursor?: FlashcardInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardInteractionScalarFieldEnum | FlashcardInteractionScalarFieldEnum[]
  }

  /**
   * User.flashcards
   */
  export type User$flashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    where?: FlashcardWhereInput
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    cursor?: FlashcardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * User.flashcardCollections
   */
  export type User$flashcardCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    where?: FlashcardCollectionWhereInput
    orderBy?: FlashcardCollectionOrderByWithRelationInput | FlashcardCollectionOrderByWithRelationInput[]
    cursor?: FlashcardCollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardCollectionScalarFieldEnum | FlashcardCollectionScalarFieldEnum[]
  }

  /**
   * User.chatbotSessions
   */
  export type User$chatbotSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    where?: ChatbotSessionWhereInput
    orderBy?: ChatbotSessionOrderByWithRelationInput | ChatbotSessionOrderByWithRelationInput[]
    cursor?: ChatbotSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotSessionScalarFieldEnum | ChatbotSessionScalarFieldEnum[]
  }

  /**
   * User.chatbotFeedback
   */
  export type User$chatbotFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    where?: ChatbotFeedbackWhereInput
    orderBy?: ChatbotFeedbackOrderByWithRelationInput | ChatbotFeedbackOrderByWithRelationInput[]
    cursor?: ChatbotFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotFeedbackScalarFieldEnum | ChatbotFeedbackScalarFieldEnum[]
  }

  /**
   * User.savedAnswers
   */
  export type User$savedAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    where?: SavedAnswerWhereInput
    orderBy?: SavedAnswerOrderByWithRelationInput | SavedAnswerOrderByWithRelationInput[]
    cursor?: SavedAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedAnswerScalarFieldEnum | SavedAnswerScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Flashcard
   */

  export type AggregateFlashcard = {
    _count: FlashcardCountAggregateOutputType | null
    _avg: FlashcardAvgAggregateOutputType | null
    _sum: FlashcardSumAggregateOutputType | null
    _min: FlashcardMinAggregateOutputType | null
    _max: FlashcardMaxAggregateOutputType | null
  }

  export type FlashcardAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    moduleId: number | null
    difficultyLevel: number | null
    timesReviewed: number | null
    confidenceLevel: number | null
  }

  export type FlashcardSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    moduleId: number | null
    difficultyLevel: number | null
    timesReviewed: number | null
    confidenceLevel: number | null
  }

  export type FlashcardMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    moduleId: number | null
    question: string | null
    answer: string | null
    difficultyLevel: number | null
    tags: string | null
    aiGenerated: boolean | null
    createdAt: Date | null
    lastReviewed: Date | null
    timesReviewed: number | null
    confidenceLevel: number | null
    aiModel: string | null
    generationPrompt: string | null
    sourceContentSnippet: string | null
  }

  export type FlashcardMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    moduleId: number | null
    question: string | null
    answer: string | null
    difficultyLevel: number | null
    tags: string | null
    aiGenerated: boolean | null
    createdAt: Date | null
    lastReviewed: Date | null
    timesReviewed: number | null
    confidenceLevel: number | null
    aiModel: string | null
    generationPrompt: string | null
    sourceContentSnippet: string | null
  }

  export type FlashcardCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    moduleId: number
    question: number
    answer: number
    difficultyLevel: number
    tags: number
    aiGenerated: number
    createdAt: number
    lastReviewed: number
    timesReviewed: number
    confidenceLevel: number
    aiModel: number
    generationPrompt: number
    sourceContentSnippet: number
    _all: number
  }


  export type FlashcardAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    moduleId?: true
    difficultyLevel?: true
    timesReviewed?: true
    confidenceLevel?: true
  }

  export type FlashcardSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    moduleId?: true
    difficultyLevel?: true
    timesReviewed?: true
    confidenceLevel?: true
  }

  export type FlashcardMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    moduleId?: true
    question?: true
    answer?: true
    difficultyLevel?: true
    tags?: true
    aiGenerated?: true
    createdAt?: true
    lastReviewed?: true
    timesReviewed?: true
    confidenceLevel?: true
    aiModel?: true
    generationPrompt?: true
    sourceContentSnippet?: true
  }

  export type FlashcardMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    moduleId?: true
    question?: true
    answer?: true
    difficultyLevel?: true
    tags?: true
    aiGenerated?: true
    createdAt?: true
    lastReviewed?: true
    timesReviewed?: true
    confidenceLevel?: true
    aiModel?: true
    generationPrompt?: true
    sourceContentSnippet?: true
  }

  export type FlashcardCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    moduleId?: true
    question?: true
    answer?: true
    difficultyLevel?: true
    tags?: true
    aiGenerated?: true
    createdAt?: true
    lastReviewed?: true
    timesReviewed?: true
    confidenceLevel?: true
    aiModel?: true
    generationPrompt?: true
    sourceContentSnippet?: true
    _all?: true
  }

  export type FlashcardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flashcard to aggregate.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flashcards
    **/
    _count?: true | FlashcardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlashcardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlashcardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlashcardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlashcardMaxAggregateInputType
  }

  export type GetFlashcardAggregateType<T extends FlashcardAggregateArgs> = {
        [P in keyof T & keyof AggregateFlashcard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlashcard[P]>
      : GetScalarType<T[P], AggregateFlashcard[P]>
  }




  export type FlashcardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardWhereInput
    orderBy?: FlashcardOrderByWithAggregationInput | FlashcardOrderByWithAggregationInput[]
    by: FlashcardScalarFieldEnum[] | FlashcardScalarFieldEnum
    having?: FlashcardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlashcardCountAggregateInputType | true
    _avg?: FlashcardAvgAggregateInputType
    _sum?: FlashcardSumAggregateInputType
    _min?: FlashcardMinAggregateInputType
    _max?: FlashcardMaxAggregateInputType
  }

  export type FlashcardGroupByOutputType = {
    id: number
    userId: number
    courseId: number | null
    moduleId: number | null
    question: string
    answer: string
    difficultyLevel: number
    tags: string | null
    aiGenerated: boolean
    createdAt: Date
    lastReviewed: Date | null
    timesReviewed: number
    confidenceLevel: number | null
    aiModel: string | null
    generationPrompt: string | null
    sourceContentSnippet: string | null
    _count: FlashcardCountAggregateOutputType | null
    _avg: FlashcardAvgAggregateOutputType | null
    _sum: FlashcardSumAggregateOutputType | null
    _min: FlashcardMinAggregateOutputType | null
    _max: FlashcardMaxAggregateOutputType | null
  }

  type GetFlashcardGroupByPayload<T extends FlashcardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlashcardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlashcardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlashcardGroupByOutputType[P]>
            : GetScalarType<T[P], FlashcardGroupByOutputType[P]>
        }
      >
    >


  export type FlashcardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    question?: boolean
    answer?: boolean
    difficultyLevel?: boolean
    tags?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    lastReviewed?: boolean
    timesReviewed?: boolean
    confidenceLevel?: boolean
    aiModel?: boolean
    generationPrompt?: boolean
    sourceContentSnippet?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Flashcard$courseArgs<ExtArgs>
    module?: boolean | Flashcard$moduleArgs<ExtArgs>
    userInteractions?: boolean | Flashcard$userInteractionsArgs<ExtArgs>
    collections?: boolean | Flashcard$collectionsArgs<ExtArgs>
    _count?: boolean | FlashcardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcard"]>

  export type FlashcardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    question?: boolean
    answer?: boolean
    difficultyLevel?: boolean
    tags?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    lastReviewed?: boolean
    timesReviewed?: boolean
    confidenceLevel?: boolean
    aiModel?: boolean
    generationPrompt?: boolean
    sourceContentSnippet?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Flashcard$courseArgs<ExtArgs>
    module?: boolean | Flashcard$moduleArgs<ExtArgs>
  }, ExtArgs["result"]["flashcard"]>

  export type FlashcardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    question?: boolean
    answer?: boolean
    difficultyLevel?: boolean
    tags?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    lastReviewed?: boolean
    timesReviewed?: boolean
    confidenceLevel?: boolean
    aiModel?: boolean
    generationPrompt?: boolean
    sourceContentSnippet?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Flashcard$courseArgs<ExtArgs>
    module?: boolean | Flashcard$moduleArgs<ExtArgs>
  }, ExtArgs["result"]["flashcard"]>

  export type FlashcardSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    question?: boolean
    answer?: boolean
    difficultyLevel?: boolean
    tags?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    lastReviewed?: boolean
    timesReviewed?: boolean
    confidenceLevel?: boolean
    aiModel?: boolean
    generationPrompt?: boolean
    sourceContentSnippet?: boolean
  }

  export type FlashcardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "moduleId" | "question" | "answer" | "difficultyLevel" | "tags" | "aiGenerated" | "createdAt" | "lastReviewed" | "timesReviewed" | "confidenceLevel" | "aiModel" | "generationPrompt" | "sourceContentSnippet", ExtArgs["result"]["flashcard"]>
  export type FlashcardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Flashcard$courseArgs<ExtArgs>
    module?: boolean | Flashcard$moduleArgs<ExtArgs>
    userInteractions?: boolean | Flashcard$userInteractionsArgs<ExtArgs>
    collections?: boolean | Flashcard$collectionsArgs<ExtArgs>
    _count?: boolean | FlashcardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlashcardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Flashcard$courseArgs<ExtArgs>
    module?: boolean | Flashcard$moduleArgs<ExtArgs>
  }
  export type FlashcardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Flashcard$courseArgs<ExtArgs>
    module?: boolean | Flashcard$moduleArgs<ExtArgs>
  }

  export type $FlashcardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flashcard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$CourseModulePayload<ExtArgs> | null
      userInteractions: Prisma.$FlashcardInteractionPayload<ExtArgs>[]
      collections: Prisma.$FlashcardCollectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number | null
      moduleId: number | null
      question: string
      answer: string
      difficultyLevel: number
      tags: string | null
      aiGenerated: boolean
      createdAt: Date
      lastReviewed: Date | null
      timesReviewed: number
      confidenceLevel: number | null
      aiModel: string | null
      generationPrompt: string | null
      sourceContentSnippet: string | null
    }, ExtArgs["result"]["flashcard"]>
    composites: {}
  }

  type FlashcardGetPayload<S extends boolean | null | undefined | FlashcardDefaultArgs> = $Result.GetResult<Prisma.$FlashcardPayload, S>

  type FlashcardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlashcardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlashcardCountAggregateInputType | true
    }

  export interface FlashcardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flashcard'], meta: { name: 'Flashcard' } }
    /**
     * Find zero or one Flashcard that matches the filter.
     * @param {FlashcardFindUniqueArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlashcardFindUniqueArgs>(args: SelectSubset<T, FlashcardFindUniqueArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flashcard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlashcardFindUniqueOrThrowArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlashcardFindUniqueOrThrowArgs>(args: SelectSubset<T, FlashcardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flashcard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardFindFirstArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlashcardFindFirstArgs>(args?: SelectSubset<T, FlashcardFindFirstArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flashcard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardFindFirstOrThrowArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlashcardFindFirstOrThrowArgs>(args?: SelectSubset<T, FlashcardFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flashcards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flashcards
     * const flashcards = await prisma.flashcard.findMany()
     * 
     * // Get first 10 Flashcards
     * const flashcards = await prisma.flashcard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flashcardWithIdOnly = await prisma.flashcard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlashcardFindManyArgs>(args?: SelectSubset<T, FlashcardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flashcard.
     * @param {FlashcardCreateArgs} args - Arguments to create a Flashcard.
     * @example
     * // Create one Flashcard
     * const Flashcard = await prisma.flashcard.create({
     *   data: {
     *     // ... data to create a Flashcard
     *   }
     * })
     * 
     */
    create<T extends FlashcardCreateArgs>(args: SelectSubset<T, FlashcardCreateArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flashcards.
     * @param {FlashcardCreateManyArgs} args - Arguments to create many Flashcards.
     * @example
     * // Create many Flashcards
     * const flashcard = await prisma.flashcard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlashcardCreateManyArgs>(args?: SelectSubset<T, FlashcardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flashcards and returns the data saved in the database.
     * @param {FlashcardCreateManyAndReturnArgs} args - Arguments to create many Flashcards.
     * @example
     * // Create many Flashcards
     * const flashcard = await prisma.flashcard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flashcards and only return the `id`
     * const flashcardWithIdOnly = await prisma.flashcard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlashcardCreateManyAndReturnArgs>(args?: SelectSubset<T, FlashcardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flashcard.
     * @param {FlashcardDeleteArgs} args - Arguments to delete one Flashcard.
     * @example
     * // Delete one Flashcard
     * const Flashcard = await prisma.flashcard.delete({
     *   where: {
     *     // ... filter to delete one Flashcard
     *   }
     * })
     * 
     */
    delete<T extends FlashcardDeleteArgs>(args: SelectSubset<T, FlashcardDeleteArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flashcard.
     * @param {FlashcardUpdateArgs} args - Arguments to update one Flashcard.
     * @example
     * // Update one Flashcard
     * const flashcard = await prisma.flashcard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlashcardUpdateArgs>(args: SelectSubset<T, FlashcardUpdateArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flashcards.
     * @param {FlashcardDeleteManyArgs} args - Arguments to filter Flashcards to delete.
     * @example
     * // Delete a few Flashcards
     * const { count } = await prisma.flashcard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlashcardDeleteManyArgs>(args?: SelectSubset<T, FlashcardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flashcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flashcards
     * const flashcard = await prisma.flashcard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlashcardUpdateManyArgs>(args: SelectSubset<T, FlashcardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flashcards and returns the data updated in the database.
     * @param {FlashcardUpdateManyAndReturnArgs} args - Arguments to update many Flashcards.
     * @example
     * // Update many Flashcards
     * const flashcard = await prisma.flashcard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flashcards and only return the `id`
     * const flashcardWithIdOnly = await prisma.flashcard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlashcardUpdateManyAndReturnArgs>(args: SelectSubset<T, FlashcardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flashcard.
     * @param {FlashcardUpsertArgs} args - Arguments to update or create a Flashcard.
     * @example
     * // Update or create a Flashcard
     * const flashcard = await prisma.flashcard.upsert({
     *   create: {
     *     // ... data to create a Flashcard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flashcard we want to update
     *   }
     * })
     */
    upsert<T extends FlashcardUpsertArgs>(args: SelectSubset<T, FlashcardUpsertArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flashcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCountArgs} args - Arguments to filter Flashcards to count.
     * @example
     * // Count the number of Flashcards
     * const count = await prisma.flashcard.count({
     *   where: {
     *     // ... the filter for the Flashcards we want to count
     *   }
     * })
    **/
    count<T extends FlashcardCountArgs>(
      args?: Subset<T, FlashcardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlashcardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flashcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlashcardAggregateArgs>(args: Subset<T, FlashcardAggregateArgs>): Prisma.PrismaPromise<GetFlashcardAggregateType<T>>

    /**
     * Group by Flashcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlashcardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlashcardGroupByArgs['orderBy'] }
        : { orderBy?: FlashcardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlashcardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlashcardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flashcard model
   */
  readonly fields: FlashcardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flashcard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlashcardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends Flashcard$courseArgs<ExtArgs> = {}>(args?: Subset<T, Flashcard$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    module<T extends Flashcard$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Flashcard$moduleArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userInteractions<T extends Flashcard$userInteractionsArgs<ExtArgs> = {}>(args?: Subset<T, Flashcard$userInteractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collections<T extends Flashcard$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, Flashcard$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flashcard model
   */
  interface FlashcardFieldRefs {
    readonly id: FieldRef<"Flashcard", 'Int'>
    readonly userId: FieldRef<"Flashcard", 'Int'>
    readonly courseId: FieldRef<"Flashcard", 'Int'>
    readonly moduleId: FieldRef<"Flashcard", 'Int'>
    readonly question: FieldRef<"Flashcard", 'String'>
    readonly answer: FieldRef<"Flashcard", 'String'>
    readonly difficultyLevel: FieldRef<"Flashcard", 'Int'>
    readonly tags: FieldRef<"Flashcard", 'String'>
    readonly aiGenerated: FieldRef<"Flashcard", 'Boolean'>
    readonly createdAt: FieldRef<"Flashcard", 'DateTime'>
    readonly lastReviewed: FieldRef<"Flashcard", 'DateTime'>
    readonly timesReviewed: FieldRef<"Flashcard", 'Int'>
    readonly confidenceLevel: FieldRef<"Flashcard", 'Int'>
    readonly aiModel: FieldRef<"Flashcard", 'String'>
    readonly generationPrompt: FieldRef<"Flashcard", 'String'>
    readonly sourceContentSnippet: FieldRef<"Flashcard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Flashcard findUnique
   */
  export type FlashcardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard findUniqueOrThrow
   */
  export type FlashcardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard findFirst
   */
  export type FlashcardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flashcards.
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flashcards.
     */
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Flashcard findFirstOrThrow
   */
  export type FlashcardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flashcards.
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flashcards.
     */
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Flashcard findMany
   */
  export type FlashcardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcards to fetch.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flashcards.
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Flashcard create
   */
  export type FlashcardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * The data needed to create a Flashcard.
     */
    data: XOR<FlashcardCreateInput, FlashcardUncheckedCreateInput>
  }

  /**
   * Flashcard createMany
   */
  export type FlashcardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flashcards.
     */
    data: FlashcardCreateManyInput | FlashcardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flashcard createManyAndReturn
   */
  export type FlashcardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * The data used to create many Flashcards.
     */
    data: FlashcardCreateManyInput | FlashcardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flashcard update
   */
  export type FlashcardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * The data needed to update a Flashcard.
     */
    data: XOR<FlashcardUpdateInput, FlashcardUncheckedUpdateInput>
    /**
     * Choose, which Flashcard to update.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard updateMany
   */
  export type FlashcardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flashcards.
     */
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyInput>
    /**
     * Filter which Flashcards to update
     */
    where?: FlashcardWhereInput
    /**
     * Limit how many Flashcards to update.
     */
    limit?: number
  }

  /**
   * Flashcard updateManyAndReturn
   */
  export type FlashcardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * The data used to update Flashcards.
     */
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyInput>
    /**
     * Filter which Flashcards to update
     */
    where?: FlashcardWhereInput
    /**
     * Limit how many Flashcards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flashcard upsert
   */
  export type FlashcardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * The filter to search for the Flashcard to update in case it exists.
     */
    where: FlashcardWhereUniqueInput
    /**
     * In case the Flashcard found by the `where` argument doesn't exist, create a new Flashcard with this data.
     */
    create: XOR<FlashcardCreateInput, FlashcardUncheckedCreateInput>
    /**
     * In case the Flashcard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlashcardUpdateInput, FlashcardUncheckedUpdateInput>
  }

  /**
   * Flashcard delete
   */
  export type FlashcardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter which Flashcard to delete.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard deleteMany
   */
  export type FlashcardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flashcards to delete
     */
    where?: FlashcardWhereInput
    /**
     * Limit how many Flashcards to delete.
     */
    limit?: number
  }

  /**
   * Flashcard.course
   */
  export type Flashcard$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Flashcard.module
   */
  export type Flashcard$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
  }

  /**
   * Flashcard.userInteractions
   */
  export type Flashcard$userInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    where?: FlashcardInteractionWhereInput
    orderBy?: FlashcardInteractionOrderByWithRelationInput | FlashcardInteractionOrderByWithRelationInput[]
    cursor?: FlashcardInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardInteractionScalarFieldEnum | FlashcardInteractionScalarFieldEnum[]
  }

  /**
   * Flashcard.collections
   */
  export type Flashcard$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    where?: FlashcardCollectionItemWhereInput
    orderBy?: FlashcardCollectionItemOrderByWithRelationInput | FlashcardCollectionItemOrderByWithRelationInput[]
    cursor?: FlashcardCollectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardCollectionItemScalarFieldEnum | FlashcardCollectionItemScalarFieldEnum[]
  }

  /**
   * Flashcard without action
   */
  export type FlashcardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
  }


  /**
   * Model FlashcardInteraction
   */

  export type AggregateFlashcardInteraction = {
    _count: FlashcardInteractionCountAggregateOutputType | null
    _avg: FlashcardInteractionAvgAggregateOutputType | null
    _sum: FlashcardInteractionSumAggregateOutputType | null
    _min: FlashcardInteractionMinAggregateOutputType | null
    _max: FlashcardInteractionMaxAggregateOutputType | null
  }

  export type FlashcardInteractionAvgAggregateOutputType = {
    id: number | null
    flashcardId: number | null
    userId: number | null
    responseTime: number | null
  }

  export type FlashcardInteractionSumAggregateOutputType = {
    id: number | null
    flashcardId: number | null
    userId: number | null
    responseTime: number | null
  }

  export type FlashcardInteractionMinAggregateOutputType = {
    id: number | null
    flashcardId: number | null
    userId: number | null
    correct: boolean | null
    responseTime: number | null
    interactionDate: Date | null
  }

  export type FlashcardInteractionMaxAggregateOutputType = {
    id: number | null
    flashcardId: number | null
    userId: number | null
    correct: boolean | null
    responseTime: number | null
    interactionDate: Date | null
  }

  export type FlashcardInteractionCountAggregateOutputType = {
    id: number
    flashcardId: number
    userId: number
    correct: number
    responseTime: number
    interactionDate: number
    _all: number
  }


  export type FlashcardInteractionAvgAggregateInputType = {
    id?: true
    flashcardId?: true
    userId?: true
    responseTime?: true
  }

  export type FlashcardInteractionSumAggregateInputType = {
    id?: true
    flashcardId?: true
    userId?: true
    responseTime?: true
  }

  export type FlashcardInteractionMinAggregateInputType = {
    id?: true
    flashcardId?: true
    userId?: true
    correct?: true
    responseTime?: true
    interactionDate?: true
  }

  export type FlashcardInteractionMaxAggregateInputType = {
    id?: true
    flashcardId?: true
    userId?: true
    correct?: true
    responseTime?: true
    interactionDate?: true
  }

  export type FlashcardInteractionCountAggregateInputType = {
    id?: true
    flashcardId?: true
    userId?: true
    correct?: true
    responseTime?: true
    interactionDate?: true
    _all?: true
  }

  export type FlashcardInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlashcardInteraction to aggregate.
     */
    where?: FlashcardInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardInteractions to fetch.
     */
    orderBy?: FlashcardInteractionOrderByWithRelationInput | FlashcardInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlashcardInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlashcardInteractions
    **/
    _count?: true | FlashcardInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlashcardInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlashcardInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlashcardInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlashcardInteractionMaxAggregateInputType
  }

  export type GetFlashcardInteractionAggregateType<T extends FlashcardInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateFlashcardInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlashcardInteraction[P]>
      : GetScalarType<T[P], AggregateFlashcardInteraction[P]>
  }




  export type FlashcardInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardInteractionWhereInput
    orderBy?: FlashcardInteractionOrderByWithAggregationInput | FlashcardInteractionOrderByWithAggregationInput[]
    by: FlashcardInteractionScalarFieldEnum[] | FlashcardInteractionScalarFieldEnum
    having?: FlashcardInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlashcardInteractionCountAggregateInputType | true
    _avg?: FlashcardInteractionAvgAggregateInputType
    _sum?: FlashcardInteractionSumAggregateInputType
    _min?: FlashcardInteractionMinAggregateInputType
    _max?: FlashcardInteractionMaxAggregateInputType
  }

  export type FlashcardInteractionGroupByOutputType = {
    id: number
    flashcardId: number
    userId: number
    correct: boolean
    responseTime: number | null
    interactionDate: Date
    _count: FlashcardInteractionCountAggregateOutputType | null
    _avg: FlashcardInteractionAvgAggregateOutputType | null
    _sum: FlashcardInteractionSumAggregateOutputType | null
    _min: FlashcardInteractionMinAggregateOutputType | null
    _max: FlashcardInteractionMaxAggregateOutputType | null
  }

  type GetFlashcardInteractionGroupByPayload<T extends FlashcardInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlashcardInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlashcardInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlashcardInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], FlashcardInteractionGroupByOutputType[P]>
        }
      >
    >


  export type FlashcardInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flashcardId?: boolean
    userId?: boolean
    correct?: boolean
    responseTime?: boolean
    interactionDate?: boolean
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardInteraction"]>

  export type FlashcardInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flashcardId?: boolean
    userId?: boolean
    correct?: boolean
    responseTime?: boolean
    interactionDate?: boolean
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardInteraction"]>

  export type FlashcardInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flashcardId?: boolean
    userId?: boolean
    correct?: boolean
    responseTime?: boolean
    interactionDate?: boolean
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardInteraction"]>

  export type FlashcardInteractionSelectScalar = {
    id?: boolean
    flashcardId?: boolean
    userId?: boolean
    correct?: boolean
    responseTime?: boolean
    interactionDate?: boolean
  }

  export type FlashcardInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flashcardId" | "userId" | "correct" | "responseTime" | "interactionDate", ExtArgs["result"]["flashcardInteraction"]>
  export type FlashcardInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlashcardInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlashcardInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlashcardInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlashcardInteraction"
    objects: {
      flashcard: Prisma.$FlashcardPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      flashcardId: number
      userId: number
      correct: boolean
      responseTime: number | null
      interactionDate: Date
    }, ExtArgs["result"]["flashcardInteraction"]>
    composites: {}
  }

  type FlashcardInteractionGetPayload<S extends boolean | null | undefined | FlashcardInteractionDefaultArgs> = $Result.GetResult<Prisma.$FlashcardInteractionPayload, S>

  type FlashcardInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlashcardInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlashcardInteractionCountAggregateInputType | true
    }

  export interface FlashcardInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlashcardInteraction'], meta: { name: 'FlashcardInteraction' } }
    /**
     * Find zero or one FlashcardInteraction that matches the filter.
     * @param {FlashcardInteractionFindUniqueArgs} args - Arguments to find a FlashcardInteraction
     * @example
     * // Get one FlashcardInteraction
     * const flashcardInteraction = await prisma.flashcardInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlashcardInteractionFindUniqueArgs>(args: SelectSubset<T, FlashcardInteractionFindUniqueArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlashcardInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlashcardInteractionFindUniqueOrThrowArgs} args - Arguments to find a FlashcardInteraction
     * @example
     * // Get one FlashcardInteraction
     * const flashcardInteraction = await prisma.flashcardInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlashcardInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, FlashcardInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlashcardInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionFindFirstArgs} args - Arguments to find a FlashcardInteraction
     * @example
     * // Get one FlashcardInteraction
     * const flashcardInteraction = await prisma.flashcardInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlashcardInteractionFindFirstArgs>(args?: SelectSubset<T, FlashcardInteractionFindFirstArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlashcardInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionFindFirstOrThrowArgs} args - Arguments to find a FlashcardInteraction
     * @example
     * // Get one FlashcardInteraction
     * const flashcardInteraction = await prisma.flashcardInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlashcardInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, FlashcardInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlashcardInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlashcardInteractions
     * const flashcardInteractions = await prisma.flashcardInteraction.findMany()
     * 
     * // Get first 10 FlashcardInteractions
     * const flashcardInteractions = await prisma.flashcardInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flashcardInteractionWithIdOnly = await prisma.flashcardInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlashcardInteractionFindManyArgs>(args?: SelectSubset<T, FlashcardInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlashcardInteraction.
     * @param {FlashcardInteractionCreateArgs} args - Arguments to create a FlashcardInteraction.
     * @example
     * // Create one FlashcardInteraction
     * const FlashcardInteraction = await prisma.flashcardInteraction.create({
     *   data: {
     *     // ... data to create a FlashcardInteraction
     *   }
     * })
     * 
     */
    create<T extends FlashcardInteractionCreateArgs>(args: SelectSubset<T, FlashcardInteractionCreateArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlashcardInteractions.
     * @param {FlashcardInteractionCreateManyArgs} args - Arguments to create many FlashcardInteractions.
     * @example
     * // Create many FlashcardInteractions
     * const flashcardInteraction = await prisma.flashcardInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlashcardInteractionCreateManyArgs>(args?: SelectSubset<T, FlashcardInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlashcardInteractions and returns the data saved in the database.
     * @param {FlashcardInteractionCreateManyAndReturnArgs} args - Arguments to create many FlashcardInteractions.
     * @example
     * // Create many FlashcardInteractions
     * const flashcardInteraction = await prisma.flashcardInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlashcardInteractions and only return the `id`
     * const flashcardInteractionWithIdOnly = await prisma.flashcardInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlashcardInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, FlashcardInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlashcardInteraction.
     * @param {FlashcardInteractionDeleteArgs} args - Arguments to delete one FlashcardInteraction.
     * @example
     * // Delete one FlashcardInteraction
     * const FlashcardInteraction = await prisma.flashcardInteraction.delete({
     *   where: {
     *     // ... filter to delete one FlashcardInteraction
     *   }
     * })
     * 
     */
    delete<T extends FlashcardInteractionDeleteArgs>(args: SelectSubset<T, FlashcardInteractionDeleteArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlashcardInteraction.
     * @param {FlashcardInteractionUpdateArgs} args - Arguments to update one FlashcardInteraction.
     * @example
     * // Update one FlashcardInteraction
     * const flashcardInteraction = await prisma.flashcardInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlashcardInteractionUpdateArgs>(args: SelectSubset<T, FlashcardInteractionUpdateArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlashcardInteractions.
     * @param {FlashcardInteractionDeleteManyArgs} args - Arguments to filter FlashcardInteractions to delete.
     * @example
     * // Delete a few FlashcardInteractions
     * const { count } = await prisma.flashcardInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlashcardInteractionDeleteManyArgs>(args?: SelectSubset<T, FlashcardInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlashcardInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlashcardInteractions
     * const flashcardInteraction = await prisma.flashcardInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlashcardInteractionUpdateManyArgs>(args: SelectSubset<T, FlashcardInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlashcardInteractions and returns the data updated in the database.
     * @param {FlashcardInteractionUpdateManyAndReturnArgs} args - Arguments to update many FlashcardInteractions.
     * @example
     * // Update many FlashcardInteractions
     * const flashcardInteraction = await prisma.flashcardInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlashcardInteractions and only return the `id`
     * const flashcardInteractionWithIdOnly = await prisma.flashcardInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlashcardInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, FlashcardInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlashcardInteraction.
     * @param {FlashcardInteractionUpsertArgs} args - Arguments to update or create a FlashcardInteraction.
     * @example
     * // Update or create a FlashcardInteraction
     * const flashcardInteraction = await prisma.flashcardInteraction.upsert({
     *   create: {
     *     // ... data to create a FlashcardInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlashcardInteraction we want to update
     *   }
     * })
     */
    upsert<T extends FlashcardInteractionUpsertArgs>(args: SelectSubset<T, FlashcardInteractionUpsertArgs<ExtArgs>>): Prisma__FlashcardInteractionClient<$Result.GetResult<Prisma.$FlashcardInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlashcardInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionCountArgs} args - Arguments to filter FlashcardInteractions to count.
     * @example
     * // Count the number of FlashcardInteractions
     * const count = await prisma.flashcardInteraction.count({
     *   where: {
     *     // ... the filter for the FlashcardInteractions we want to count
     *   }
     * })
    **/
    count<T extends FlashcardInteractionCountArgs>(
      args?: Subset<T, FlashcardInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlashcardInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlashcardInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlashcardInteractionAggregateArgs>(args: Subset<T, FlashcardInteractionAggregateArgs>): Prisma.PrismaPromise<GetFlashcardInteractionAggregateType<T>>

    /**
     * Group by FlashcardInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlashcardInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlashcardInteractionGroupByArgs['orderBy'] }
        : { orderBy?: FlashcardInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlashcardInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlashcardInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlashcardInteraction model
   */
  readonly fields: FlashcardInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlashcardInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlashcardInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flashcard<T extends FlashcardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlashcardDefaultArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlashcardInteraction model
   */
  interface FlashcardInteractionFieldRefs {
    readonly id: FieldRef<"FlashcardInteraction", 'Int'>
    readonly flashcardId: FieldRef<"FlashcardInteraction", 'Int'>
    readonly userId: FieldRef<"FlashcardInteraction", 'Int'>
    readonly correct: FieldRef<"FlashcardInteraction", 'Boolean'>
    readonly responseTime: FieldRef<"FlashcardInteraction", 'Int'>
    readonly interactionDate: FieldRef<"FlashcardInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlashcardInteraction findUnique
   */
  export type FlashcardInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardInteraction to fetch.
     */
    where: FlashcardInteractionWhereUniqueInput
  }

  /**
   * FlashcardInteraction findUniqueOrThrow
   */
  export type FlashcardInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardInteraction to fetch.
     */
    where: FlashcardInteractionWhereUniqueInput
  }

  /**
   * FlashcardInteraction findFirst
   */
  export type FlashcardInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardInteraction to fetch.
     */
    where?: FlashcardInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardInteractions to fetch.
     */
    orderBy?: FlashcardInteractionOrderByWithRelationInput | FlashcardInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlashcardInteractions.
     */
    cursor?: FlashcardInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlashcardInteractions.
     */
    distinct?: FlashcardInteractionScalarFieldEnum | FlashcardInteractionScalarFieldEnum[]
  }

  /**
   * FlashcardInteraction findFirstOrThrow
   */
  export type FlashcardInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardInteraction to fetch.
     */
    where?: FlashcardInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardInteractions to fetch.
     */
    orderBy?: FlashcardInteractionOrderByWithRelationInput | FlashcardInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlashcardInteractions.
     */
    cursor?: FlashcardInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlashcardInteractions.
     */
    distinct?: FlashcardInteractionScalarFieldEnum | FlashcardInteractionScalarFieldEnum[]
  }

  /**
   * FlashcardInteraction findMany
   */
  export type FlashcardInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardInteractions to fetch.
     */
    where?: FlashcardInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardInteractions to fetch.
     */
    orderBy?: FlashcardInteractionOrderByWithRelationInput | FlashcardInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlashcardInteractions.
     */
    cursor?: FlashcardInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardInteractions.
     */
    skip?: number
    distinct?: FlashcardInteractionScalarFieldEnum | FlashcardInteractionScalarFieldEnum[]
  }

  /**
   * FlashcardInteraction create
   */
  export type FlashcardInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a FlashcardInteraction.
     */
    data: XOR<FlashcardInteractionCreateInput, FlashcardInteractionUncheckedCreateInput>
  }

  /**
   * FlashcardInteraction createMany
   */
  export type FlashcardInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlashcardInteractions.
     */
    data: FlashcardInteractionCreateManyInput | FlashcardInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlashcardInteraction createManyAndReturn
   */
  export type FlashcardInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many FlashcardInteractions.
     */
    data: FlashcardInteractionCreateManyInput | FlashcardInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlashcardInteraction update
   */
  export type FlashcardInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a FlashcardInteraction.
     */
    data: XOR<FlashcardInteractionUpdateInput, FlashcardInteractionUncheckedUpdateInput>
    /**
     * Choose, which FlashcardInteraction to update.
     */
    where: FlashcardInteractionWhereUniqueInput
  }

  /**
   * FlashcardInteraction updateMany
   */
  export type FlashcardInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlashcardInteractions.
     */
    data: XOR<FlashcardInteractionUpdateManyMutationInput, FlashcardInteractionUncheckedUpdateManyInput>
    /**
     * Filter which FlashcardInteractions to update
     */
    where?: FlashcardInteractionWhereInput
    /**
     * Limit how many FlashcardInteractions to update.
     */
    limit?: number
  }

  /**
   * FlashcardInteraction updateManyAndReturn
   */
  export type FlashcardInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * The data used to update FlashcardInteractions.
     */
    data: XOR<FlashcardInteractionUpdateManyMutationInput, FlashcardInteractionUncheckedUpdateManyInput>
    /**
     * Filter which FlashcardInteractions to update
     */
    where?: FlashcardInteractionWhereInput
    /**
     * Limit how many FlashcardInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlashcardInteraction upsert
   */
  export type FlashcardInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the FlashcardInteraction to update in case it exists.
     */
    where: FlashcardInteractionWhereUniqueInput
    /**
     * In case the FlashcardInteraction found by the `where` argument doesn't exist, create a new FlashcardInteraction with this data.
     */
    create: XOR<FlashcardInteractionCreateInput, FlashcardInteractionUncheckedCreateInput>
    /**
     * In case the FlashcardInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlashcardInteractionUpdateInput, FlashcardInteractionUncheckedUpdateInput>
  }

  /**
   * FlashcardInteraction delete
   */
  export type FlashcardInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
    /**
     * Filter which FlashcardInteraction to delete.
     */
    where: FlashcardInteractionWhereUniqueInput
  }

  /**
   * FlashcardInteraction deleteMany
   */
  export type FlashcardInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlashcardInteractions to delete
     */
    where?: FlashcardInteractionWhereInput
    /**
     * Limit how many FlashcardInteractions to delete.
     */
    limit?: number
  }

  /**
   * FlashcardInteraction without action
   */
  export type FlashcardInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardInteraction
     */
    select?: FlashcardInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardInteraction
     */
    omit?: FlashcardInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInteractionInclude<ExtArgs> | null
  }


  /**
   * Model FlashcardCollection
   */

  export type AggregateFlashcardCollection = {
    _count: FlashcardCollectionCountAggregateOutputType | null
    _avg: FlashcardCollectionAvgAggregateOutputType | null
    _sum: FlashcardCollectionSumAggregateOutputType | null
    _min: FlashcardCollectionMinAggregateOutputType | null
    _max: FlashcardCollectionMaxAggregateOutputType | null
  }

  export type FlashcardCollectionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FlashcardCollectionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FlashcardCollectionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userId: number | null
    createdAt: Date | null
    isPublic: boolean | null
  }

  export type FlashcardCollectionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userId: number | null
    createdAt: Date | null
    isPublic: boolean | null
  }

  export type FlashcardCollectionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    createdAt: number
    isPublic: number
    _all: number
  }


  export type FlashcardCollectionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FlashcardCollectionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FlashcardCollectionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    createdAt?: true
    isPublic?: true
  }

  export type FlashcardCollectionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    createdAt?: true
    isPublic?: true
  }

  export type FlashcardCollectionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    createdAt?: true
    isPublic?: true
    _all?: true
  }

  export type FlashcardCollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlashcardCollection to aggregate.
     */
    where?: FlashcardCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollections to fetch.
     */
    orderBy?: FlashcardCollectionOrderByWithRelationInput | FlashcardCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlashcardCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlashcardCollections
    **/
    _count?: true | FlashcardCollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlashcardCollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlashcardCollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlashcardCollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlashcardCollectionMaxAggregateInputType
  }

  export type GetFlashcardCollectionAggregateType<T extends FlashcardCollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateFlashcardCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlashcardCollection[P]>
      : GetScalarType<T[P], AggregateFlashcardCollection[P]>
  }




  export type FlashcardCollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardCollectionWhereInput
    orderBy?: FlashcardCollectionOrderByWithAggregationInput | FlashcardCollectionOrderByWithAggregationInput[]
    by: FlashcardCollectionScalarFieldEnum[] | FlashcardCollectionScalarFieldEnum
    having?: FlashcardCollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlashcardCollectionCountAggregateInputType | true
    _avg?: FlashcardCollectionAvgAggregateInputType
    _sum?: FlashcardCollectionSumAggregateInputType
    _min?: FlashcardCollectionMinAggregateInputType
    _max?: FlashcardCollectionMaxAggregateInputType
  }

  export type FlashcardCollectionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    userId: number
    createdAt: Date
    isPublic: boolean
    _count: FlashcardCollectionCountAggregateOutputType | null
    _avg: FlashcardCollectionAvgAggregateOutputType | null
    _sum: FlashcardCollectionSumAggregateOutputType | null
    _min: FlashcardCollectionMinAggregateOutputType | null
    _max: FlashcardCollectionMaxAggregateOutputType | null
  }

  type GetFlashcardCollectionGroupByPayload<T extends FlashcardCollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlashcardCollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlashcardCollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlashcardCollectionGroupByOutputType[P]>
            : GetScalarType<T[P], FlashcardCollectionGroupByOutputType[P]>
        }
      >
    >


  export type FlashcardCollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdAt?: boolean
    isPublic?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cards?: boolean | FlashcardCollection$cardsArgs<ExtArgs>
    _count?: boolean | FlashcardCollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardCollection"]>

  export type FlashcardCollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdAt?: boolean
    isPublic?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardCollection"]>

  export type FlashcardCollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdAt?: boolean
    isPublic?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardCollection"]>

  export type FlashcardCollectionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdAt?: boolean
    isPublic?: boolean
  }

  export type FlashcardCollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "userId" | "createdAt" | "isPublic", ExtArgs["result"]["flashcardCollection"]>
  export type FlashcardCollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cards?: boolean | FlashcardCollection$cardsArgs<ExtArgs>
    _count?: boolean | FlashcardCollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlashcardCollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlashcardCollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlashcardCollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlashcardCollection"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cards: Prisma.$FlashcardCollectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      userId: number
      createdAt: Date
      isPublic: boolean
    }, ExtArgs["result"]["flashcardCollection"]>
    composites: {}
  }

  type FlashcardCollectionGetPayload<S extends boolean | null | undefined | FlashcardCollectionDefaultArgs> = $Result.GetResult<Prisma.$FlashcardCollectionPayload, S>

  type FlashcardCollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlashcardCollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlashcardCollectionCountAggregateInputType | true
    }

  export interface FlashcardCollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlashcardCollection'], meta: { name: 'FlashcardCollection' } }
    /**
     * Find zero or one FlashcardCollection that matches the filter.
     * @param {FlashcardCollectionFindUniqueArgs} args - Arguments to find a FlashcardCollection
     * @example
     * // Get one FlashcardCollection
     * const flashcardCollection = await prisma.flashcardCollection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlashcardCollectionFindUniqueArgs>(args: SelectSubset<T, FlashcardCollectionFindUniqueArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlashcardCollection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlashcardCollectionFindUniqueOrThrowArgs} args - Arguments to find a FlashcardCollection
     * @example
     * // Get one FlashcardCollection
     * const flashcardCollection = await prisma.flashcardCollection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlashcardCollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, FlashcardCollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlashcardCollection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionFindFirstArgs} args - Arguments to find a FlashcardCollection
     * @example
     * // Get one FlashcardCollection
     * const flashcardCollection = await prisma.flashcardCollection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlashcardCollectionFindFirstArgs>(args?: SelectSubset<T, FlashcardCollectionFindFirstArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlashcardCollection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionFindFirstOrThrowArgs} args - Arguments to find a FlashcardCollection
     * @example
     * // Get one FlashcardCollection
     * const flashcardCollection = await prisma.flashcardCollection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlashcardCollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, FlashcardCollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlashcardCollections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlashcardCollections
     * const flashcardCollections = await prisma.flashcardCollection.findMany()
     * 
     * // Get first 10 FlashcardCollections
     * const flashcardCollections = await prisma.flashcardCollection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flashcardCollectionWithIdOnly = await prisma.flashcardCollection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlashcardCollectionFindManyArgs>(args?: SelectSubset<T, FlashcardCollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlashcardCollection.
     * @param {FlashcardCollectionCreateArgs} args - Arguments to create a FlashcardCollection.
     * @example
     * // Create one FlashcardCollection
     * const FlashcardCollection = await prisma.flashcardCollection.create({
     *   data: {
     *     // ... data to create a FlashcardCollection
     *   }
     * })
     * 
     */
    create<T extends FlashcardCollectionCreateArgs>(args: SelectSubset<T, FlashcardCollectionCreateArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlashcardCollections.
     * @param {FlashcardCollectionCreateManyArgs} args - Arguments to create many FlashcardCollections.
     * @example
     * // Create many FlashcardCollections
     * const flashcardCollection = await prisma.flashcardCollection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlashcardCollectionCreateManyArgs>(args?: SelectSubset<T, FlashcardCollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlashcardCollections and returns the data saved in the database.
     * @param {FlashcardCollectionCreateManyAndReturnArgs} args - Arguments to create many FlashcardCollections.
     * @example
     * // Create many FlashcardCollections
     * const flashcardCollection = await prisma.flashcardCollection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlashcardCollections and only return the `id`
     * const flashcardCollectionWithIdOnly = await prisma.flashcardCollection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlashcardCollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, FlashcardCollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlashcardCollection.
     * @param {FlashcardCollectionDeleteArgs} args - Arguments to delete one FlashcardCollection.
     * @example
     * // Delete one FlashcardCollection
     * const FlashcardCollection = await prisma.flashcardCollection.delete({
     *   where: {
     *     // ... filter to delete one FlashcardCollection
     *   }
     * })
     * 
     */
    delete<T extends FlashcardCollectionDeleteArgs>(args: SelectSubset<T, FlashcardCollectionDeleteArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlashcardCollection.
     * @param {FlashcardCollectionUpdateArgs} args - Arguments to update one FlashcardCollection.
     * @example
     * // Update one FlashcardCollection
     * const flashcardCollection = await prisma.flashcardCollection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlashcardCollectionUpdateArgs>(args: SelectSubset<T, FlashcardCollectionUpdateArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlashcardCollections.
     * @param {FlashcardCollectionDeleteManyArgs} args - Arguments to filter FlashcardCollections to delete.
     * @example
     * // Delete a few FlashcardCollections
     * const { count } = await prisma.flashcardCollection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlashcardCollectionDeleteManyArgs>(args?: SelectSubset<T, FlashcardCollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlashcardCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlashcardCollections
     * const flashcardCollection = await prisma.flashcardCollection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlashcardCollectionUpdateManyArgs>(args: SelectSubset<T, FlashcardCollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlashcardCollections and returns the data updated in the database.
     * @param {FlashcardCollectionUpdateManyAndReturnArgs} args - Arguments to update many FlashcardCollections.
     * @example
     * // Update many FlashcardCollections
     * const flashcardCollection = await prisma.flashcardCollection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlashcardCollections and only return the `id`
     * const flashcardCollectionWithIdOnly = await prisma.flashcardCollection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlashcardCollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, FlashcardCollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlashcardCollection.
     * @param {FlashcardCollectionUpsertArgs} args - Arguments to update or create a FlashcardCollection.
     * @example
     * // Update or create a FlashcardCollection
     * const flashcardCollection = await prisma.flashcardCollection.upsert({
     *   create: {
     *     // ... data to create a FlashcardCollection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlashcardCollection we want to update
     *   }
     * })
     */
    upsert<T extends FlashcardCollectionUpsertArgs>(args: SelectSubset<T, FlashcardCollectionUpsertArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlashcardCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionCountArgs} args - Arguments to filter FlashcardCollections to count.
     * @example
     * // Count the number of FlashcardCollections
     * const count = await prisma.flashcardCollection.count({
     *   where: {
     *     // ... the filter for the FlashcardCollections we want to count
     *   }
     * })
    **/
    count<T extends FlashcardCollectionCountArgs>(
      args?: Subset<T, FlashcardCollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlashcardCollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlashcardCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlashcardCollectionAggregateArgs>(args: Subset<T, FlashcardCollectionAggregateArgs>): Prisma.PrismaPromise<GetFlashcardCollectionAggregateType<T>>

    /**
     * Group by FlashcardCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlashcardCollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlashcardCollectionGroupByArgs['orderBy'] }
        : { orderBy?: FlashcardCollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlashcardCollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlashcardCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlashcardCollection model
   */
  readonly fields: FlashcardCollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlashcardCollection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlashcardCollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cards<T extends FlashcardCollection$cardsArgs<ExtArgs> = {}>(args?: Subset<T, FlashcardCollection$cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlashcardCollection model
   */
  interface FlashcardCollectionFieldRefs {
    readonly id: FieldRef<"FlashcardCollection", 'Int'>
    readonly name: FieldRef<"FlashcardCollection", 'String'>
    readonly description: FieldRef<"FlashcardCollection", 'String'>
    readonly userId: FieldRef<"FlashcardCollection", 'Int'>
    readonly createdAt: FieldRef<"FlashcardCollection", 'DateTime'>
    readonly isPublic: FieldRef<"FlashcardCollection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FlashcardCollection findUnique
   */
  export type FlashcardCollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollection to fetch.
     */
    where: FlashcardCollectionWhereUniqueInput
  }

  /**
   * FlashcardCollection findUniqueOrThrow
   */
  export type FlashcardCollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollection to fetch.
     */
    where: FlashcardCollectionWhereUniqueInput
  }

  /**
   * FlashcardCollection findFirst
   */
  export type FlashcardCollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollection to fetch.
     */
    where?: FlashcardCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollections to fetch.
     */
    orderBy?: FlashcardCollectionOrderByWithRelationInput | FlashcardCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlashcardCollections.
     */
    cursor?: FlashcardCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlashcardCollections.
     */
    distinct?: FlashcardCollectionScalarFieldEnum | FlashcardCollectionScalarFieldEnum[]
  }

  /**
   * FlashcardCollection findFirstOrThrow
   */
  export type FlashcardCollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollection to fetch.
     */
    where?: FlashcardCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollections to fetch.
     */
    orderBy?: FlashcardCollectionOrderByWithRelationInput | FlashcardCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlashcardCollections.
     */
    cursor?: FlashcardCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlashcardCollections.
     */
    distinct?: FlashcardCollectionScalarFieldEnum | FlashcardCollectionScalarFieldEnum[]
  }

  /**
   * FlashcardCollection findMany
   */
  export type FlashcardCollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollections to fetch.
     */
    where?: FlashcardCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollections to fetch.
     */
    orderBy?: FlashcardCollectionOrderByWithRelationInput | FlashcardCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlashcardCollections.
     */
    cursor?: FlashcardCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollections.
     */
    skip?: number
    distinct?: FlashcardCollectionScalarFieldEnum | FlashcardCollectionScalarFieldEnum[]
  }

  /**
   * FlashcardCollection create
   */
  export type FlashcardCollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a FlashcardCollection.
     */
    data: XOR<FlashcardCollectionCreateInput, FlashcardCollectionUncheckedCreateInput>
  }

  /**
   * FlashcardCollection createMany
   */
  export type FlashcardCollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlashcardCollections.
     */
    data: FlashcardCollectionCreateManyInput | FlashcardCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlashcardCollection createManyAndReturn
   */
  export type FlashcardCollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * The data used to create many FlashcardCollections.
     */
    data: FlashcardCollectionCreateManyInput | FlashcardCollectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlashcardCollection update
   */
  export type FlashcardCollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a FlashcardCollection.
     */
    data: XOR<FlashcardCollectionUpdateInput, FlashcardCollectionUncheckedUpdateInput>
    /**
     * Choose, which FlashcardCollection to update.
     */
    where: FlashcardCollectionWhereUniqueInput
  }

  /**
   * FlashcardCollection updateMany
   */
  export type FlashcardCollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlashcardCollections.
     */
    data: XOR<FlashcardCollectionUpdateManyMutationInput, FlashcardCollectionUncheckedUpdateManyInput>
    /**
     * Filter which FlashcardCollections to update
     */
    where?: FlashcardCollectionWhereInput
    /**
     * Limit how many FlashcardCollections to update.
     */
    limit?: number
  }

  /**
   * FlashcardCollection updateManyAndReturn
   */
  export type FlashcardCollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * The data used to update FlashcardCollections.
     */
    data: XOR<FlashcardCollectionUpdateManyMutationInput, FlashcardCollectionUncheckedUpdateManyInput>
    /**
     * Filter which FlashcardCollections to update
     */
    where?: FlashcardCollectionWhereInput
    /**
     * Limit how many FlashcardCollections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlashcardCollection upsert
   */
  export type FlashcardCollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the FlashcardCollection to update in case it exists.
     */
    where: FlashcardCollectionWhereUniqueInput
    /**
     * In case the FlashcardCollection found by the `where` argument doesn't exist, create a new FlashcardCollection with this data.
     */
    create: XOR<FlashcardCollectionCreateInput, FlashcardCollectionUncheckedCreateInput>
    /**
     * In case the FlashcardCollection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlashcardCollectionUpdateInput, FlashcardCollectionUncheckedUpdateInput>
  }

  /**
   * FlashcardCollection delete
   */
  export type FlashcardCollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
    /**
     * Filter which FlashcardCollection to delete.
     */
    where: FlashcardCollectionWhereUniqueInput
  }

  /**
   * FlashcardCollection deleteMany
   */
  export type FlashcardCollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlashcardCollections to delete
     */
    where?: FlashcardCollectionWhereInput
    /**
     * Limit how many FlashcardCollections to delete.
     */
    limit?: number
  }

  /**
   * FlashcardCollection.cards
   */
  export type FlashcardCollection$cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    where?: FlashcardCollectionItemWhereInput
    orderBy?: FlashcardCollectionItemOrderByWithRelationInput | FlashcardCollectionItemOrderByWithRelationInput[]
    cursor?: FlashcardCollectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardCollectionItemScalarFieldEnum | FlashcardCollectionItemScalarFieldEnum[]
  }

  /**
   * FlashcardCollection without action
   */
  export type FlashcardCollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollection
     */
    select?: FlashcardCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollection
     */
    omit?: FlashcardCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionInclude<ExtArgs> | null
  }


  /**
   * Model FlashcardCollectionItem
   */

  export type AggregateFlashcardCollectionItem = {
    _count: FlashcardCollectionItemCountAggregateOutputType | null
    _avg: FlashcardCollectionItemAvgAggregateOutputType | null
    _sum: FlashcardCollectionItemSumAggregateOutputType | null
    _min: FlashcardCollectionItemMinAggregateOutputType | null
    _max: FlashcardCollectionItemMaxAggregateOutputType | null
  }

  export type FlashcardCollectionItemAvgAggregateOutputType = {
    id: number | null
    collectionId: number | null
    flashcardId: number | null
  }

  export type FlashcardCollectionItemSumAggregateOutputType = {
    id: number | null
    collectionId: number | null
    flashcardId: number | null
  }

  export type FlashcardCollectionItemMinAggregateOutputType = {
    id: number | null
    collectionId: number | null
    flashcardId: number | null
    addedAt: Date | null
  }

  export type FlashcardCollectionItemMaxAggregateOutputType = {
    id: number | null
    collectionId: number | null
    flashcardId: number | null
    addedAt: Date | null
  }

  export type FlashcardCollectionItemCountAggregateOutputType = {
    id: number
    collectionId: number
    flashcardId: number
    addedAt: number
    _all: number
  }


  export type FlashcardCollectionItemAvgAggregateInputType = {
    id?: true
    collectionId?: true
    flashcardId?: true
  }

  export type FlashcardCollectionItemSumAggregateInputType = {
    id?: true
    collectionId?: true
    flashcardId?: true
  }

  export type FlashcardCollectionItemMinAggregateInputType = {
    id?: true
    collectionId?: true
    flashcardId?: true
    addedAt?: true
  }

  export type FlashcardCollectionItemMaxAggregateInputType = {
    id?: true
    collectionId?: true
    flashcardId?: true
    addedAt?: true
  }

  export type FlashcardCollectionItemCountAggregateInputType = {
    id?: true
    collectionId?: true
    flashcardId?: true
    addedAt?: true
    _all?: true
  }

  export type FlashcardCollectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlashcardCollectionItem to aggregate.
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollectionItems to fetch.
     */
    orderBy?: FlashcardCollectionItemOrderByWithRelationInput | FlashcardCollectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlashcardCollectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlashcardCollectionItems
    **/
    _count?: true | FlashcardCollectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlashcardCollectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlashcardCollectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlashcardCollectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlashcardCollectionItemMaxAggregateInputType
  }

  export type GetFlashcardCollectionItemAggregateType<T extends FlashcardCollectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFlashcardCollectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlashcardCollectionItem[P]>
      : GetScalarType<T[P], AggregateFlashcardCollectionItem[P]>
  }




  export type FlashcardCollectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardCollectionItemWhereInput
    orderBy?: FlashcardCollectionItemOrderByWithAggregationInput | FlashcardCollectionItemOrderByWithAggregationInput[]
    by: FlashcardCollectionItemScalarFieldEnum[] | FlashcardCollectionItemScalarFieldEnum
    having?: FlashcardCollectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlashcardCollectionItemCountAggregateInputType | true
    _avg?: FlashcardCollectionItemAvgAggregateInputType
    _sum?: FlashcardCollectionItemSumAggregateInputType
    _min?: FlashcardCollectionItemMinAggregateInputType
    _max?: FlashcardCollectionItemMaxAggregateInputType
  }

  export type FlashcardCollectionItemGroupByOutputType = {
    id: number
    collectionId: number
    flashcardId: number
    addedAt: Date
    _count: FlashcardCollectionItemCountAggregateOutputType | null
    _avg: FlashcardCollectionItemAvgAggregateOutputType | null
    _sum: FlashcardCollectionItemSumAggregateOutputType | null
    _min: FlashcardCollectionItemMinAggregateOutputType | null
    _max: FlashcardCollectionItemMaxAggregateOutputType | null
  }

  type GetFlashcardCollectionItemGroupByPayload<T extends FlashcardCollectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlashcardCollectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlashcardCollectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlashcardCollectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], FlashcardCollectionItemGroupByOutputType[P]>
        }
      >
    >


  export type FlashcardCollectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    flashcardId?: boolean
    addedAt?: boolean
    collection?: boolean | FlashcardCollectionDefaultArgs<ExtArgs>
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardCollectionItem"]>

  export type FlashcardCollectionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    flashcardId?: boolean
    addedAt?: boolean
    collection?: boolean | FlashcardCollectionDefaultArgs<ExtArgs>
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardCollectionItem"]>

  export type FlashcardCollectionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    flashcardId?: boolean
    addedAt?: boolean
    collection?: boolean | FlashcardCollectionDefaultArgs<ExtArgs>
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcardCollectionItem"]>

  export type FlashcardCollectionItemSelectScalar = {
    id?: boolean
    collectionId?: boolean
    flashcardId?: boolean
    addedAt?: boolean
  }

  export type FlashcardCollectionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionId" | "flashcardId" | "addedAt", ExtArgs["result"]["flashcardCollectionItem"]>
  export type FlashcardCollectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | FlashcardCollectionDefaultArgs<ExtArgs>
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
  }
  export type FlashcardCollectionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | FlashcardCollectionDefaultArgs<ExtArgs>
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
  }
  export type FlashcardCollectionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | FlashcardCollectionDefaultArgs<ExtArgs>
    flashcard?: boolean | FlashcardDefaultArgs<ExtArgs>
  }

  export type $FlashcardCollectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlashcardCollectionItem"
    objects: {
      collection: Prisma.$FlashcardCollectionPayload<ExtArgs>
      flashcard: Prisma.$FlashcardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      collectionId: number
      flashcardId: number
      addedAt: Date
    }, ExtArgs["result"]["flashcardCollectionItem"]>
    composites: {}
  }

  type FlashcardCollectionItemGetPayload<S extends boolean | null | undefined | FlashcardCollectionItemDefaultArgs> = $Result.GetResult<Prisma.$FlashcardCollectionItemPayload, S>

  type FlashcardCollectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlashcardCollectionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlashcardCollectionItemCountAggregateInputType | true
    }

  export interface FlashcardCollectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlashcardCollectionItem'], meta: { name: 'FlashcardCollectionItem' } }
    /**
     * Find zero or one FlashcardCollectionItem that matches the filter.
     * @param {FlashcardCollectionItemFindUniqueArgs} args - Arguments to find a FlashcardCollectionItem
     * @example
     * // Get one FlashcardCollectionItem
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlashcardCollectionItemFindUniqueArgs>(args: SelectSubset<T, FlashcardCollectionItemFindUniqueArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlashcardCollectionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlashcardCollectionItemFindUniqueOrThrowArgs} args - Arguments to find a FlashcardCollectionItem
     * @example
     * // Get one FlashcardCollectionItem
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlashcardCollectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FlashcardCollectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlashcardCollectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemFindFirstArgs} args - Arguments to find a FlashcardCollectionItem
     * @example
     * // Get one FlashcardCollectionItem
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlashcardCollectionItemFindFirstArgs>(args?: SelectSubset<T, FlashcardCollectionItemFindFirstArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlashcardCollectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemFindFirstOrThrowArgs} args - Arguments to find a FlashcardCollectionItem
     * @example
     * // Get one FlashcardCollectionItem
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlashcardCollectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FlashcardCollectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlashcardCollectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlashcardCollectionItems
     * const flashcardCollectionItems = await prisma.flashcardCollectionItem.findMany()
     * 
     * // Get first 10 FlashcardCollectionItems
     * const flashcardCollectionItems = await prisma.flashcardCollectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flashcardCollectionItemWithIdOnly = await prisma.flashcardCollectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlashcardCollectionItemFindManyArgs>(args?: SelectSubset<T, FlashcardCollectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlashcardCollectionItem.
     * @param {FlashcardCollectionItemCreateArgs} args - Arguments to create a FlashcardCollectionItem.
     * @example
     * // Create one FlashcardCollectionItem
     * const FlashcardCollectionItem = await prisma.flashcardCollectionItem.create({
     *   data: {
     *     // ... data to create a FlashcardCollectionItem
     *   }
     * })
     * 
     */
    create<T extends FlashcardCollectionItemCreateArgs>(args: SelectSubset<T, FlashcardCollectionItemCreateArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlashcardCollectionItems.
     * @param {FlashcardCollectionItemCreateManyArgs} args - Arguments to create many FlashcardCollectionItems.
     * @example
     * // Create many FlashcardCollectionItems
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlashcardCollectionItemCreateManyArgs>(args?: SelectSubset<T, FlashcardCollectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlashcardCollectionItems and returns the data saved in the database.
     * @param {FlashcardCollectionItemCreateManyAndReturnArgs} args - Arguments to create many FlashcardCollectionItems.
     * @example
     * // Create many FlashcardCollectionItems
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlashcardCollectionItems and only return the `id`
     * const flashcardCollectionItemWithIdOnly = await prisma.flashcardCollectionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlashcardCollectionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FlashcardCollectionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlashcardCollectionItem.
     * @param {FlashcardCollectionItemDeleteArgs} args - Arguments to delete one FlashcardCollectionItem.
     * @example
     * // Delete one FlashcardCollectionItem
     * const FlashcardCollectionItem = await prisma.flashcardCollectionItem.delete({
     *   where: {
     *     // ... filter to delete one FlashcardCollectionItem
     *   }
     * })
     * 
     */
    delete<T extends FlashcardCollectionItemDeleteArgs>(args: SelectSubset<T, FlashcardCollectionItemDeleteArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlashcardCollectionItem.
     * @param {FlashcardCollectionItemUpdateArgs} args - Arguments to update one FlashcardCollectionItem.
     * @example
     * // Update one FlashcardCollectionItem
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlashcardCollectionItemUpdateArgs>(args: SelectSubset<T, FlashcardCollectionItemUpdateArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlashcardCollectionItems.
     * @param {FlashcardCollectionItemDeleteManyArgs} args - Arguments to filter FlashcardCollectionItems to delete.
     * @example
     * // Delete a few FlashcardCollectionItems
     * const { count } = await prisma.flashcardCollectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlashcardCollectionItemDeleteManyArgs>(args?: SelectSubset<T, FlashcardCollectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlashcardCollectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlashcardCollectionItems
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlashcardCollectionItemUpdateManyArgs>(args: SelectSubset<T, FlashcardCollectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlashcardCollectionItems and returns the data updated in the database.
     * @param {FlashcardCollectionItemUpdateManyAndReturnArgs} args - Arguments to update many FlashcardCollectionItems.
     * @example
     * // Update many FlashcardCollectionItems
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlashcardCollectionItems and only return the `id`
     * const flashcardCollectionItemWithIdOnly = await prisma.flashcardCollectionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlashcardCollectionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, FlashcardCollectionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlashcardCollectionItem.
     * @param {FlashcardCollectionItemUpsertArgs} args - Arguments to update or create a FlashcardCollectionItem.
     * @example
     * // Update or create a FlashcardCollectionItem
     * const flashcardCollectionItem = await prisma.flashcardCollectionItem.upsert({
     *   create: {
     *     // ... data to create a FlashcardCollectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlashcardCollectionItem we want to update
     *   }
     * })
     */
    upsert<T extends FlashcardCollectionItemUpsertArgs>(args: SelectSubset<T, FlashcardCollectionItemUpsertArgs<ExtArgs>>): Prisma__FlashcardCollectionItemClient<$Result.GetResult<Prisma.$FlashcardCollectionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlashcardCollectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemCountArgs} args - Arguments to filter FlashcardCollectionItems to count.
     * @example
     * // Count the number of FlashcardCollectionItems
     * const count = await prisma.flashcardCollectionItem.count({
     *   where: {
     *     // ... the filter for the FlashcardCollectionItems we want to count
     *   }
     * })
    **/
    count<T extends FlashcardCollectionItemCountArgs>(
      args?: Subset<T, FlashcardCollectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlashcardCollectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlashcardCollectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlashcardCollectionItemAggregateArgs>(args: Subset<T, FlashcardCollectionItemAggregateArgs>): Prisma.PrismaPromise<GetFlashcardCollectionItemAggregateType<T>>

    /**
     * Group by FlashcardCollectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCollectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlashcardCollectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlashcardCollectionItemGroupByArgs['orderBy'] }
        : { orderBy?: FlashcardCollectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlashcardCollectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlashcardCollectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlashcardCollectionItem model
   */
  readonly fields: FlashcardCollectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlashcardCollectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlashcardCollectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends FlashcardCollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlashcardCollectionDefaultArgs<ExtArgs>>): Prisma__FlashcardCollectionClient<$Result.GetResult<Prisma.$FlashcardCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flashcard<T extends FlashcardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlashcardDefaultArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlashcardCollectionItem model
   */
  interface FlashcardCollectionItemFieldRefs {
    readonly id: FieldRef<"FlashcardCollectionItem", 'Int'>
    readonly collectionId: FieldRef<"FlashcardCollectionItem", 'Int'>
    readonly flashcardId: FieldRef<"FlashcardCollectionItem", 'Int'>
    readonly addedAt: FieldRef<"FlashcardCollectionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlashcardCollectionItem findUnique
   */
  export type FlashcardCollectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollectionItem to fetch.
     */
    where: FlashcardCollectionItemWhereUniqueInput
  }

  /**
   * FlashcardCollectionItem findUniqueOrThrow
   */
  export type FlashcardCollectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollectionItem to fetch.
     */
    where: FlashcardCollectionItemWhereUniqueInput
  }

  /**
   * FlashcardCollectionItem findFirst
   */
  export type FlashcardCollectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollectionItem to fetch.
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollectionItems to fetch.
     */
    orderBy?: FlashcardCollectionItemOrderByWithRelationInput | FlashcardCollectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlashcardCollectionItems.
     */
    cursor?: FlashcardCollectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlashcardCollectionItems.
     */
    distinct?: FlashcardCollectionItemScalarFieldEnum | FlashcardCollectionItemScalarFieldEnum[]
  }

  /**
   * FlashcardCollectionItem findFirstOrThrow
   */
  export type FlashcardCollectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollectionItem to fetch.
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollectionItems to fetch.
     */
    orderBy?: FlashcardCollectionItemOrderByWithRelationInput | FlashcardCollectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlashcardCollectionItems.
     */
    cursor?: FlashcardCollectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlashcardCollectionItems.
     */
    distinct?: FlashcardCollectionItemScalarFieldEnum | FlashcardCollectionItemScalarFieldEnum[]
  }

  /**
   * FlashcardCollectionItem findMany
   */
  export type FlashcardCollectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * Filter, which FlashcardCollectionItems to fetch.
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlashcardCollectionItems to fetch.
     */
    orderBy?: FlashcardCollectionItemOrderByWithRelationInput | FlashcardCollectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlashcardCollectionItems.
     */
    cursor?: FlashcardCollectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlashcardCollectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlashcardCollectionItems.
     */
    skip?: number
    distinct?: FlashcardCollectionItemScalarFieldEnum | FlashcardCollectionItemScalarFieldEnum[]
  }

  /**
   * FlashcardCollectionItem create
   */
  export type FlashcardCollectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FlashcardCollectionItem.
     */
    data: XOR<FlashcardCollectionItemCreateInput, FlashcardCollectionItemUncheckedCreateInput>
  }

  /**
   * FlashcardCollectionItem createMany
   */
  export type FlashcardCollectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlashcardCollectionItems.
     */
    data: FlashcardCollectionItemCreateManyInput | FlashcardCollectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlashcardCollectionItem createManyAndReturn
   */
  export type FlashcardCollectionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * The data used to create many FlashcardCollectionItems.
     */
    data: FlashcardCollectionItemCreateManyInput | FlashcardCollectionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlashcardCollectionItem update
   */
  export type FlashcardCollectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FlashcardCollectionItem.
     */
    data: XOR<FlashcardCollectionItemUpdateInput, FlashcardCollectionItemUncheckedUpdateInput>
    /**
     * Choose, which FlashcardCollectionItem to update.
     */
    where: FlashcardCollectionItemWhereUniqueInput
  }

  /**
   * FlashcardCollectionItem updateMany
   */
  export type FlashcardCollectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlashcardCollectionItems.
     */
    data: XOR<FlashcardCollectionItemUpdateManyMutationInput, FlashcardCollectionItemUncheckedUpdateManyInput>
    /**
     * Filter which FlashcardCollectionItems to update
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * Limit how many FlashcardCollectionItems to update.
     */
    limit?: number
  }

  /**
   * FlashcardCollectionItem updateManyAndReturn
   */
  export type FlashcardCollectionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * The data used to update FlashcardCollectionItems.
     */
    data: XOR<FlashcardCollectionItemUpdateManyMutationInput, FlashcardCollectionItemUncheckedUpdateManyInput>
    /**
     * Filter which FlashcardCollectionItems to update
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * Limit how many FlashcardCollectionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlashcardCollectionItem upsert
   */
  export type FlashcardCollectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FlashcardCollectionItem to update in case it exists.
     */
    where: FlashcardCollectionItemWhereUniqueInput
    /**
     * In case the FlashcardCollectionItem found by the `where` argument doesn't exist, create a new FlashcardCollectionItem with this data.
     */
    create: XOR<FlashcardCollectionItemCreateInput, FlashcardCollectionItemUncheckedCreateInput>
    /**
     * In case the FlashcardCollectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlashcardCollectionItemUpdateInput, FlashcardCollectionItemUncheckedUpdateInput>
  }

  /**
   * FlashcardCollectionItem delete
   */
  export type FlashcardCollectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
    /**
     * Filter which FlashcardCollectionItem to delete.
     */
    where: FlashcardCollectionItemWhereUniqueInput
  }

  /**
   * FlashcardCollectionItem deleteMany
   */
  export type FlashcardCollectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlashcardCollectionItems to delete
     */
    where?: FlashcardCollectionItemWhereInput
    /**
     * Limit how many FlashcardCollectionItems to delete.
     */
    limit?: number
  }

  /**
   * FlashcardCollectionItem without action
   */
  export type FlashcardCollectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlashcardCollectionItem
     */
    select?: FlashcardCollectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlashcardCollectionItem
     */
    omit?: FlashcardCollectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardCollectionItemInclude<ExtArgs> | null
  }


  /**
   * Model ChatbotSession
   */

  export type AggregateChatbotSession = {
    _count: ChatbotSessionCountAggregateOutputType | null
    _avg: ChatbotSessionAvgAggregateOutputType | null
    _sum: ChatbotSessionSumAggregateOutputType | null
    _min: ChatbotSessionMinAggregateOutputType | null
    _max: ChatbotSessionMaxAggregateOutputType | null
  }

  export type ChatbotSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ChatbotSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ChatbotSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type ChatbotSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type ChatbotSessionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type ChatbotSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ChatbotSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ChatbotSessionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type ChatbotSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type ChatbotSessionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type ChatbotSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotSession to aggregate.
     */
    where?: ChatbotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessions to fetch.
     */
    orderBy?: ChatbotSessionOrderByWithRelationInput | ChatbotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatbotSessions
    **/
    _count?: true | ChatbotSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatbotSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatbotSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotSessionMaxAggregateInputType
  }

  export type GetChatbotSessionAggregateType<T extends ChatbotSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbotSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbotSession[P]>
      : GetScalarType<T[P], AggregateChatbotSession[P]>
  }




  export type ChatbotSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotSessionWhereInput
    orderBy?: ChatbotSessionOrderByWithAggregationInput | ChatbotSessionOrderByWithAggregationInput[]
    by: ChatbotSessionScalarFieldEnum[] | ChatbotSessionScalarFieldEnum
    having?: ChatbotSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotSessionCountAggregateInputType | true
    _avg?: ChatbotSessionAvgAggregateInputType
    _sum?: ChatbotSessionSumAggregateInputType
    _min?: ChatbotSessionMinAggregateInputType
    _max?: ChatbotSessionMaxAggregateInputType
  }

  export type ChatbotSessionGroupByOutputType = {
    id: number
    userId: number
    title: string | null
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: ChatbotSessionCountAggregateOutputType | null
    _avg: ChatbotSessionAvgAggregateOutputType | null
    _sum: ChatbotSessionSumAggregateOutputType | null
    _min: ChatbotSessionMinAggregateOutputType | null
    _max: ChatbotSessionMaxAggregateOutputType | null
  }

  type GetChatbotSessionGroupByPayload<T extends ChatbotSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatbotSession$messagesArgs<ExtArgs>
    analytics?: boolean | ChatbotSession$analyticsArgs<ExtArgs>
    _count?: boolean | ChatbotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotSession"]>

  export type ChatbotSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotSession"]>

  export type ChatbotSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotSession"]>

  export type ChatbotSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type ChatbotSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "createdAt" | "updatedAt" | "isActive", ExtArgs["result"]["chatbotSession"]>
  export type ChatbotSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatbotSession$messagesArgs<ExtArgs>
    analytics?: boolean | ChatbotSession$analyticsArgs<ExtArgs>
    _count?: boolean | ChatbotSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatbotSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatbotSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatbotSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatbotSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$ChatbotMessagePayload<ExtArgs>[]
      analytics: Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string | null
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["chatbotSession"]>
    composites: {}
  }

  type ChatbotSessionGetPayload<S extends boolean | null | undefined | ChatbotSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatbotSessionPayload, S>

  type ChatbotSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotSessionCountAggregateInputType | true
    }

  export interface ChatbotSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatbotSession'], meta: { name: 'ChatbotSession' } }
    /**
     * Find zero or one ChatbotSession that matches the filter.
     * @param {ChatbotSessionFindUniqueArgs} args - Arguments to find a ChatbotSession
     * @example
     * // Get one ChatbotSession
     * const chatbotSession = await prisma.chatbotSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotSessionFindUniqueArgs>(args: SelectSubset<T, ChatbotSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatbotSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatbotSession
     * @example
     * // Get one ChatbotSession
     * const chatbotSession = await prisma.chatbotSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionFindFirstArgs} args - Arguments to find a ChatbotSession
     * @example
     * // Get one ChatbotSession
     * const chatbotSession = await prisma.chatbotSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotSessionFindFirstArgs>(args?: SelectSubset<T, ChatbotSessionFindFirstArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionFindFirstOrThrowArgs} args - Arguments to find a ChatbotSession
     * @example
     * // Get one ChatbotSession
     * const chatbotSession = await prisma.chatbotSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatbotSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatbotSessions
     * const chatbotSessions = await prisma.chatbotSession.findMany()
     * 
     * // Get first 10 ChatbotSessions
     * const chatbotSessions = await prisma.chatbotSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatbotSessionWithIdOnly = await prisma.chatbotSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatbotSessionFindManyArgs>(args?: SelectSubset<T, ChatbotSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatbotSession.
     * @param {ChatbotSessionCreateArgs} args - Arguments to create a ChatbotSession.
     * @example
     * // Create one ChatbotSession
     * const ChatbotSession = await prisma.chatbotSession.create({
     *   data: {
     *     // ... data to create a ChatbotSession
     *   }
     * })
     * 
     */
    create<T extends ChatbotSessionCreateArgs>(args: SelectSubset<T, ChatbotSessionCreateArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatbotSessions.
     * @param {ChatbotSessionCreateManyArgs} args - Arguments to create many ChatbotSessions.
     * @example
     * // Create many ChatbotSessions
     * const chatbotSession = await prisma.chatbotSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotSessionCreateManyArgs>(args?: SelectSubset<T, ChatbotSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatbotSessions and returns the data saved in the database.
     * @param {ChatbotSessionCreateManyAndReturnArgs} args - Arguments to create many ChatbotSessions.
     * @example
     * // Create many ChatbotSessions
     * const chatbotSession = await prisma.chatbotSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatbotSessions and only return the `id`
     * const chatbotSessionWithIdOnly = await prisma.chatbotSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatbotSession.
     * @param {ChatbotSessionDeleteArgs} args - Arguments to delete one ChatbotSession.
     * @example
     * // Delete one ChatbotSession
     * const ChatbotSession = await prisma.chatbotSession.delete({
     *   where: {
     *     // ... filter to delete one ChatbotSession
     *   }
     * })
     * 
     */
    delete<T extends ChatbotSessionDeleteArgs>(args: SelectSubset<T, ChatbotSessionDeleteArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatbotSession.
     * @param {ChatbotSessionUpdateArgs} args - Arguments to update one ChatbotSession.
     * @example
     * // Update one ChatbotSession
     * const chatbotSession = await prisma.chatbotSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotSessionUpdateArgs>(args: SelectSubset<T, ChatbotSessionUpdateArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatbotSessions.
     * @param {ChatbotSessionDeleteManyArgs} args - Arguments to filter ChatbotSessions to delete.
     * @example
     * // Delete a few ChatbotSessions
     * const { count } = await prisma.chatbotSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotSessionDeleteManyArgs>(args?: SelectSubset<T, ChatbotSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatbotSessions
     * const chatbotSession = await prisma.chatbotSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotSessionUpdateManyArgs>(args: SelectSubset<T, ChatbotSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotSessions and returns the data updated in the database.
     * @param {ChatbotSessionUpdateManyAndReturnArgs} args - Arguments to update many ChatbotSessions.
     * @example
     * // Update many ChatbotSessions
     * const chatbotSession = await prisma.chatbotSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatbotSessions and only return the `id`
     * const chatbotSessionWithIdOnly = await prisma.chatbotSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatbotSession.
     * @param {ChatbotSessionUpsertArgs} args - Arguments to update or create a ChatbotSession.
     * @example
     * // Update or create a ChatbotSession
     * const chatbotSession = await prisma.chatbotSession.upsert({
     *   create: {
     *     // ... data to create a ChatbotSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatbotSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotSessionUpsertArgs>(args: SelectSubset<T, ChatbotSessionUpsertArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatbotSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionCountArgs} args - Arguments to filter ChatbotSessions to count.
     * @example
     * // Count the number of ChatbotSessions
     * const count = await prisma.chatbotSession.count({
     *   where: {
     *     // ... the filter for the ChatbotSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatbotSessionCountArgs>(
      args?: Subset<T, ChatbotSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatbotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotSessionAggregateArgs>(args: Subset<T, ChatbotSessionAggregateArgs>): Prisma.PrismaPromise<GetChatbotSessionAggregateType<T>>

    /**
     * Group by ChatbotSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatbotSession model
   */
  readonly fields: ChatbotSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatbotSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatbotSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analytics<T extends ChatbotSession$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotSession$analyticsArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatbotSession model
   */
  interface ChatbotSessionFieldRefs {
    readonly id: FieldRef<"ChatbotSession", 'Int'>
    readonly userId: FieldRef<"ChatbotSession", 'Int'>
    readonly title: FieldRef<"ChatbotSession", 'String'>
    readonly createdAt: FieldRef<"ChatbotSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatbotSession", 'DateTime'>
    readonly isActive: FieldRef<"ChatbotSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ChatbotSession findUnique
   */
  export type ChatbotSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSession to fetch.
     */
    where: ChatbotSessionWhereUniqueInput
  }

  /**
   * ChatbotSession findUniqueOrThrow
   */
  export type ChatbotSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSession to fetch.
     */
    where: ChatbotSessionWhereUniqueInput
  }

  /**
   * ChatbotSession findFirst
   */
  export type ChatbotSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSession to fetch.
     */
    where?: ChatbotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessions to fetch.
     */
    orderBy?: ChatbotSessionOrderByWithRelationInput | ChatbotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotSessions.
     */
    cursor?: ChatbotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotSessions.
     */
    distinct?: ChatbotSessionScalarFieldEnum | ChatbotSessionScalarFieldEnum[]
  }

  /**
   * ChatbotSession findFirstOrThrow
   */
  export type ChatbotSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSession to fetch.
     */
    where?: ChatbotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessions to fetch.
     */
    orderBy?: ChatbotSessionOrderByWithRelationInput | ChatbotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotSessions.
     */
    cursor?: ChatbotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotSessions.
     */
    distinct?: ChatbotSessionScalarFieldEnum | ChatbotSessionScalarFieldEnum[]
  }

  /**
   * ChatbotSession findMany
   */
  export type ChatbotSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSessions to fetch.
     */
    where?: ChatbotSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessions to fetch.
     */
    orderBy?: ChatbotSessionOrderByWithRelationInput | ChatbotSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatbotSessions.
     */
    cursor?: ChatbotSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessions.
     */
    skip?: number
    distinct?: ChatbotSessionScalarFieldEnum | ChatbotSessionScalarFieldEnum[]
  }

  /**
   * ChatbotSession create
   */
  export type ChatbotSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatbotSession.
     */
    data: XOR<ChatbotSessionCreateInput, ChatbotSessionUncheckedCreateInput>
  }

  /**
   * ChatbotSession createMany
   */
  export type ChatbotSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatbotSessions.
     */
    data: ChatbotSessionCreateManyInput | ChatbotSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatbotSession createManyAndReturn
   */
  export type ChatbotSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ChatbotSessions.
     */
    data: ChatbotSessionCreateManyInput | ChatbotSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotSession update
   */
  export type ChatbotSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatbotSession.
     */
    data: XOR<ChatbotSessionUpdateInput, ChatbotSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatbotSession to update.
     */
    where: ChatbotSessionWhereUniqueInput
  }

  /**
   * ChatbotSession updateMany
   */
  export type ChatbotSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatbotSessions.
     */
    data: XOR<ChatbotSessionUpdateManyMutationInput, ChatbotSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotSessions to update
     */
    where?: ChatbotSessionWhereInput
    /**
     * Limit how many ChatbotSessions to update.
     */
    limit?: number
  }

  /**
   * ChatbotSession updateManyAndReturn
   */
  export type ChatbotSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * The data used to update ChatbotSessions.
     */
    data: XOR<ChatbotSessionUpdateManyMutationInput, ChatbotSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotSessions to update
     */
    where?: ChatbotSessionWhereInput
    /**
     * Limit how many ChatbotSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotSession upsert
   */
  export type ChatbotSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatbotSession to update in case it exists.
     */
    where: ChatbotSessionWhereUniqueInput
    /**
     * In case the ChatbotSession found by the `where` argument doesn't exist, create a new ChatbotSession with this data.
     */
    create: XOR<ChatbotSessionCreateInput, ChatbotSessionUncheckedCreateInput>
    /**
     * In case the ChatbotSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotSessionUpdateInput, ChatbotSessionUncheckedUpdateInput>
  }

  /**
   * ChatbotSession delete
   */
  export type ChatbotSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatbotSession to delete.
     */
    where: ChatbotSessionWhereUniqueInput
  }

  /**
   * ChatbotSession deleteMany
   */
  export type ChatbotSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotSessions to delete
     */
    where?: ChatbotSessionWhereInput
    /**
     * Limit how many ChatbotSessions to delete.
     */
    limit?: number
  }

  /**
   * ChatbotSession.messages
   */
  export type ChatbotSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    where?: ChatbotMessageWhereInput
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    cursor?: ChatbotMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotSession.analytics
   */
  export type ChatbotSession$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    where?: ChatbotSessionAnalyticsWhereInput
  }

  /**
   * ChatbotSession without action
   */
  export type ChatbotSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSession
     */
    select?: ChatbotSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSession
     */
    omit?: ChatbotSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionInclude<ExtArgs> | null
  }


  /**
   * Model ChatbotMessage
   */

  export type AggregateChatbotMessage = {
    _count: ChatbotMessageCountAggregateOutputType | null
    _avg: ChatbotMessageAvgAggregateOutputType | null
    _sum: ChatbotMessageSumAggregateOutputType | null
    _min: ChatbotMessageMinAggregateOutputType | null
    _max: ChatbotMessageMaxAggregateOutputType | null
  }

  export type ChatbotMessageAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
    courseId: number | null
    moduleId: number | null
    promptTokens: number | null
    completionTokens: number | null
  }

  export type ChatbotMessageSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
    courseId: number | null
    moduleId: number | null
    promptTokens: number | null
    completionTokens: number | null
  }

  export type ChatbotMessageMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    content: string | null
    role: $Enums.MessageRole | null
    timestamp: Date | null
    referencedContent: string | null
    courseId: number | null
    moduleId: number | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
  }

  export type ChatbotMessageMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    content: string | null
    role: $Enums.MessageRole | null
    timestamp: Date | null
    referencedContent: string | null
    courseId: number | null
    moduleId: number | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
  }

  export type ChatbotMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    content: number
    role: number
    timestamp: number
    referencedContent: number
    courseId: number
    moduleId: number
    model: number
    promptTokens: number
    completionTokens: number
    _all: number
  }


  export type ChatbotMessageAvgAggregateInputType = {
    id?: true
    sessionId?: true
    courseId?: true
    moduleId?: true
    promptTokens?: true
    completionTokens?: true
  }

  export type ChatbotMessageSumAggregateInputType = {
    id?: true
    sessionId?: true
    courseId?: true
    moduleId?: true
    promptTokens?: true
    completionTokens?: true
  }

  export type ChatbotMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    content?: true
    role?: true
    timestamp?: true
    referencedContent?: true
    courseId?: true
    moduleId?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
  }

  export type ChatbotMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    content?: true
    role?: true
    timestamp?: true
    referencedContent?: true
    courseId?: true
    moduleId?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
  }

  export type ChatbotMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    content?: true
    role?: true
    timestamp?: true
    referencedContent?: true
    courseId?: true
    moduleId?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    _all?: true
  }

  export type ChatbotMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotMessage to aggregate.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatbotMessages
    **/
    _count?: true | ChatbotMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatbotMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatbotMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotMessageMaxAggregateInputType
  }

  export type GetChatbotMessageAggregateType<T extends ChatbotMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbotMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbotMessage[P]>
      : GetScalarType<T[P], AggregateChatbotMessage[P]>
  }




  export type ChatbotMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotMessageWhereInput
    orderBy?: ChatbotMessageOrderByWithAggregationInput | ChatbotMessageOrderByWithAggregationInput[]
    by: ChatbotMessageScalarFieldEnum[] | ChatbotMessageScalarFieldEnum
    having?: ChatbotMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotMessageCountAggregateInputType | true
    _avg?: ChatbotMessageAvgAggregateInputType
    _sum?: ChatbotMessageSumAggregateInputType
    _min?: ChatbotMessageMinAggregateInputType
    _max?: ChatbotMessageMaxAggregateInputType
  }

  export type ChatbotMessageGroupByOutputType = {
    id: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp: Date
    referencedContent: string | null
    courseId: number | null
    moduleId: number | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    _count: ChatbotMessageCountAggregateOutputType | null
    _avg: ChatbotMessageAvgAggregateOutputType | null
    _sum: ChatbotMessageSumAggregateOutputType | null
    _min: ChatbotMessageMinAggregateOutputType | null
    _max: ChatbotMessageMaxAggregateOutputType | null
  }

  type GetChatbotMessageGroupByPayload<T extends ChatbotMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    content?: boolean
    role?: boolean
    timestamp?: boolean
    referencedContent?: boolean
    courseId?: boolean
    moduleId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
    course?: boolean | ChatbotMessage$courseArgs<ExtArgs>
    module?: boolean | ChatbotMessage$moduleArgs<ExtArgs>
    feedback?: boolean | ChatbotMessage$feedbackArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotMessage"]>

  export type ChatbotMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    content?: boolean
    role?: boolean
    timestamp?: boolean
    referencedContent?: boolean
    courseId?: boolean
    moduleId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
    course?: boolean | ChatbotMessage$courseArgs<ExtArgs>
    module?: boolean | ChatbotMessage$moduleArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotMessage"]>

  export type ChatbotMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    content?: boolean
    role?: boolean
    timestamp?: boolean
    referencedContent?: boolean
    courseId?: boolean
    moduleId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
    course?: boolean | ChatbotMessage$courseArgs<ExtArgs>
    module?: boolean | ChatbotMessage$moduleArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotMessage"]>

  export type ChatbotMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    content?: boolean
    role?: boolean
    timestamp?: boolean
    referencedContent?: boolean
    courseId?: boolean
    moduleId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
  }

  export type ChatbotMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "content" | "role" | "timestamp" | "referencedContent" | "courseId" | "moduleId" | "model" | "promptTokens" | "completionTokens", ExtArgs["result"]["chatbotMessage"]>
  export type ChatbotMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
    course?: boolean | ChatbotMessage$courseArgs<ExtArgs>
    module?: boolean | ChatbotMessage$moduleArgs<ExtArgs>
    feedback?: boolean | ChatbotMessage$feedbackArgs<ExtArgs>
  }
  export type ChatbotMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
    course?: boolean | ChatbotMessage$courseArgs<ExtArgs>
    module?: boolean | ChatbotMessage$moduleArgs<ExtArgs>
  }
  export type ChatbotMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
    course?: boolean | ChatbotMessage$courseArgs<ExtArgs>
    module?: boolean | ChatbotMessage$moduleArgs<ExtArgs>
  }

  export type $ChatbotMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatbotMessage"
    objects: {
      session: Prisma.$ChatbotSessionPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$CourseModulePayload<ExtArgs> | null
      feedback: Prisma.$ChatbotFeedbackPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      content: string
      role: $Enums.MessageRole
      timestamp: Date
      referencedContent: string | null
      courseId: number | null
      moduleId: number | null
      model: string | null
      promptTokens: number | null
      completionTokens: number | null
    }, ExtArgs["result"]["chatbotMessage"]>
    composites: {}
  }

  type ChatbotMessageGetPayload<S extends boolean | null | undefined | ChatbotMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatbotMessagePayload, S>

  type ChatbotMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotMessageCountAggregateInputType | true
    }

  export interface ChatbotMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatbotMessage'], meta: { name: 'ChatbotMessage' } }
    /**
     * Find zero or one ChatbotMessage that matches the filter.
     * @param {ChatbotMessageFindUniqueArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotMessageFindUniqueArgs>(args: SelectSubset<T, ChatbotMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatbotMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageFindFirstArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotMessageFindFirstArgs>(args?: SelectSubset<T, ChatbotMessageFindFirstArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageFindFirstOrThrowArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatbotMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatbotMessages
     * const chatbotMessages = await prisma.chatbotMessage.findMany()
     * 
     * // Get first 10 ChatbotMessages
     * const chatbotMessages = await prisma.chatbotMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatbotMessageWithIdOnly = await prisma.chatbotMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatbotMessageFindManyArgs>(args?: SelectSubset<T, ChatbotMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatbotMessage.
     * @param {ChatbotMessageCreateArgs} args - Arguments to create a ChatbotMessage.
     * @example
     * // Create one ChatbotMessage
     * const ChatbotMessage = await prisma.chatbotMessage.create({
     *   data: {
     *     // ... data to create a ChatbotMessage
     *   }
     * })
     * 
     */
    create<T extends ChatbotMessageCreateArgs>(args: SelectSubset<T, ChatbotMessageCreateArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatbotMessages.
     * @param {ChatbotMessageCreateManyArgs} args - Arguments to create many ChatbotMessages.
     * @example
     * // Create many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotMessageCreateManyArgs>(args?: SelectSubset<T, ChatbotMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatbotMessages and returns the data saved in the database.
     * @param {ChatbotMessageCreateManyAndReturnArgs} args - Arguments to create many ChatbotMessages.
     * @example
     * // Create many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatbotMessages and only return the `id`
     * const chatbotMessageWithIdOnly = await prisma.chatbotMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatbotMessage.
     * @param {ChatbotMessageDeleteArgs} args - Arguments to delete one ChatbotMessage.
     * @example
     * // Delete one ChatbotMessage
     * const ChatbotMessage = await prisma.chatbotMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatbotMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatbotMessageDeleteArgs>(args: SelectSubset<T, ChatbotMessageDeleteArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatbotMessage.
     * @param {ChatbotMessageUpdateArgs} args - Arguments to update one ChatbotMessage.
     * @example
     * // Update one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotMessageUpdateArgs>(args: SelectSubset<T, ChatbotMessageUpdateArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatbotMessages.
     * @param {ChatbotMessageDeleteManyArgs} args - Arguments to filter ChatbotMessages to delete.
     * @example
     * // Delete a few ChatbotMessages
     * const { count } = await prisma.chatbotMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotMessageDeleteManyArgs>(args?: SelectSubset<T, ChatbotMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotMessageUpdateManyArgs>(args: SelectSubset<T, ChatbotMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotMessages and returns the data updated in the database.
     * @param {ChatbotMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatbotMessages.
     * @example
     * // Update many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatbotMessages and only return the `id`
     * const chatbotMessageWithIdOnly = await prisma.chatbotMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatbotMessage.
     * @param {ChatbotMessageUpsertArgs} args - Arguments to update or create a ChatbotMessage.
     * @example
     * // Update or create a ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.upsert({
     *   create: {
     *     // ... data to create a ChatbotMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatbotMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotMessageUpsertArgs>(args: SelectSubset<T, ChatbotMessageUpsertArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatbotMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageCountArgs} args - Arguments to filter ChatbotMessages to count.
     * @example
     * // Count the number of ChatbotMessages
     * const count = await prisma.chatbotMessage.count({
     *   where: {
     *     // ... the filter for the ChatbotMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatbotMessageCountArgs>(
      args?: Subset<T, ChatbotMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatbotMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotMessageAggregateArgs>(args: Subset<T, ChatbotMessageAggregateArgs>): Prisma.PrismaPromise<GetChatbotMessageAggregateType<T>>

    /**
     * Group by ChatbotMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatbotMessage model
   */
  readonly fields: ChatbotMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatbotMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatbotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotSessionDefaultArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends ChatbotMessage$courseArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotMessage$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    module<T extends ChatbotMessage$moduleArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotMessage$moduleArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedback<T extends ChatbotMessage$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotMessage$feedbackArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatbotMessage model
   */
  interface ChatbotMessageFieldRefs {
    readonly id: FieldRef<"ChatbotMessage", 'Int'>
    readonly sessionId: FieldRef<"ChatbotMessage", 'Int'>
    readonly content: FieldRef<"ChatbotMessage", 'String'>
    readonly role: FieldRef<"ChatbotMessage", 'MessageRole'>
    readonly timestamp: FieldRef<"ChatbotMessage", 'DateTime'>
    readonly referencedContent: FieldRef<"ChatbotMessage", 'String'>
    readonly courseId: FieldRef<"ChatbotMessage", 'Int'>
    readonly moduleId: FieldRef<"ChatbotMessage", 'Int'>
    readonly model: FieldRef<"ChatbotMessage", 'String'>
    readonly promptTokens: FieldRef<"ChatbotMessage", 'Int'>
    readonly completionTokens: FieldRef<"ChatbotMessage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChatbotMessage findUnique
   */
  export type ChatbotMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage findUniqueOrThrow
   */
  export type ChatbotMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage findFirst
   */
  export type ChatbotMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotMessages.
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotMessages.
     */
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotMessage findFirstOrThrow
   */
  export type ChatbotMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotMessages.
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotMessages.
     */
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotMessage findMany
   */
  export type ChatbotMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessages to fetch.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatbotMessages.
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotMessage create
   */
  export type ChatbotMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatbotMessage.
     */
    data: XOR<ChatbotMessageCreateInput, ChatbotMessageUncheckedCreateInput>
  }

  /**
   * ChatbotMessage createMany
   */
  export type ChatbotMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatbotMessages.
     */
    data: ChatbotMessageCreateManyInput | ChatbotMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatbotMessage createManyAndReturn
   */
  export type ChatbotMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatbotMessages.
     */
    data: ChatbotMessageCreateManyInput | ChatbotMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotMessage update
   */
  export type ChatbotMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatbotMessage.
     */
    data: XOR<ChatbotMessageUpdateInput, ChatbotMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatbotMessage to update.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage updateMany
   */
  export type ChatbotMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatbotMessages.
     */
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotMessages to update
     */
    where?: ChatbotMessageWhereInput
    /**
     * Limit how many ChatbotMessages to update.
     */
    limit?: number
  }

  /**
   * ChatbotMessage updateManyAndReturn
   */
  export type ChatbotMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatbotMessages.
     */
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotMessages to update
     */
    where?: ChatbotMessageWhereInput
    /**
     * Limit how many ChatbotMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotMessage upsert
   */
  export type ChatbotMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatbotMessage to update in case it exists.
     */
    where: ChatbotMessageWhereUniqueInput
    /**
     * In case the ChatbotMessage found by the `where` argument doesn't exist, create a new ChatbotMessage with this data.
     */
    create: XOR<ChatbotMessageCreateInput, ChatbotMessageUncheckedCreateInput>
    /**
     * In case the ChatbotMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotMessageUpdateInput, ChatbotMessageUncheckedUpdateInput>
  }

  /**
   * ChatbotMessage delete
   */
  export type ChatbotMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatbotMessage to delete.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage deleteMany
   */
  export type ChatbotMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotMessages to delete
     */
    where?: ChatbotMessageWhereInput
    /**
     * Limit how many ChatbotMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatbotMessage.course
   */
  export type ChatbotMessage$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * ChatbotMessage.module
   */
  export type ChatbotMessage$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
  }

  /**
   * ChatbotMessage.feedback
   */
  export type ChatbotMessage$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    where?: ChatbotFeedbackWhereInput
  }

  /**
   * ChatbotMessage without action
   */
  export type ChatbotMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
  }


  /**
   * Model ChatbotFeedback
   */

  export type AggregateChatbotFeedback = {
    _count: ChatbotFeedbackCountAggregateOutputType | null
    _avg: ChatbotFeedbackAvgAggregateOutputType | null
    _sum: ChatbotFeedbackSumAggregateOutputType | null
    _min: ChatbotFeedbackMinAggregateOutputType | null
    _max: ChatbotFeedbackMaxAggregateOutputType | null
  }

  export type ChatbotFeedbackAvgAggregateOutputType = {
    id: number | null
    messageId: number | null
    userId: number | null
    rating: number | null
  }

  export type ChatbotFeedbackSumAggregateOutputType = {
    id: number | null
    messageId: number | null
    userId: number | null
    rating: number | null
  }

  export type ChatbotFeedbackMinAggregateOutputType = {
    id: number | null
    messageId: number | null
    userId: number | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type ChatbotFeedbackMaxAggregateOutputType = {
    id: number | null
    messageId: number | null
    userId: number | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type ChatbotFeedbackCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    rating: number
    feedback: number
    createdAt: number
    _all: number
  }


  export type ChatbotFeedbackAvgAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    rating?: true
  }

  export type ChatbotFeedbackSumAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    rating?: true
  }

  export type ChatbotFeedbackMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    rating?: true
    feedback?: true
    createdAt?: true
  }

  export type ChatbotFeedbackMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    rating?: true
    feedback?: true
    createdAt?: true
  }

  export type ChatbotFeedbackCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    rating?: true
    feedback?: true
    createdAt?: true
    _all?: true
  }

  export type ChatbotFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotFeedback to aggregate.
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotFeedbacks to fetch.
     */
    orderBy?: ChatbotFeedbackOrderByWithRelationInput | ChatbotFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatbotFeedbacks
    **/
    _count?: true | ChatbotFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatbotFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatbotFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotFeedbackMaxAggregateInputType
  }

  export type GetChatbotFeedbackAggregateType<T extends ChatbotFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbotFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbotFeedback[P]>
      : GetScalarType<T[P], AggregateChatbotFeedback[P]>
  }




  export type ChatbotFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotFeedbackWhereInput
    orderBy?: ChatbotFeedbackOrderByWithAggregationInput | ChatbotFeedbackOrderByWithAggregationInput[]
    by: ChatbotFeedbackScalarFieldEnum[] | ChatbotFeedbackScalarFieldEnum
    having?: ChatbotFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotFeedbackCountAggregateInputType | true
    _avg?: ChatbotFeedbackAvgAggregateInputType
    _sum?: ChatbotFeedbackSumAggregateInputType
    _min?: ChatbotFeedbackMinAggregateInputType
    _max?: ChatbotFeedbackMaxAggregateInputType
  }

  export type ChatbotFeedbackGroupByOutputType = {
    id: number
    messageId: number
    userId: number
    rating: number | null
    feedback: string | null
    createdAt: Date
    _count: ChatbotFeedbackCountAggregateOutputType | null
    _avg: ChatbotFeedbackAvgAggregateOutputType | null
    _sum: ChatbotFeedbackSumAggregateOutputType | null
    _min: ChatbotFeedbackMinAggregateOutputType | null
    _max: ChatbotFeedbackMaxAggregateOutputType | null
  }

  type GetChatbotFeedbackGroupByPayload<T extends ChatbotFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    message?: boolean | ChatbotMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotFeedback"]>

  export type ChatbotFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    message?: boolean | ChatbotMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotFeedback"]>

  export type ChatbotFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    message?: boolean | ChatbotMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotFeedback"]>

  export type ChatbotFeedbackSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
  }

  export type ChatbotFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "userId" | "rating" | "feedback" | "createdAt", ExtArgs["result"]["chatbotFeedback"]>
  export type ChatbotFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | ChatbotMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatbotFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | ChatbotMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatbotFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | ChatbotMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatbotFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatbotFeedback"
    objects: {
      message: Prisma.$ChatbotMessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      messageId: number
      userId: number
      rating: number | null
      feedback: string | null
      createdAt: Date
    }, ExtArgs["result"]["chatbotFeedback"]>
    composites: {}
  }

  type ChatbotFeedbackGetPayload<S extends boolean | null | undefined | ChatbotFeedbackDefaultArgs> = $Result.GetResult<Prisma.$ChatbotFeedbackPayload, S>

  type ChatbotFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotFeedbackCountAggregateInputType | true
    }

  export interface ChatbotFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatbotFeedback'], meta: { name: 'ChatbotFeedback' } }
    /**
     * Find zero or one ChatbotFeedback that matches the filter.
     * @param {ChatbotFeedbackFindUniqueArgs} args - Arguments to find a ChatbotFeedback
     * @example
     * // Get one ChatbotFeedback
     * const chatbotFeedback = await prisma.chatbotFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotFeedbackFindUniqueArgs>(args: SelectSubset<T, ChatbotFeedbackFindUniqueArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatbotFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotFeedbackFindUniqueOrThrowArgs} args - Arguments to find a ChatbotFeedback
     * @example
     * // Get one ChatbotFeedback
     * const chatbotFeedback = await prisma.chatbotFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackFindFirstArgs} args - Arguments to find a ChatbotFeedback
     * @example
     * // Get one ChatbotFeedback
     * const chatbotFeedback = await prisma.chatbotFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotFeedbackFindFirstArgs>(args?: SelectSubset<T, ChatbotFeedbackFindFirstArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackFindFirstOrThrowArgs} args - Arguments to find a ChatbotFeedback
     * @example
     * // Get one ChatbotFeedback
     * const chatbotFeedback = await prisma.chatbotFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatbotFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatbotFeedbacks
     * const chatbotFeedbacks = await prisma.chatbotFeedback.findMany()
     * 
     * // Get first 10 ChatbotFeedbacks
     * const chatbotFeedbacks = await prisma.chatbotFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatbotFeedbackWithIdOnly = await prisma.chatbotFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatbotFeedbackFindManyArgs>(args?: SelectSubset<T, ChatbotFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatbotFeedback.
     * @param {ChatbotFeedbackCreateArgs} args - Arguments to create a ChatbotFeedback.
     * @example
     * // Create one ChatbotFeedback
     * const ChatbotFeedback = await prisma.chatbotFeedback.create({
     *   data: {
     *     // ... data to create a ChatbotFeedback
     *   }
     * })
     * 
     */
    create<T extends ChatbotFeedbackCreateArgs>(args: SelectSubset<T, ChatbotFeedbackCreateArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatbotFeedbacks.
     * @param {ChatbotFeedbackCreateManyArgs} args - Arguments to create many ChatbotFeedbacks.
     * @example
     * // Create many ChatbotFeedbacks
     * const chatbotFeedback = await prisma.chatbotFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotFeedbackCreateManyArgs>(args?: SelectSubset<T, ChatbotFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatbotFeedbacks and returns the data saved in the database.
     * @param {ChatbotFeedbackCreateManyAndReturnArgs} args - Arguments to create many ChatbotFeedbacks.
     * @example
     * // Create many ChatbotFeedbacks
     * const chatbotFeedback = await prisma.chatbotFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatbotFeedbacks and only return the `id`
     * const chatbotFeedbackWithIdOnly = await prisma.chatbotFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatbotFeedback.
     * @param {ChatbotFeedbackDeleteArgs} args - Arguments to delete one ChatbotFeedback.
     * @example
     * // Delete one ChatbotFeedback
     * const ChatbotFeedback = await prisma.chatbotFeedback.delete({
     *   where: {
     *     // ... filter to delete one ChatbotFeedback
     *   }
     * })
     * 
     */
    delete<T extends ChatbotFeedbackDeleteArgs>(args: SelectSubset<T, ChatbotFeedbackDeleteArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatbotFeedback.
     * @param {ChatbotFeedbackUpdateArgs} args - Arguments to update one ChatbotFeedback.
     * @example
     * // Update one ChatbotFeedback
     * const chatbotFeedback = await prisma.chatbotFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotFeedbackUpdateArgs>(args: SelectSubset<T, ChatbotFeedbackUpdateArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatbotFeedbacks.
     * @param {ChatbotFeedbackDeleteManyArgs} args - Arguments to filter ChatbotFeedbacks to delete.
     * @example
     * // Delete a few ChatbotFeedbacks
     * const { count } = await prisma.chatbotFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotFeedbackDeleteManyArgs>(args?: SelectSubset<T, ChatbotFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatbotFeedbacks
     * const chatbotFeedback = await prisma.chatbotFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotFeedbackUpdateManyArgs>(args: SelectSubset<T, ChatbotFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotFeedbacks and returns the data updated in the database.
     * @param {ChatbotFeedbackUpdateManyAndReturnArgs} args - Arguments to update many ChatbotFeedbacks.
     * @example
     * // Update many ChatbotFeedbacks
     * const chatbotFeedback = await prisma.chatbotFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatbotFeedbacks and only return the `id`
     * const chatbotFeedbackWithIdOnly = await prisma.chatbotFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatbotFeedback.
     * @param {ChatbotFeedbackUpsertArgs} args - Arguments to update or create a ChatbotFeedback.
     * @example
     * // Update or create a ChatbotFeedback
     * const chatbotFeedback = await prisma.chatbotFeedback.upsert({
     *   create: {
     *     // ... data to create a ChatbotFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatbotFeedback we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotFeedbackUpsertArgs>(args: SelectSubset<T, ChatbotFeedbackUpsertArgs<ExtArgs>>): Prisma__ChatbotFeedbackClient<$Result.GetResult<Prisma.$ChatbotFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatbotFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackCountArgs} args - Arguments to filter ChatbotFeedbacks to count.
     * @example
     * // Count the number of ChatbotFeedbacks
     * const count = await prisma.chatbotFeedback.count({
     *   where: {
     *     // ... the filter for the ChatbotFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ChatbotFeedbackCountArgs>(
      args?: Subset<T, ChatbotFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatbotFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotFeedbackAggregateArgs>(args: Subset<T, ChatbotFeedbackAggregateArgs>): Prisma.PrismaPromise<GetChatbotFeedbackAggregateType<T>>

    /**
     * Group by ChatbotFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatbotFeedback model
   */
  readonly fields: ChatbotFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatbotFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends ChatbotMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotMessageDefaultArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatbotFeedback model
   */
  interface ChatbotFeedbackFieldRefs {
    readonly id: FieldRef<"ChatbotFeedback", 'Int'>
    readonly messageId: FieldRef<"ChatbotFeedback", 'Int'>
    readonly userId: FieldRef<"ChatbotFeedback", 'Int'>
    readonly rating: FieldRef<"ChatbotFeedback", 'Int'>
    readonly feedback: FieldRef<"ChatbotFeedback", 'String'>
    readonly createdAt: FieldRef<"ChatbotFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatbotFeedback findUnique
   */
  export type ChatbotFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotFeedback to fetch.
     */
    where: ChatbotFeedbackWhereUniqueInput
  }

  /**
   * ChatbotFeedback findUniqueOrThrow
   */
  export type ChatbotFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotFeedback to fetch.
     */
    where: ChatbotFeedbackWhereUniqueInput
  }

  /**
   * ChatbotFeedback findFirst
   */
  export type ChatbotFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotFeedback to fetch.
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotFeedbacks to fetch.
     */
    orderBy?: ChatbotFeedbackOrderByWithRelationInput | ChatbotFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotFeedbacks.
     */
    cursor?: ChatbotFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotFeedbacks.
     */
    distinct?: ChatbotFeedbackScalarFieldEnum | ChatbotFeedbackScalarFieldEnum[]
  }

  /**
   * ChatbotFeedback findFirstOrThrow
   */
  export type ChatbotFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotFeedback to fetch.
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotFeedbacks to fetch.
     */
    orderBy?: ChatbotFeedbackOrderByWithRelationInput | ChatbotFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotFeedbacks.
     */
    cursor?: ChatbotFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotFeedbacks.
     */
    distinct?: ChatbotFeedbackScalarFieldEnum | ChatbotFeedbackScalarFieldEnum[]
  }

  /**
   * ChatbotFeedback findMany
   */
  export type ChatbotFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotFeedbacks to fetch.
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotFeedbacks to fetch.
     */
    orderBy?: ChatbotFeedbackOrderByWithRelationInput | ChatbotFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatbotFeedbacks.
     */
    cursor?: ChatbotFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotFeedbacks.
     */
    skip?: number
    distinct?: ChatbotFeedbackScalarFieldEnum | ChatbotFeedbackScalarFieldEnum[]
  }

  /**
   * ChatbotFeedback create
   */
  export type ChatbotFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatbotFeedback.
     */
    data: XOR<ChatbotFeedbackCreateInput, ChatbotFeedbackUncheckedCreateInput>
  }

  /**
   * ChatbotFeedback createMany
   */
  export type ChatbotFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatbotFeedbacks.
     */
    data: ChatbotFeedbackCreateManyInput | ChatbotFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatbotFeedback createManyAndReturn
   */
  export type ChatbotFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many ChatbotFeedbacks.
     */
    data: ChatbotFeedbackCreateManyInput | ChatbotFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotFeedback update
   */
  export type ChatbotFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatbotFeedback.
     */
    data: XOR<ChatbotFeedbackUpdateInput, ChatbotFeedbackUncheckedUpdateInput>
    /**
     * Choose, which ChatbotFeedback to update.
     */
    where: ChatbotFeedbackWhereUniqueInput
  }

  /**
   * ChatbotFeedback updateMany
   */
  export type ChatbotFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatbotFeedbacks.
     */
    data: XOR<ChatbotFeedbackUpdateManyMutationInput, ChatbotFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotFeedbacks to update
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * Limit how many ChatbotFeedbacks to update.
     */
    limit?: number
  }

  /**
   * ChatbotFeedback updateManyAndReturn
   */
  export type ChatbotFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update ChatbotFeedbacks.
     */
    data: XOR<ChatbotFeedbackUpdateManyMutationInput, ChatbotFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotFeedbacks to update
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * Limit how many ChatbotFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotFeedback upsert
   */
  export type ChatbotFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatbotFeedback to update in case it exists.
     */
    where: ChatbotFeedbackWhereUniqueInput
    /**
     * In case the ChatbotFeedback found by the `where` argument doesn't exist, create a new ChatbotFeedback with this data.
     */
    create: XOR<ChatbotFeedbackCreateInput, ChatbotFeedbackUncheckedCreateInput>
    /**
     * In case the ChatbotFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotFeedbackUpdateInput, ChatbotFeedbackUncheckedUpdateInput>
  }

  /**
   * ChatbotFeedback delete
   */
  export type ChatbotFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
    /**
     * Filter which ChatbotFeedback to delete.
     */
    where: ChatbotFeedbackWhereUniqueInput
  }

  /**
   * ChatbotFeedback deleteMany
   */
  export type ChatbotFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotFeedbacks to delete
     */
    where?: ChatbotFeedbackWhereInput
    /**
     * Limit how many ChatbotFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * ChatbotFeedback without action
   */
  export type ChatbotFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotFeedback
     */
    select?: ChatbotFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotFeedback
     */
    omit?: ChatbotFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model ChatbotSessionAnalytics
   */

  export type AggregateChatbotSessionAnalytics = {
    _count: ChatbotSessionAnalyticsCountAggregateOutputType | null
    _avg: ChatbotSessionAnalyticsAvgAggregateOutputType | null
    _sum: ChatbotSessionAnalyticsSumAggregateOutputType | null
    _min: ChatbotSessionAnalyticsMinAggregateOutputType | null
    _max: ChatbotSessionAnalyticsMaxAggregateOutputType | null
  }

  export type ChatbotSessionAnalyticsAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
    messageCount: number | null
    userMessageCount: number | null
    aiMessageCount: number | null
    averageUserMessageLength: number | null
    averageAiResponseLength: number | null
  }

  export type ChatbotSessionAnalyticsSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
    messageCount: number | null
    userMessageCount: number | null
    aiMessageCount: number | null
    averageUserMessageLength: number | null
    averageAiResponseLength: number | null
  }

  export type ChatbotSessionAnalyticsMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    messageCount: number | null
    userMessageCount: number | null
    aiMessageCount: number | null
    averageUserMessageLength: number | null
    averageAiResponseLength: number | null
    topicsDiscussed: string | null
  }

  export type ChatbotSessionAnalyticsMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    messageCount: number | null
    userMessageCount: number | null
    aiMessageCount: number | null
    averageUserMessageLength: number | null
    averageAiResponseLength: number | null
    topicsDiscussed: string | null
  }

  export type ChatbotSessionAnalyticsCountAggregateOutputType = {
    id: number
    sessionId: number
    messageCount: number
    userMessageCount: number
    aiMessageCount: number
    averageUserMessageLength: number
    averageAiResponseLength: number
    topicsDiscussed: number
    _all: number
  }


  export type ChatbotSessionAnalyticsAvgAggregateInputType = {
    id?: true
    sessionId?: true
    messageCount?: true
    userMessageCount?: true
    aiMessageCount?: true
    averageUserMessageLength?: true
    averageAiResponseLength?: true
  }

  export type ChatbotSessionAnalyticsSumAggregateInputType = {
    id?: true
    sessionId?: true
    messageCount?: true
    userMessageCount?: true
    aiMessageCount?: true
    averageUserMessageLength?: true
    averageAiResponseLength?: true
  }

  export type ChatbotSessionAnalyticsMinAggregateInputType = {
    id?: true
    sessionId?: true
    messageCount?: true
    userMessageCount?: true
    aiMessageCount?: true
    averageUserMessageLength?: true
    averageAiResponseLength?: true
    topicsDiscussed?: true
  }

  export type ChatbotSessionAnalyticsMaxAggregateInputType = {
    id?: true
    sessionId?: true
    messageCount?: true
    userMessageCount?: true
    aiMessageCount?: true
    averageUserMessageLength?: true
    averageAiResponseLength?: true
    topicsDiscussed?: true
  }

  export type ChatbotSessionAnalyticsCountAggregateInputType = {
    id?: true
    sessionId?: true
    messageCount?: true
    userMessageCount?: true
    aiMessageCount?: true
    averageUserMessageLength?: true
    averageAiResponseLength?: true
    topicsDiscussed?: true
    _all?: true
  }

  export type ChatbotSessionAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotSessionAnalytics to aggregate.
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessionAnalytics to fetch.
     */
    orderBy?: ChatbotSessionAnalyticsOrderByWithRelationInput | ChatbotSessionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotSessionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessionAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatbotSessionAnalytics
    **/
    _count?: true | ChatbotSessionAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatbotSessionAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatbotSessionAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotSessionAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotSessionAnalyticsMaxAggregateInputType
  }

  export type GetChatbotSessionAnalyticsAggregateType<T extends ChatbotSessionAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbotSessionAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbotSessionAnalytics[P]>
      : GetScalarType<T[P], AggregateChatbotSessionAnalytics[P]>
  }




  export type ChatbotSessionAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotSessionAnalyticsWhereInput
    orderBy?: ChatbotSessionAnalyticsOrderByWithAggregationInput | ChatbotSessionAnalyticsOrderByWithAggregationInput[]
    by: ChatbotSessionAnalyticsScalarFieldEnum[] | ChatbotSessionAnalyticsScalarFieldEnum
    having?: ChatbotSessionAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotSessionAnalyticsCountAggregateInputType | true
    _avg?: ChatbotSessionAnalyticsAvgAggregateInputType
    _sum?: ChatbotSessionAnalyticsSumAggregateInputType
    _min?: ChatbotSessionAnalyticsMinAggregateInputType
    _max?: ChatbotSessionAnalyticsMaxAggregateInputType
  }

  export type ChatbotSessionAnalyticsGroupByOutputType = {
    id: number
    sessionId: number
    messageCount: number
    userMessageCount: number
    aiMessageCount: number
    averageUserMessageLength: number | null
    averageAiResponseLength: number | null
    topicsDiscussed: string | null
    _count: ChatbotSessionAnalyticsCountAggregateOutputType | null
    _avg: ChatbotSessionAnalyticsAvgAggregateOutputType | null
    _sum: ChatbotSessionAnalyticsSumAggregateOutputType | null
    _min: ChatbotSessionAnalyticsMinAggregateOutputType | null
    _max: ChatbotSessionAnalyticsMaxAggregateOutputType | null
  }

  type GetChatbotSessionAnalyticsGroupByPayload<T extends ChatbotSessionAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotSessionAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotSessionAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotSessionAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotSessionAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotSessionAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageCount?: boolean
    userMessageCount?: boolean
    aiMessageCount?: boolean
    averageUserMessageLength?: boolean
    averageAiResponseLength?: boolean
    topicsDiscussed?: boolean
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotSessionAnalytics"]>

  export type ChatbotSessionAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageCount?: boolean
    userMessageCount?: boolean
    aiMessageCount?: boolean
    averageUserMessageLength?: boolean
    averageAiResponseLength?: boolean
    topicsDiscussed?: boolean
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotSessionAnalytics"]>

  export type ChatbotSessionAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageCount?: boolean
    userMessageCount?: boolean
    aiMessageCount?: boolean
    averageUserMessageLength?: boolean
    averageAiResponseLength?: boolean
    topicsDiscussed?: boolean
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotSessionAnalytics"]>

  export type ChatbotSessionAnalyticsSelectScalar = {
    id?: boolean
    sessionId?: boolean
    messageCount?: boolean
    userMessageCount?: boolean
    aiMessageCount?: boolean
    averageUserMessageLength?: boolean
    averageAiResponseLength?: boolean
    topicsDiscussed?: boolean
  }

  export type ChatbotSessionAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "messageCount" | "userMessageCount" | "aiMessageCount" | "averageUserMessageLength" | "averageAiResponseLength" | "topicsDiscussed", ExtArgs["result"]["chatbotSessionAnalytics"]>
  export type ChatbotSessionAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
  }
  export type ChatbotSessionAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
  }
  export type ChatbotSessionAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatbotSessionDefaultArgs<ExtArgs>
  }

  export type $ChatbotSessionAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatbotSessionAnalytics"
    objects: {
      session: Prisma.$ChatbotSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      messageCount: number
      userMessageCount: number
      aiMessageCount: number
      averageUserMessageLength: number | null
      averageAiResponseLength: number | null
      topicsDiscussed: string | null
    }, ExtArgs["result"]["chatbotSessionAnalytics"]>
    composites: {}
  }

  type ChatbotSessionAnalyticsGetPayload<S extends boolean | null | undefined | ChatbotSessionAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload, S>

  type ChatbotSessionAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotSessionAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotSessionAnalyticsCountAggregateInputType | true
    }

  export interface ChatbotSessionAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatbotSessionAnalytics'], meta: { name: 'ChatbotSessionAnalytics' } }
    /**
     * Find zero or one ChatbotSessionAnalytics that matches the filter.
     * @param {ChatbotSessionAnalyticsFindUniqueArgs} args - Arguments to find a ChatbotSessionAnalytics
     * @example
     * // Get one ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotSessionAnalyticsFindUniqueArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatbotSessionAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotSessionAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a ChatbotSessionAnalytics
     * @example
     * // Get one ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotSessionAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotSessionAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsFindFirstArgs} args - Arguments to find a ChatbotSessionAnalytics
     * @example
     * // Get one ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotSessionAnalyticsFindFirstArgs>(args?: SelectSubset<T, ChatbotSessionAnalyticsFindFirstArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotSessionAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsFindFirstOrThrowArgs} args - Arguments to find a ChatbotSessionAnalytics
     * @example
     * // Get one ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotSessionAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotSessionAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatbotSessionAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findMany()
     * 
     * // Get first 10 ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatbotSessionAnalyticsWithIdOnly = await prisma.chatbotSessionAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatbotSessionAnalyticsFindManyArgs>(args?: SelectSubset<T, ChatbotSessionAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatbotSessionAnalytics.
     * @param {ChatbotSessionAnalyticsCreateArgs} args - Arguments to create a ChatbotSessionAnalytics.
     * @example
     * // Create one ChatbotSessionAnalytics
     * const ChatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.create({
     *   data: {
     *     // ... data to create a ChatbotSessionAnalytics
     *   }
     * })
     * 
     */
    create<T extends ChatbotSessionAnalyticsCreateArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsCreateArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatbotSessionAnalytics.
     * @param {ChatbotSessionAnalyticsCreateManyArgs} args - Arguments to create many ChatbotSessionAnalytics.
     * @example
     * // Create many ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotSessionAnalyticsCreateManyArgs>(args?: SelectSubset<T, ChatbotSessionAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatbotSessionAnalytics and returns the data saved in the database.
     * @param {ChatbotSessionAnalyticsCreateManyAndReturnArgs} args - Arguments to create many ChatbotSessionAnalytics.
     * @example
     * // Create many ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatbotSessionAnalytics and only return the `id`
     * const chatbotSessionAnalyticsWithIdOnly = await prisma.chatbotSessionAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotSessionAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotSessionAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatbotSessionAnalytics.
     * @param {ChatbotSessionAnalyticsDeleteArgs} args - Arguments to delete one ChatbotSessionAnalytics.
     * @example
     * // Delete one ChatbotSessionAnalytics
     * const ChatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.delete({
     *   where: {
     *     // ... filter to delete one ChatbotSessionAnalytics
     *   }
     * })
     * 
     */
    delete<T extends ChatbotSessionAnalyticsDeleteArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsDeleteArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatbotSessionAnalytics.
     * @param {ChatbotSessionAnalyticsUpdateArgs} args - Arguments to update one ChatbotSessionAnalytics.
     * @example
     * // Update one ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotSessionAnalyticsUpdateArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsUpdateArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatbotSessionAnalytics.
     * @param {ChatbotSessionAnalyticsDeleteManyArgs} args - Arguments to filter ChatbotSessionAnalytics to delete.
     * @example
     * // Delete a few ChatbotSessionAnalytics
     * const { count } = await prisma.chatbotSessionAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotSessionAnalyticsDeleteManyArgs>(args?: SelectSubset<T, ChatbotSessionAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotSessionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotSessionAnalyticsUpdateManyArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotSessionAnalytics and returns the data updated in the database.
     * @param {ChatbotSessionAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many ChatbotSessionAnalytics.
     * @example
     * // Update many ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatbotSessionAnalytics and only return the `id`
     * const chatbotSessionAnalyticsWithIdOnly = await prisma.chatbotSessionAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotSessionAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatbotSessionAnalytics.
     * @param {ChatbotSessionAnalyticsUpsertArgs} args - Arguments to update or create a ChatbotSessionAnalytics.
     * @example
     * // Update or create a ChatbotSessionAnalytics
     * const chatbotSessionAnalytics = await prisma.chatbotSessionAnalytics.upsert({
     *   create: {
     *     // ... data to create a ChatbotSessionAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatbotSessionAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotSessionAnalyticsUpsertArgs>(args: SelectSubset<T, ChatbotSessionAnalyticsUpsertArgs<ExtArgs>>): Prisma__ChatbotSessionAnalyticsClient<$Result.GetResult<Prisma.$ChatbotSessionAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatbotSessionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsCountArgs} args - Arguments to filter ChatbotSessionAnalytics to count.
     * @example
     * // Count the number of ChatbotSessionAnalytics
     * const count = await prisma.chatbotSessionAnalytics.count({
     *   where: {
     *     // ... the filter for the ChatbotSessionAnalytics we want to count
     *   }
     * })
    **/
    count<T extends ChatbotSessionAnalyticsCountArgs>(
      args?: Subset<T, ChatbotSessionAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotSessionAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatbotSessionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotSessionAnalyticsAggregateArgs>(args: Subset<T, ChatbotSessionAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetChatbotSessionAnalyticsAggregateType<T>>

    /**
     * Group by ChatbotSessionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotSessionAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotSessionAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotSessionAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotSessionAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotSessionAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotSessionAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatbotSessionAnalytics model
   */
  readonly fields: ChatbotSessionAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatbotSessionAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotSessionAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatbotSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotSessionDefaultArgs<ExtArgs>>): Prisma__ChatbotSessionClient<$Result.GetResult<Prisma.$ChatbotSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatbotSessionAnalytics model
   */
  interface ChatbotSessionAnalyticsFieldRefs {
    readonly id: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly sessionId: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly messageCount: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly userMessageCount: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly aiMessageCount: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly averageUserMessageLength: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly averageAiResponseLength: FieldRef<"ChatbotSessionAnalytics", 'Int'>
    readonly topicsDiscussed: FieldRef<"ChatbotSessionAnalytics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChatbotSessionAnalytics findUnique
   */
  export type ChatbotSessionAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSessionAnalytics to fetch.
     */
    where: ChatbotSessionAnalyticsWhereUniqueInput
  }

  /**
   * ChatbotSessionAnalytics findUniqueOrThrow
   */
  export type ChatbotSessionAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSessionAnalytics to fetch.
     */
    where: ChatbotSessionAnalyticsWhereUniqueInput
  }

  /**
   * ChatbotSessionAnalytics findFirst
   */
  export type ChatbotSessionAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSessionAnalytics to fetch.
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessionAnalytics to fetch.
     */
    orderBy?: ChatbotSessionAnalyticsOrderByWithRelationInput | ChatbotSessionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotSessionAnalytics.
     */
    cursor?: ChatbotSessionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessionAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotSessionAnalytics.
     */
    distinct?: ChatbotSessionAnalyticsScalarFieldEnum | ChatbotSessionAnalyticsScalarFieldEnum[]
  }

  /**
   * ChatbotSessionAnalytics findFirstOrThrow
   */
  export type ChatbotSessionAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSessionAnalytics to fetch.
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessionAnalytics to fetch.
     */
    orderBy?: ChatbotSessionAnalyticsOrderByWithRelationInput | ChatbotSessionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotSessionAnalytics.
     */
    cursor?: ChatbotSessionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessionAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotSessionAnalytics.
     */
    distinct?: ChatbotSessionAnalyticsScalarFieldEnum | ChatbotSessionAnalyticsScalarFieldEnum[]
  }

  /**
   * ChatbotSessionAnalytics findMany
   */
  export type ChatbotSessionAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotSessionAnalytics to fetch.
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotSessionAnalytics to fetch.
     */
    orderBy?: ChatbotSessionAnalyticsOrderByWithRelationInput | ChatbotSessionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatbotSessionAnalytics.
     */
    cursor?: ChatbotSessionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotSessionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotSessionAnalytics.
     */
    skip?: number
    distinct?: ChatbotSessionAnalyticsScalarFieldEnum | ChatbotSessionAnalyticsScalarFieldEnum[]
  }

  /**
   * ChatbotSessionAnalytics create
   */
  export type ChatbotSessionAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatbotSessionAnalytics.
     */
    data: XOR<ChatbotSessionAnalyticsCreateInput, ChatbotSessionAnalyticsUncheckedCreateInput>
  }

  /**
   * ChatbotSessionAnalytics createMany
   */
  export type ChatbotSessionAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatbotSessionAnalytics.
     */
    data: ChatbotSessionAnalyticsCreateManyInput | ChatbotSessionAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatbotSessionAnalytics createManyAndReturn
   */
  export type ChatbotSessionAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many ChatbotSessionAnalytics.
     */
    data: ChatbotSessionAnalyticsCreateManyInput | ChatbotSessionAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotSessionAnalytics update
   */
  export type ChatbotSessionAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatbotSessionAnalytics.
     */
    data: XOR<ChatbotSessionAnalyticsUpdateInput, ChatbotSessionAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which ChatbotSessionAnalytics to update.
     */
    where: ChatbotSessionAnalyticsWhereUniqueInput
  }

  /**
   * ChatbotSessionAnalytics updateMany
   */
  export type ChatbotSessionAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatbotSessionAnalytics.
     */
    data: XOR<ChatbotSessionAnalyticsUpdateManyMutationInput, ChatbotSessionAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotSessionAnalytics to update
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * Limit how many ChatbotSessionAnalytics to update.
     */
    limit?: number
  }

  /**
   * ChatbotSessionAnalytics updateManyAndReturn
   */
  export type ChatbotSessionAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update ChatbotSessionAnalytics.
     */
    data: XOR<ChatbotSessionAnalyticsUpdateManyMutationInput, ChatbotSessionAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotSessionAnalytics to update
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * Limit how many ChatbotSessionAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotSessionAnalytics upsert
   */
  export type ChatbotSessionAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatbotSessionAnalytics to update in case it exists.
     */
    where: ChatbotSessionAnalyticsWhereUniqueInput
    /**
     * In case the ChatbotSessionAnalytics found by the `where` argument doesn't exist, create a new ChatbotSessionAnalytics with this data.
     */
    create: XOR<ChatbotSessionAnalyticsCreateInput, ChatbotSessionAnalyticsUncheckedCreateInput>
    /**
     * In case the ChatbotSessionAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotSessionAnalyticsUpdateInput, ChatbotSessionAnalyticsUncheckedUpdateInput>
  }

  /**
   * ChatbotSessionAnalytics delete
   */
  export type ChatbotSessionAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which ChatbotSessionAnalytics to delete.
     */
    where: ChatbotSessionAnalyticsWhereUniqueInput
  }

  /**
   * ChatbotSessionAnalytics deleteMany
   */
  export type ChatbotSessionAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotSessionAnalytics to delete
     */
    where?: ChatbotSessionAnalyticsWhereInput
    /**
     * Limit how many ChatbotSessionAnalytics to delete.
     */
    limit?: number
  }

  /**
   * ChatbotSessionAnalytics without action
   */
  export type ChatbotSessionAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotSessionAnalytics
     */
    select?: ChatbotSessionAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotSessionAnalytics
     */
    omit?: ChatbotSessionAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotSessionAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SavedAnswer
   */

  export type AggregateSavedAnswer = {
    _count: SavedAnswerCountAggregateOutputType | null
    _avg: SavedAnswerAvgAggregateOutputType | null
    _sum: SavedAnswerSumAggregateOutputType | null
    _min: SavedAnswerMinAggregateOutputType | null
    _max: SavedAnswerMaxAggregateOutputType | null
  }

  export type SavedAnswerAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type SavedAnswerSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type SavedAnswerMinAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isPublic: boolean | null
    userId: number | null
    courseId: number | null
  }

  export type SavedAnswerMaxAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isPublic: boolean | null
    userId: number | null
    courseId: number | null
  }

  export type SavedAnswerCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    createdAt: number
    updatedAt: number
    isPublic: number
    userId: number
    courseId: number
    _all: number
  }


  export type SavedAnswerAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type SavedAnswerSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type SavedAnswerMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    isPublic?: true
    userId?: true
    courseId?: true
  }

  export type SavedAnswerMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    isPublic?: true
    userId?: true
    courseId?: true
  }

  export type SavedAnswerCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    isPublic?: true
    userId?: true
    courseId?: true
    _all?: true
  }

  export type SavedAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedAnswer to aggregate.
     */
    where?: SavedAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedAnswers to fetch.
     */
    orderBy?: SavedAnswerOrderByWithRelationInput | SavedAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedAnswers
    **/
    _count?: true | SavedAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedAnswerMaxAggregateInputType
  }

  export type GetSavedAnswerAggregateType<T extends SavedAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedAnswer[P]>
      : GetScalarType<T[P], AggregateSavedAnswer[P]>
  }




  export type SavedAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedAnswerWhereInput
    orderBy?: SavedAnswerOrderByWithAggregationInput | SavedAnswerOrderByWithAggregationInput[]
    by: SavedAnswerScalarFieldEnum[] | SavedAnswerScalarFieldEnum
    having?: SavedAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedAnswerCountAggregateInputType | true
    _avg?: SavedAnswerAvgAggregateInputType
    _sum?: SavedAnswerSumAggregateInputType
    _min?: SavedAnswerMinAggregateInputType
    _max?: SavedAnswerMaxAggregateInputType
  }

  export type SavedAnswerGroupByOutputType = {
    id: number
    question: string
    answer: string
    category: string | null
    createdAt: Date
    updatedAt: Date
    isPublic: boolean
    userId: number | null
    courseId: number | null
    _count: SavedAnswerCountAggregateOutputType | null
    _avg: SavedAnswerAvgAggregateOutputType | null
    _sum: SavedAnswerSumAggregateOutputType | null
    _min: SavedAnswerMinAggregateOutputType | null
    _max: SavedAnswerMaxAggregateOutputType | null
  }

  type GetSavedAnswerGroupByPayload<T extends SavedAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], SavedAnswerGroupByOutputType[P]>
        }
      >
    >


  export type SavedAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublic?: boolean
    userId?: boolean
    courseId?: boolean
    user?: boolean | SavedAnswer$userArgs<ExtArgs>
    course?: boolean | SavedAnswer$courseArgs<ExtArgs>
  }, ExtArgs["result"]["savedAnswer"]>

  export type SavedAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublic?: boolean
    userId?: boolean
    courseId?: boolean
    user?: boolean | SavedAnswer$userArgs<ExtArgs>
    course?: boolean | SavedAnswer$courseArgs<ExtArgs>
  }, ExtArgs["result"]["savedAnswer"]>

  export type SavedAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublic?: boolean
    userId?: boolean
    courseId?: boolean
    user?: boolean | SavedAnswer$userArgs<ExtArgs>
    course?: boolean | SavedAnswer$courseArgs<ExtArgs>
  }, ExtArgs["result"]["savedAnswer"]>

  export type SavedAnswerSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublic?: boolean
    userId?: boolean
    courseId?: boolean
  }

  export type SavedAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "category" | "createdAt" | "updatedAt" | "isPublic" | "userId" | "courseId", ExtArgs["result"]["savedAnswer"]>
  export type SavedAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SavedAnswer$userArgs<ExtArgs>
    course?: boolean | SavedAnswer$courseArgs<ExtArgs>
  }
  export type SavedAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SavedAnswer$userArgs<ExtArgs>
    course?: boolean | SavedAnswer$courseArgs<ExtArgs>
  }
  export type SavedAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SavedAnswer$userArgs<ExtArgs>
    course?: boolean | SavedAnswer$courseArgs<ExtArgs>
  }

  export type $SavedAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedAnswer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      answer: string
      category: string | null
      createdAt: Date
      updatedAt: Date
      isPublic: boolean
      userId: number | null
      courseId: number | null
    }, ExtArgs["result"]["savedAnswer"]>
    composites: {}
  }

  type SavedAnswerGetPayload<S extends boolean | null | undefined | SavedAnswerDefaultArgs> = $Result.GetResult<Prisma.$SavedAnswerPayload, S>

  type SavedAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedAnswerCountAggregateInputType | true
    }

  export interface SavedAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedAnswer'], meta: { name: 'SavedAnswer' } }
    /**
     * Find zero or one SavedAnswer that matches the filter.
     * @param {SavedAnswerFindUniqueArgs} args - Arguments to find a SavedAnswer
     * @example
     * // Get one SavedAnswer
     * const savedAnswer = await prisma.savedAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedAnswerFindUniqueArgs>(args: SelectSubset<T, SavedAnswerFindUniqueArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedAnswerFindUniqueOrThrowArgs} args - Arguments to find a SavedAnswer
     * @example
     * // Get one SavedAnswer
     * const savedAnswer = await prisma.savedAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerFindFirstArgs} args - Arguments to find a SavedAnswer
     * @example
     * // Get one SavedAnswer
     * const savedAnswer = await prisma.savedAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedAnswerFindFirstArgs>(args?: SelectSubset<T, SavedAnswerFindFirstArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerFindFirstOrThrowArgs} args - Arguments to find a SavedAnswer
     * @example
     * // Get one SavedAnswer
     * const savedAnswer = await prisma.savedAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedAnswers
     * const savedAnswers = await prisma.savedAnswer.findMany()
     * 
     * // Get first 10 SavedAnswers
     * const savedAnswers = await prisma.savedAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedAnswerWithIdOnly = await prisma.savedAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedAnswerFindManyArgs>(args?: SelectSubset<T, SavedAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedAnswer.
     * @param {SavedAnswerCreateArgs} args - Arguments to create a SavedAnswer.
     * @example
     * // Create one SavedAnswer
     * const SavedAnswer = await prisma.savedAnswer.create({
     *   data: {
     *     // ... data to create a SavedAnswer
     *   }
     * })
     * 
     */
    create<T extends SavedAnswerCreateArgs>(args: SelectSubset<T, SavedAnswerCreateArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedAnswers.
     * @param {SavedAnswerCreateManyArgs} args - Arguments to create many SavedAnswers.
     * @example
     * // Create many SavedAnswers
     * const savedAnswer = await prisma.savedAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedAnswerCreateManyArgs>(args?: SelectSubset<T, SavedAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedAnswers and returns the data saved in the database.
     * @param {SavedAnswerCreateManyAndReturnArgs} args - Arguments to create many SavedAnswers.
     * @example
     * // Create many SavedAnswers
     * const savedAnswer = await prisma.savedAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedAnswers and only return the `id`
     * const savedAnswerWithIdOnly = await prisma.savedAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedAnswer.
     * @param {SavedAnswerDeleteArgs} args - Arguments to delete one SavedAnswer.
     * @example
     * // Delete one SavedAnswer
     * const SavedAnswer = await prisma.savedAnswer.delete({
     *   where: {
     *     // ... filter to delete one SavedAnswer
     *   }
     * })
     * 
     */
    delete<T extends SavedAnswerDeleteArgs>(args: SelectSubset<T, SavedAnswerDeleteArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedAnswer.
     * @param {SavedAnswerUpdateArgs} args - Arguments to update one SavedAnswer.
     * @example
     * // Update one SavedAnswer
     * const savedAnswer = await prisma.savedAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedAnswerUpdateArgs>(args: SelectSubset<T, SavedAnswerUpdateArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedAnswers.
     * @param {SavedAnswerDeleteManyArgs} args - Arguments to filter SavedAnswers to delete.
     * @example
     * // Delete a few SavedAnswers
     * const { count } = await prisma.savedAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedAnswerDeleteManyArgs>(args?: SelectSubset<T, SavedAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedAnswers
     * const savedAnswer = await prisma.savedAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedAnswerUpdateManyArgs>(args: SelectSubset<T, SavedAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedAnswers and returns the data updated in the database.
     * @param {SavedAnswerUpdateManyAndReturnArgs} args - Arguments to update many SavedAnswers.
     * @example
     * // Update many SavedAnswers
     * const savedAnswer = await prisma.savedAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedAnswers and only return the `id`
     * const savedAnswerWithIdOnly = await prisma.savedAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedAnswer.
     * @param {SavedAnswerUpsertArgs} args - Arguments to update or create a SavedAnswer.
     * @example
     * // Update or create a SavedAnswer
     * const savedAnswer = await prisma.savedAnswer.upsert({
     *   create: {
     *     // ... data to create a SavedAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedAnswer we want to update
     *   }
     * })
     */
    upsert<T extends SavedAnswerUpsertArgs>(args: SelectSubset<T, SavedAnswerUpsertArgs<ExtArgs>>): Prisma__SavedAnswerClient<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerCountArgs} args - Arguments to filter SavedAnswers to count.
     * @example
     * // Count the number of SavedAnswers
     * const count = await prisma.savedAnswer.count({
     *   where: {
     *     // ... the filter for the SavedAnswers we want to count
     *   }
     * })
    **/
    count<T extends SavedAnswerCountArgs>(
      args?: Subset<T, SavedAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedAnswerAggregateArgs>(args: Subset<T, SavedAnswerAggregateArgs>): Prisma.PrismaPromise<GetSavedAnswerAggregateType<T>>

    /**
     * Group by SavedAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedAnswerGroupByArgs['orderBy'] }
        : { orderBy?: SavedAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedAnswer model
   */
  readonly fields: SavedAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SavedAnswer$userArgs<ExtArgs> = {}>(args?: Subset<T, SavedAnswer$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    course<T extends SavedAnswer$courseArgs<ExtArgs> = {}>(args?: Subset<T, SavedAnswer$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedAnswer model
   */
  interface SavedAnswerFieldRefs {
    readonly id: FieldRef<"SavedAnswer", 'Int'>
    readonly question: FieldRef<"SavedAnswer", 'String'>
    readonly answer: FieldRef<"SavedAnswer", 'String'>
    readonly category: FieldRef<"SavedAnswer", 'String'>
    readonly createdAt: FieldRef<"SavedAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedAnswer", 'DateTime'>
    readonly isPublic: FieldRef<"SavedAnswer", 'Boolean'>
    readonly userId: FieldRef<"SavedAnswer", 'Int'>
    readonly courseId: FieldRef<"SavedAnswer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SavedAnswer findUnique
   */
  export type SavedAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SavedAnswer to fetch.
     */
    where: SavedAnswerWhereUniqueInput
  }

  /**
   * SavedAnswer findUniqueOrThrow
   */
  export type SavedAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SavedAnswer to fetch.
     */
    where: SavedAnswerWhereUniqueInput
  }

  /**
   * SavedAnswer findFirst
   */
  export type SavedAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SavedAnswer to fetch.
     */
    where?: SavedAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedAnswers to fetch.
     */
    orderBy?: SavedAnswerOrderByWithRelationInput | SavedAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedAnswers.
     */
    cursor?: SavedAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedAnswers.
     */
    distinct?: SavedAnswerScalarFieldEnum | SavedAnswerScalarFieldEnum[]
  }

  /**
   * SavedAnswer findFirstOrThrow
   */
  export type SavedAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SavedAnswer to fetch.
     */
    where?: SavedAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedAnswers to fetch.
     */
    orderBy?: SavedAnswerOrderByWithRelationInput | SavedAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedAnswers.
     */
    cursor?: SavedAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedAnswers.
     */
    distinct?: SavedAnswerScalarFieldEnum | SavedAnswerScalarFieldEnum[]
  }

  /**
   * SavedAnswer findMany
   */
  export type SavedAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SavedAnswers to fetch.
     */
    where?: SavedAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedAnswers to fetch.
     */
    orderBy?: SavedAnswerOrderByWithRelationInput | SavedAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedAnswers.
     */
    cursor?: SavedAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedAnswers.
     */
    skip?: number
    distinct?: SavedAnswerScalarFieldEnum | SavedAnswerScalarFieldEnum[]
  }

  /**
   * SavedAnswer create
   */
  export type SavedAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedAnswer.
     */
    data: XOR<SavedAnswerCreateInput, SavedAnswerUncheckedCreateInput>
  }

  /**
   * SavedAnswer createMany
   */
  export type SavedAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedAnswers.
     */
    data: SavedAnswerCreateManyInput | SavedAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedAnswer createManyAndReturn
   */
  export type SavedAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many SavedAnswers.
     */
    data: SavedAnswerCreateManyInput | SavedAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedAnswer update
   */
  export type SavedAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedAnswer.
     */
    data: XOR<SavedAnswerUpdateInput, SavedAnswerUncheckedUpdateInput>
    /**
     * Choose, which SavedAnswer to update.
     */
    where: SavedAnswerWhereUniqueInput
  }

  /**
   * SavedAnswer updateMany
   */
  export type SavedAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedAnswers.
     */
    data: XOR<SavedAnswerUpdateManyMutationInput, SavedAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SavedAnswers to update
     */
    where?: SavedAnswerWhereInput
    /**
     * Limit how many SavedAnswers to update.
     */
    limit?: number
  }

  /**
   * SavedAnswer updateManyAndReturn
   */
  export type SavedAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * The data used to update SavedAnswers.
     */
    data: XOR<SavedAnswerUpdateManyMutationInput, SavedAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SavedAnswers to update
     */
    where?: SavedAnswerWhereInput
    /**
     * Limit how many SavedAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedAnswer upsert
   */
  export type SavedAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedAnswer to update in case it exists.
     */
    where: SavedAnswerWhereUniqueInput
    /**
     * In case the SavedAnswer found by the `where` argument doesn't exist, create a new SavedAnswer with this data.
     */
    create: XOR<SavedAnswerCreateInput, SavedAnswerUncheckedCreateInput>
    /**
     * In case the SavedAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedAnswerUpdateInput, SavedAnswerUncheckedUpdateInput>
  }

  /**
   * SavedAnswer delete
   */
  export type SavedAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    /**
     * Filter which SavedAnswer to delete.
     */
    where: SavedAnswerWhereUniqueInput
  }

  /**
   * SavedAnswer deleteMany
   */
  export type SavedAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedAnswers to delete
     */
    where?: SavedAnswerWhereInput
    /**
     * Limit how many SavedAnswers to delete.
     */
    limit?: number
  }

  /**
   * SavedAnswer.user
   */
  export type SavedAnswer$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SavedAnswer.course
   */
  export type SavedAnswer$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * SavedAnswer without action
   */
  export type SavedAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    id: number | null
  }

  export type SkillSumAggregateOutputType = {
    id: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    description: string | null
    icon: string | null
  }

  export type SkillMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    description: string | null
    icon: string | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    icon: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    id?: true
  }

  export type SkillSumAggregateInputType = {
    id?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    icon?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    icon?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    icon?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: number
    name: string
    category: string
    description: string | null
    icon: string | null
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    icon?: boolean
    userSkills?: boolean | Skill$userSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    icon?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    icon?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    icon?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "description" | "icon", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | Skill$userSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      userSkills: Prisma.$UserSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      description: string | null
      icon: string | null
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userSkills<T extends Skill$userSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$userSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'Int'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly icon: FieldRef<"Skill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.userSkills
   */
  export type Skill$userSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    where?: UserSkillWhereInput
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    cursor?: UserSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model UserSkill
   */

  export type AggregateUserSkill = {
    _count: UserSkillCountAggregateOutputType | null
    _avg: UserSkillAvgAggregateOutputType | null
    _sum: UserSkillSumAggregateOutputType | null
    _min: UserSkillMinAggregateOutputType | null
    _max: UserSkillMaxAggregateOutputType | null
  }

  export type UserSkillAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    skillId: number | null
    proficiencyLevel: number | null
  }

  export type UserSkillSumAggregateOutputType = {
    id: number | null
    userId: number | null
    skillId: number | null
    proficiencyLevel: number | null
  }

  export type UserSkillMinAggregateOutputType = {
    id: number | null
    userId: number | null
    skillId: number | null
    proficiencyLevel: number | null
    acquiredDate: Date | null
  }

  export type UserSkillMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    skillId: number | null
    proficiencyLevel: number | null
    acquiredDate: Date | null
  }

  export type UserSkillCountAggregateOutputType = {
    id: number
    userId: number
    skillId: number
    proficiencyLevel: number
    acquiredDate: number
    _all: number
  }


  export type UserSkillAvgAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    proficiencyLevel?: true
  }

  export type UserSkillSumAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    proficiencyLevel?: true
  }

  export type UserSkillMinAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    proficiencyLevel?: true
    acquiredDate?: true
  }

  export type UserSkillMaxAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    proficiencyLevel?: true
    acquiredDate?: true
  }

  export type UserSkillCountAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    proficiencyLevel?: true
    acquiredDate?: true
    _all?: true
  }

  export type UserSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkill to aggregate.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkills
    **/
    _count?: true | UserSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillMaxAggregateInputType
  }

  export type GetUserSkillAggregateType<T extends UserSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkill[P]>
      : GetScalarType<T[P], AggregateUserSkill[P]>
  }




  export type UserSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillWhereInput
    orderBy?: UserSkillOrderByWithAggregationInput | UserSkillOrderByWithAggregationInput[]
    by: UserSkillScalarFieldEnum[] | UserSkillScalarFieldEnum
    having?: UserSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillCountAggregateInputType | true
    _avg?: UserSkillAvgAggregateInputType
    _sum?: UserSkillSumAggregateInputType
    _min?: UserSkillMinAggregateInputType
    _max?: UserSkillMaxAggregateInputType
  }

  export type UserSkillGroupByOutputType = {
    id: number
    userId: number
    skillId: number
    proficiencyLevel: number
    acquiredDate: Date | null
    _count: UserSkillCountAggregateOutputType | null
    _avg: UserSkillAvgAggregateOutputType | null
    _sum: UserSkillSumAggregateOutputType | null
    _min: UserSkillMinAggregateOutputType | null
    _max: UserSkillMaxAggregateOutputType | null
  }

  type GetUserSkillGroupByPayload<T extends UserSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillGroupByOutputType[P]>
        }
      >
    >


  export type UserSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    acquiredDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type UserSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    acquiredDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type UserSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    acquiredDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type UserSkillSelectScalar = {
    id?: boolean
    userId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    acquiredDate?: boolean
  }

  export type UserSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "skillId" | "proficiencyLevel" | "acquiredDate", ExtArgs["result"]["userSkill"]>
  export type UserSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $UserSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      skillId: number
      proficiencyLevel: number
      acquiredDate: Date | null
    }, ExtArgs["result"]["userSkill"]>
    composites: {}
  }

  type UserSkillGetPayload<S extends boolean | null | undefined | UserSkillDefaultArgs> = $Result.GetResult<Prisma.$UserSkillPayload, S>

  type UserSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSkillCountAggregateInputType | true
    }

  export interface UserSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkill'], meta: { name: 'UserSkill' } }
    /**
     * Find zero or one UserSkill that matches the filter.
     * @param {UserSkillFindUniqueArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkillFindUniqueArgs>(args: SelectSubset<T, UserSkillFindUniqueArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSkillFindUniqueOrThrowArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillFindFirstArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkillFindFirstArgs>(args?: SelectSubset<T, UserSkillFindFirstArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillFindFirstOrThrowArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkills
     * const userSkills = await prisma.userSkill.findMany()
     * 
     * // Get first 10 UserSkills
     * const userSkills = await prisma.userSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSkillWithIdOnly = await prisma.userSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSkillFindManyArgs>(args?: SelectSubset<T, UserSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSkill.
     * @param {UserSkillCreateArgs} args - Arguments to create a UserSkill.
     * @example
     * // Create one UserSkill
     * const UserSkill = await prisma.userSkill.create({
     *   data: {
     *     // ... data to create a UserSkill
     *   }
     * })
     * 
     */
    create<T extends UserSkillCreateArgs>(args: SelectSubset<T, UserSkillCreateArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSkills.
     * @param {UserSkillCreateManyArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkill = await prisma.userSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkillCreateManyArgs>(args?: SelectSubset<T, UserSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSkills and returns the data saved in the database.
     * @param {UserSkillCreateManyAndReturnArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkill = await prisma.userSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSkills and only return the `id`
     * const userSkillWithIdOnly = await prisma.userSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSkill.
     * @param {UserSkillDeleteArgs} args - Arguments to delete one UserSkill.
     * @example
     * // Delete one UserSkill
     * const UserSkill = await prisma.userSkill.delete({
     *   where: {
     *     // ... filter to delete one UserSkill
     *   }
     * })
     * 
     */
    delete<T extends UserSkillDeleteArgs>(args: SelectSubset<T, UserSkillDeleteArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSkill.
     * @param {UserSkillUpdateArgs} args - Arguments to update one UserSkill.
     * @example
     * // Update one UserSkill
     * const userSkill = await prisma.userSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkillUpdateArgs>(args: SelectSubset<T, UserSkillUpdateArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSkills.
     * @param {UserSkillDeleteManyArgs} args - Arguments to filter UserSkills to delete.
     * @example
     * // Delete a few UserSkills
     * const { count } = await prisma.userSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkillDeleteManyArgs>(args?: SelectSubset<T, UserSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkills
     * const userSkill = await prisma.userSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkillUpdateManyArgs>(args: SelectSubset<T, UserSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills and returns the data updated in the database.
     * @param {UserSkillUpdateManyAndReturnArgs} args - Arguments to update many UserSkills.
     * @example
     * // Update many UserSkills
     * const userSkill = await prisma.userSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSkills and only return the `id`
     * const userSkillWithIdOnly = await prisma.userSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSkill.
     * @param {UserSkillUpsertArgs} args - Arguments to update or create a UserSkill.
     * @example
     * // Update or create a UserSkill
     * const userSkill = await prisma.userSkill.upsert({
     *   create: {
     *     // ... data to create a UserSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkill we want to update
     *   }
     * })
     */
    upsert<T extends UserSkillUpsertArgs>(args: SelectSubset<T, UserSkillUpsertArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillCountArgs} args - Arguments to filter UserSkills to count.
     * @example
     * // Count the number of UserSkills
     * const count = await prisma.userSkill.count({
     *   where: {
     *     // ... the filter for the UserSkills we want to count
     *   }
     * })
    **/
    count<T extends UserSkillCountArgs>(
      args?: Subset<T, UserSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillAggregateArgs>(args: Subset<T, UserSkillAggregateArgs>): Prisma.PrismaPromise<GetUserSkillAggregateType<T>>

    /**
     * Group by UserSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkillGroupByArgs['orderBy'] }
        : { orderBy?: UserSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkill model
   */
  readonly fields: UserSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkill model
   */
  interface UserSkillFieldRefs {
    readonly id: FieldRef<"UserSkill", 'Int'>
    readonly userId: FieldRef<"UserSkill", 'Int'>
    readonly skillId: FieldRef<"UserSkill", 'Int'>
    readonly proficiencyLevel: FieldRef<"UserSkill", 'Int'>
    readonly acquiredDate: FieldRef<"UserSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSkill findUnique
   */
  export type UserSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill findUniqueOrThrow
   */
  export type UserSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill findFirst
   */
  export type UserSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * UserSkill findFirstOrThrow
   */
  export type UserSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * UserSkill findMany
   */
  export type UserSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkills.
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * UserSkill create
   */
  export type UserSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkill.
     */
    data: XOR<UserSkillCreateInput, UserSkillUncheckedCreateInput>
  }

  /**
   * UserSkill createMany
   */
  export type UserSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillCreateManyInput | UserSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSkill createManyAndReturn
   */
  export type UserSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillCreateManyInput | UserSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkill update
   */
  export type UserSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkill.
     */
    data: XOR<UserSkillUpdateInput, UserSkillUncheckedUpdateInput>
    /**
     * Choose, which UserSkill to update.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill updateMany
   */
  export type UserSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkills.
     */
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyInput>
    /**
     * Filter which UserSkills to update
     */
    where?: UserSkillWhereInput
    /**
     * Limit how many UserSkills to update.
     */
    limit?: number
  }

  /**
   * UserSkill updateManyAndReturn
   */
  export type UserSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * The data used to update UserSkills.
     */
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyInput>
    /**
     * Filter which UserSkills to update
     */
    where?: UserSkillWhereInput
    /**
     * Limit how many UserSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkill upsert
   */
  export type UserSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkill to update in case it exists.
     */
    where: UserSkillWhereUniqueInput
    /**
     * In case the UserSkill found by the `where` argument doesn't exist, create a new UserSkill with this data.
     */
    create: XOR<UserSkillCreateInput, UserSkillUncheckedCreateInput>
    /**
     * In case the UserSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkillUpdateInput, UserSkillUncheckedUpdateInput>
  }

  /**
   * UserSkill delete
   */
  export type UserSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter which UserSkill to delete.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill deleteMany
   */
  export type UserSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkills to delete
     */
    where?: UserSkillWhereInput
    /**
     * Limit how many UserSkills to delete.
     */
    limit?: number
  }

  /**
   * UserSkill without action
   */
  export type UserSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkill
     */
    omit?: UserSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    instructorId: number | null
    durationHours: number | null
    enrollmentLimit: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    instructorId: number | null
    durationHours: number | null
    enrollmentLimit: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    description: string | null
    overview: string | null
    thumbnail: string | null
    coverImage: string | null
    type: $Enums.CourseType | null
    difficulty: $Enums.DifficultyLevel | null
    instructorId: number | null
    durationHours: number | null
    isFeatured: boolean | null
    isPublished: boolean | null
    startDate: Date | null
    endDate: Date | null
    enrollmentLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    description: string | null
    overview: string | null
    thumbnail: string | null
    coverImage: string | null
    type: $Enums.CourseType | null
    difficulty: $Enums.DifficultyLevel | null
    instructorId: number | null
    durationHours: number | null
    isFeatured: boolean | null
    isPublished: boolean | null
    startDate: Date | null
    endDate: Date | null
    enrollmentLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    overview: number
    thumbnail: number
    coverImage: number
    type: number
    difficulty: number
    instructorId: number
    durationHours: number
    isFeatured: number
    isPublished: number
    startDate: number
    endDate: number
    enrollmentLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    instructorId?: true
    durationHours?: true
    enrollmentLimit?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    instructorId?: true
    durationHours?: true
    enrollmentLimit?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    overview?: true
    thumbnail?: true
    coverImage?: true
    type?: true
    difficulty?: true
    instructorId?: true
    durationHours?: true
    isFeatured?: true
    isPublished?: true
    startDate?: true
    endDate?: true
    enrollmentLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    overview?: true
    thumbnail?: true
    coverImage?: true
    type?: true
    difficulty?: true
    instructorId?: true
    durationHours?: true
    isFeatured?: true
    isPublished?: true
    startDate?: true
    endDate?: true
    enrollmentLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    overview?: true
    thumbnail?: true
    coverImage?: true
    type?: true
    difficulty?: true
    instructorId?: true
    durationHours?: true
    isFeatured?: true
    isPublished?: true
    startDate?: true
    endDate?: true
    enrollmentLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    title: string
    slug: string
    description: string
    overview: string | null
    thumbnail: string | null
    coverImage: string | null
    type: $Enums.CourseType
    difficulty: $Enums.DifficultyLevel | null
    instructorId: number | null
    durationHours: number | null
    isFeatured: boolean
    isPublished: boolean
    startDate: Date | null
    endDate: Date | null
    enrollmentLimit: number | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    overview?: boolean
    thumbnail?: boolean
    coverImage?: boolean
    type?: boolean
    difficulty?: boolean
    instructorId?: boolean
    durationHours?: boolean
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instructor?: boolean | Course$instructorArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    learningOutcomes?: boolean | Course$learningOutcomesArgs<ExtArgs>
    requirements?: boolean | Course$requirementsArgs<ExtArgs>
    assessments?: boolean | Course$assessmentsArgs<ExtArgs>
    flashcards?: boolean | Course$flashcardsArgs<ExtArgs>
    chatbotMessages?: boolean | Course$chatbotMessagesArgs<ExtArgs>
    savedAnswers?: boolean | Course$savedAnswersArgs<ExtArgs>
    tags?: boolean | Course$tagsArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    overview?: boolean
    thumbnail?: boolean
    coverImage?: boolean
    type?: boolean
    difficulty?: boolean
    instructorId?: boolean
    durationHours?: boolean
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instructor?: boolean | Course$instructorArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    overview?: boolean
    thumbnail?: boolean
    coverImage?: boolean
    type?: boolean
    difficulty?: boolean
    instructorId?: boolean
    durationHours?: boolean
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instructor?: boolean | Course$instructorArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    overview?: boolean
    thumbnail?: boolean
    coverImage?: boolean
    type?: boolean
    difficulty?: boolean
    instructorId?: boolean
    durationHours?: boolean
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "overview" | "thumbnail" | "coverImage" | "type" | "difficulty" | "instructorId" | "durationHours" | "isFeatured" | "isPublished" | "startDate" | "endDate" | "enrollmentLimit" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | Course$instructorArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    learningOutcomes?: boolean | Course$learningOutcomesArgs<ExtArgs>
    requirements?: boolean | Course$requirementsArgs<ExtArgs>
    assessments?: boolean | Course$assessmentsArgs<ExtArgs>
    flashcards?: boolean | Course$flashcardsArgs<ExtArgs>
    chatbotMessages?: boolean | Course$chatbotMessagesArgs<ExtArgs>
    savedAnswers?: boolean | Course$savedAnswersArgs<ExtArgs>
    tags?: boolean | Course$tagsArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | Course$instructorArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | Course$instructorArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      instructor: Prisma.$UserPayload<ExtArgs> | null
      modules: Prisma.$CourseModulePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      learningOutcomes: Prisma.$LearningOutcomePayload<ExtArgs>[]
      requirements: Prisma.$CourseRequirementPayload<ExtArgs>[]
      assessments: Prisma.$AssessmentPayload<ExtArgs>[]
      flashcards: Prisma.$FlashcardPayload<ExtArgs>[]
      chatbotMessages: Prisma.$ChatbotMessagePayload<ExtArgs>[]
      savedAnswers: Prisma.$SavedAnswerPayload<ExtArgs>[]
      tags: Prisma.$CourseTagsPayload<ExtArgs>[]
      reviews: Prisma.$CourseReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      description: string
      overview: string | null
      thumbnail: string | null
      coverImage: string | null
      type: $Enums.CourseType
      difficulty: $Enums.DifficultyLevel | null
      instructorId: number | null
      durationHours: number | null
      isFeatured: boolean
      isPublished: boolean
      startDate: Date | null
      endDate: Date | null
      enrollmentLimit: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructor<T extends Course$instructorArgs<ExtArgs> = {}>(args?: Subset<T, Course$instructorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningOutcomes<T extends Course$learningOutcomesArgs<ExtArgs> = {}>(args?: Subset<T, Course$learningOutcomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirements<T extends Course$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Course$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assessments<T extends Course$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flashcards<T extends Course$flashcardsArgs<ExtArgs> = {}>(args?: Subset<T, Course$flashcardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatbotMessages<T extends Course$chatbotMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Course$chatbotMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedAnswers<T extends Course$savedAnswersArgs<ExtArgs> = {}>(args?: Subset<T, Course$savedAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Course$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Course$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Course$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Course$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly title: FieldRef<"Course", 'String'>
    readonly slug: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly overview: FieldRef<"Course", 'String'>
    readonly thumbnail: FieldRef<"Course", 'String'>
    readonly coverImage: FieldRef<"Course", 'String'>
    readonly type: FieldRef<"Course", 'CourseType'>
    readonly difficulty: FieldRef<"Course", 'DifficultyLevel'>
    readonly instructorId: FieldRef<"Course", 'Int'>
    readonly durationHours: FieldRef<"Course", 'Int'>
    readonly isFeatured: FieldRef<"Course", 'Boolean'>
    readonly isPublished: FieldRef<"Course", 'Boolean'>
    readonly startDate: FieldRef<"Course", 'DateTime'>
    readonly endDate: FieldRef<"Course", 'DateTime'>
    readonly enrollmentLimit: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.instructor
   */
  export type Course$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    cursor?: CourseModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.learningOutcomes
   */
  export type Course$learningOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    where?: LearningOutcomeWhereInput
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    cursor?: LearningOutcomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * Course.requirements
   */
  export type Course$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    where?: CourseRequirementWhereInput
    orderBy?: CourseRequirementOrderByWithRelationInput | CourseRequirementOrderByWithRelationInput[]
    cursor?: CourseRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseRequirementScalarFieldEnum | CourseRequirementScalarFieldEnum[]
  }

  /**
   * Course.assessments
   */
  export type Course$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    cursor?: AssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Course.flashcards
   */
  export type Course$flashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    where?: FlashcardWhereInput
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    cursor?: FlashcardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Course.chatbotMessages
   */
  export type Course$chatbotMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    where?: ChatbotMessageWhereInput
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    cursor?: ChatbotMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * Course.savedAnswers
   */
  export type Course$savedAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedAnswer
     */
    select?: SavedAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedAnswer
     */
    omit?: SavedAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedAnswerInclude<ExtArgs> | null
    where?: SavedAnswerWhereInput
    orderBy?: SavedAnswerOrderByWithRelationInput | SavedAnswerOrderByWithRelationInput[]
    cursor?: SavedAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedAnswerScalarFieldEnum | SavedAnswerScalarFieldEnum[]
  }

  /**
   * Course.tags
   */
  export type Course$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    where?: CourseTagsWhereInput
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    cursor?: CourseTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * Course.reviews
   */
  export type Course$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    where?: CourseReviewWhereInput
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    cursor?: CourseReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseTags
   */

  export type AggregateCourseTags = {
    _count: CourseTagsCountAggregateOutputType | null
    _avg: CourseTagsAvgAggregateOutputType | null
    _sum: CourseTagsSumAggregateOutputType | null
    _min: CourseTagsMinAggregateOutputType | null
    _max: CourseTagsMaxAggregateOutputType | null
  }

  export type CourseTagsAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type CourseTagsSumAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type CourseTagsMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    name: string | null
  }

  export type CourseTagsMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    name: string | null
  }

  export type CourseTagsCountAggregateOutputType = {
    id: number
    courseId: number
    name: number
    _all: number
  }


  export type CourseTagsAvgAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type CourseTagsSumAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type CourseTagsMinAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
  }

  export type CourseTagsMaxAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
  }

  export type CourseTagsCountAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    _all?: true
  }

  export type CourseTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to aggregate.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTags
    **/
    _count?: true | CourseTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTagsMaxAggregateInputType
  }

  export type GetCourseTagsAggregateType<T extends CourseTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTags[P]>
      : GetScalarType<T[P], AggregateCourseTags[P]>
  }




  export type CourseTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagsWhereInput
    orderBy?: CourseTagsOrderByWithAggregationInput | CourseTagsOrderByWithAggregationInput[]
    by: CourseTagsScalarFieldEnum[] | CourseTagsScalarFieldEnum
    having?: CourseTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTagsCountAggregateInputType | true
    _avg?: CourseTagsAvgAggregateInputType
    _sum?: CourseTagsSumAggregateInputType
    _min?: CourseTagsMinAggregateInputType
    _max?: CourseTagsMaxAggregateInputType
  }

  export type CourseTagsGroupByOutputType = {
    id: number
    courseId: number
    name: string
    _count: CourseTagsCountAggregateOutputType | null
    _avg: CourseTagsAvgAggregateOutputType | null
    _sum: CourseTagsSumAggregateOutputType | null
    _min: CourseTagsMinAggregateOutputType | null
    _max: CourseTagsMaxAggregateOutputType | null
  }

  type GetCourseTagsGroupByPayload<T extends CourseTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTagsGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTagsGroupByOutputType[P]>
        }
      >
    >


  export type CourseTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTags"]>

  export type CourseTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTags"]>

  export type CourseTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTags"]>

  export type CourseTagsSelectScalar = {
    id?: boolean
    courseId?: boolean
    name?: boolean
  }

  export type CourseTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "name", ExtArgs["result"]["courseTags"]>
  export type CourseTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseTagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseTagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTags"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      name: string
    }, ExtArgs["result"]["courseTags"]>
    composites: {}
  }

  type CourseTagsGetPayload<S extends boolean | null | undefined | CourseTagsDefaultArgs> = $Result.GetResult<Prisma.$CourseTagsPayload, S>

  type CourseTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseTagsCountAggregateInputType | true
    }

  export interface CourseTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTags'], meta: { name: 'CourseTags' } }
    /**
     * Find zero or one CourseTags that matches the filter.
     * @param {CourseTagsFindUniqueArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseTagsFindUniqueArgs>(args: SelectSubset<T, CourseTagsFindUniqueArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseTagsFindUniqueOrThrowArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsFindFirstArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseTagsFindFirstArgs>(args?: SelectSubset<T, CourseTagsFindFirstArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsFindFirstOrThrowArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTags
     * const courseTags = await prisma.courseTags.findMany()
     * 
     * // Get first 10 CourseTags
     * const courseTags = await prisma.courseTags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseTagsWithIdOnly = await prisma.courseTags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseTagsFindManyArgs>(args?: SelectSubset<T, CourseTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseTags.
     * @param {CourseTagsCreateArgs} args - Arguments to create a CourseTags.
     * @example
     * // Create one CourseTags
     * const CourseTags = await prisma.courseTags.create({
     *   data: {
     *     // ... data to create a CourseTags
     *   }
     * })
     * 
     */
    create<T extends CourseTagsCreateArgs>(args: SelectSubset<T, CourseTagsCreateArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseTags.
     * @param {CourseTagsCreateManyArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTags = await prisma.courseTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseTagsCreateManyArgs>(args?: SelectSubset<T, CourseTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseTags and returns the data saved in the database.
     * @param {CourseTagsCreateManyAndReturnArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTags = await prisma.courseTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseTags and only return the `id`
     * const courseTagsWithIdOnly = await prisma.courseTags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseTags.
     * @param {CourseTagsDeleteArgs} args - Arguments to delete one CourseTags.
     * @example
     * // Delete one CourseTags
     * const CourseTags = await prisma.courseTags.delete({
     *   where: {
     *     // ... filter to delete one CourseTags
     *   }
     * })
     * 
     */
    delete<T extends CourseTagsDeleteArgs>(args: SelectSubset<T, CourseTagsDeleteArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseTags.
     * @param {CourseTagsUpdateArgs} args - Arguments to update one CourseTags.
     * @example
     * // Update one CourseTags
     * const courseTags = await prisma.courseTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseTagsUpdateArgs>(args: SelectSubset<T, CourseTagsUpdateArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseTags.
     * @param {CourseTagsDeleteManyArgs} args - Arguments to filter CourseTags to delete.
     * @example
     * // Delete a few CourseTags
     * const { count } = await prisma.courseTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseTagsDeleteManyArgs>(args?: SelectSubset<T, CourseTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTags
     * const courseTags = await prisma.courseTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseTagsUpdateManyArgs>(args: SelectSubset<T, CourseTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags and returns the data updated in the database.
     * @param {CourseTagsUpdateManyAndReturnArgs} args - Arguments to update many CourseTags.
     * @example
     * // Update many CourseTags
     * const courseTags = await prisma.courseTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseTags and only return the `id`
     * const courseTagsWithIdOnly = await prisma.courseTags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseTags.
     * @param {CourseTagsUpsertArgs} args - Arguments to update or create a CourseTags.
     * @example
     * // Update or create a CourseTags
     * const courseTags = await prisma.courseTags.upsert({
     *   create: {
     *     // ... data to create a CourseTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTags we want to update
     *   }
     * })
     */
    upsert<T extends CourseTagsUpsertArgs>(args: SelectSubset<T, CourseTagsUpsertArgs<ExtArgs>>): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsCountArgs} args - Arguments to filter CourseTags to count.
     * @example
     * // Count the number of CourseTags
     * const count = await prisma.courseTags.count({
     *   where: {
     *     // ... the filter for the CourseTags we want to count
     *   }
     * })
    **/
    count<T extends CourseTagsCountArgs>(
      args?: Subset<T, CourseTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTagsAggregateArgs>(args: Subset<T, CourseTagsAggregateArgs>): Prisma.PrismaPromise<GetCourseTagsAggregateType<T>>

    /**
     * Group by CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTagsGroupByArgs['orderBy'] }
        : { orderBy?: CourseTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTags model
   */
  readonly fields: CourseTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseTags model
   */
  interface CourseTagsFieldRefs {
    readonly id: FieldRef<"CourseTags", 'Int'>
    readonly courseId: FieldRef<"CourseTags", 'Int'>
    readonly name: FieldRef<"CourseTags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseTags findUnique
   */
  export type CourseTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags findUniqueOrThrow
   */
  export type CourseTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags findFirst
   */
  export type CourseTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * CourseTags findFirstOrThrow
   */
  export type CourseTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * CourseTags findMany
   */
  export type CourseTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTags.
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * CourseTags create
   */
  export type CourseTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTags.
     */
    data: XOR<CourseTagsCreateInput, CourseTagsUncheckedCreateInput>
  }

  /**
   * CourseTags createMany
   */
  export type CourseTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagsCreateManyInput | CourseTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTags createManyAndReturn
   */
  export type CourseTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagsCreateManyInput | CourseTagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTags update
   */
  export type CourseTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTags.
     */
    data: XOR<CourseTagsUpdateInput, CourseTagsUncheckedUpdateInput>
    /**
     * Choose, which CourseTags to update.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags updateMany
   */
  export type CourseTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagsUpdateManyMutationInput, CourseTagsUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagsWhereInput
    /**
     * Limit how many CourseTags to update.
     */
    limit?: number
  }

  /**
   * CourseTags updateManyAndReturn
   */
  export type CourseTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagsUpdateManyMutationInput, CourseTagsUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagsWhereInput
    /**
     * Limit how many CourseTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTags upsert
   */
  export type CourseTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTags to update in case it exists.
     */
    where: CourseTagsWhereUniqueInput
    /**
     * In case the CourseTags found by the `where` argument doesn't exist, create a new CourseTags with this data.
     */
    create: XOR<CourseTagsCreateInput, CourseTagsUncheckedCreateInput>
    /**
     * In case the CourseTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTagsUpdateInput, CourseTagsUncheckedUpdateInput>
  }

  /**
   * CourseTags delete
   */
  export type CourseTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter which CourseTags to delete.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags deleteMany
   */
  export type CourseTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to delete
     */
    where?: CourseTagsWhereInput
    /**
     * Limit how many CourseTags to delete.
     */
    limit?: number
  }

  /**
   * CourseTags without action
   */
  export type CourseTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTags
     */
    omit?: CourseTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
  }


  /**
   * Model LearningOutcome
   */

  export type AggregateLearningOutcome = {
    _count: LearningOutcomeCountAggregateOutputType | null
    _avg: LearningOutcomeAvgAggregateOutputType | null
    _sum: LearningOutcomeSumAggregateOutputType | null
    _min: LearningOutcomeMinAggregateOutputType | null
    _max: LearningOutcomeMaxAggregateOutputType | null
  }

  export type LearningOutcomeAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    orderNumber: number | null
  }

  export type LearningOutcomeSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    orderNumber: number | null
  }

  export type LearningOutcomeMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    description: string | null
    orderNumber: number | null
  }

  export type LearningOutcomeMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    description: string | null
    orderNumber: number | null
  }

  export type LearningOutcomeCountAggregateOutputType = {
    id: number
    courseId: number
    description: number
    orderNumber: number
    _all: number
  }


  export type LearningOutcomeAvgAggregateInputType = {
    id?: true
    courseId?: true
    orderNumber?: true
  }

  export type LearningOutcomeSumAggregateInputType = {
    id?: true
    courseId?: true
    orderNumber?: true
  }

  export type LearningOutcomeMinAggregateInputType = {
    id?: true
    courseId?: true
    description?: true
    orderNumber?: true
  }

  export type LearningOutcomeMaxAggregateInputType = {
    id?: true
    courseId?: true
    description?: true
    orderNumber?: true
  }

  export type LearningOutcomeCountAggregateInputType = {
    id?: true
    courseId?: true
    description?: true
    orderNumber?: true
    _all?: true
  }

  export type LearningOutcomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningOutcome to aggregate.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningOutcomes
    **/
    _count?: true | LearningOutcomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningOutcomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningOutcomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningOutcomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningOutcomeMaxAggregateInputType
  }

  export type GetLearningOutcomeAggregateType<T extends LearningOutcomeAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningOutcome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningOutcome[P]>
      : GetScalarType<T[P], AggregateLearningOutcome[P]>
  }




  export type LearningOutcomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningOutcomeWhereInput
    orderBy?: LearningOutcomeOrderByWithAggregationInput | LearningOutcomeOrderByWithAggregationInput[]
    by: LearningOutcomeScalarFieldEnum[] | LearningOutcomeScalarFieldEnum
    having?: LearningOutcomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningOutcomeCountAggregateInputType | true
    _avg?: LearningOutcomeAvgAggregateInputType
    _sum?: LearningOutcomeSumAggregateInputType
    _min?: LearningOutcomeMinAggregateInputType
    _max?: LearningOutcomeMaxAggregateInputType
  }

  export type LearningOutcomeGroupByOutputType = {
    id: number
    courseId: number
    description: string
    orderNumber: number
    _count: LearningOutcomeCountAggregateOutputType | null
    _avg: LearningOutcomeAvgAggregateOutputType | null
    _sum: LearningOutcomeSumAggregateOutputType | null
    _min: LearningOutcomeMinAggregateOutputType | null
    _max: LearningOutcomeMaxAggregateOutputType | null
  }

  type GetLearningOutcomeGroupByPayload<T extends LearningOutcomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningOutcomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningOutcomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningOutcomeGroupByOutputType[P]>
            : GetScalarType<T[P], LearningOutcomeGroupByOutputType[P]>
        }
      >
    >


  export type LearningOutcomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningOutcome"]>

  export type LearningOutcomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningOutcome"]>

  export type LearningOutcomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningOutcome"]>

  export type LearningOutcomeSelectScalar = {
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
  }

  export type LearningOutcomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "description" | "orderNumber", ExtArgs["result"]["learningOutcome"]>
  export type LearningOutcomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LearningOutcomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LearningOutcomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $LearningOutcomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningOutcome"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      description: string
      orderNumber: number
    }, ExtArgs["result"]["learningOutcome"]>
    composites: {}
  }

  type LearningOutcomeGetPayload<S extends boolean | null | undefined | LearningOutcomeDefaultArgs> = $Result.GetResult<Prisma.$LearningOutcomePayload, S>

  type LearningOutcomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningOutcomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningOutcomeCountAggregateInputType | true
    }

  export interface LearningOutcomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningOutcome'], meta: { name: 'LearningOutcome' } }
    /**
     * Find zero or one LearningOutcome that matches the filter.
     * @param {LearningOutcomeFindUniqueArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningOutcomeFindUniqueArgs>(args: SelectSubset<T, LearningOutcomeFindUniqueArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningOutcome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningOutcomeFindUniqueOrThrowArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningOutcomeFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningOutcomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningOutcome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeFindFirstArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningOutcomeFindFirstArgs>(args?: SelectSubset<T, LearningOutcomeFindFirstArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningOutcome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeFindFirstOrThrowArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningOutcomeFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningOutcomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningOutcomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningOutcomes
     * const learningOutcomes = await prisma.learningOutcome.findMany()
     * 
     * // Get first 10 LearningOutcomes
     * const learningOutcomes = await prisma.learningOutcome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningOutcomeWithIdOnly = await prisma.learningOutcome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningOutcomeFindManyArgs>(args?: SelectSubset<T, LearningOutcomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningOutcome.
     * @param {LearningOutcomeCreateArgs} args - Arguments to create a LearningOutcome.
     * @example
     * // Create one LearningOutcome
     * const LearningOutcome = await prisma.learningOutcome.create({
     *   data: {
     *     // ... data to create a LearningOutcome
     *   }
     * })
     * 
     */
    create<T extends LearningOutcomeCreateArgs>(args: SelectSubset<T, LearningOutcomeCreateArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningOutcomes.
     * @param {LearningOutcomeCreateManyArgs} args - Arguments to create many LearningOutcomes.
     * @example
     * // Create many LearningOutcomes
     * const learningOutcome = await prisma.learningOutcome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningOutcomeCreateManyArgs>(args?: SelectSubset<T, LearningOutcomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningOutcomes and returns the data saved in the database.
     * @param {LearningOutcomeCreateManyAndReturnArgs} args - Arguments to create many LearningOutcomes.
     * @example
     * // Create many LearningOutcomes
     * const learningOutcome = await prisma.learningOutcome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningOutcomes and only return the `id`
     * const learningOutcomeWithIdOnly = await prisma.learningOutcome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningOutcomeCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningOutcomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningOutcome.
     * @param {LearningOutcomeDeleteArgs} args - Arguments to delete one LearningOutcome.
     * @example
     * // Delete one LearningOutcome
     * const LearningOutcome = await prisma.learningOutcome.delete({
     *   where: {
     *     // ... filter to delete one LearningOutcome
     *   }
     * })
     * 
     */
    delete<T extends LearningOutcomeDeleteArgs>(args: SelectSubset<T, LearningOutcomeDeleteArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningOutcome.
     * @param {LearningOutcomeUpdateArgs} args - Arguments to update one LearningOutcome.
     * @example
     * // Update one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningOutcomeUpdateArgs>(args: SelectSubset<T, LearningOutcomeUpdateArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningOutcomes.
     * @param {LearningOutcomeDeleteManyArgs} args - Arguments to filter LearningOutcomes to delete.
     * @example
     * // Delete a few LearningOutcomes
     * const { count } = await prisma.learningOutcome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningOutcomeDeleteManyArgs>(args?: SelectSubset<T, LearningOutcomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningOutcomes
     * const learningOutcome = await prisma.learningOutcome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningOutcomeUpdateManyArgs>(args: SelectSubset<T, LearningOutcomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningOutcomes and returns the data updated in the database.
     * @param {LearningOutcomeUpdateManyAndReturnArgs} args - Arguments to update many LearningOutcomes.
     * @example
     * // Update many LearningOutcomes
     * const learningOutcome = await prisma.learningOutcome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningOutcomes and only return the `id`
     * const learningOutcomeWithIdOnly = await prisma.learningOutcome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningOutcomeUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningOutcomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningOutcome.
     * @param {LearningOutcomeUpsertArgs} args - Arguments to update or create a LearningOutcome.
     * @example
     * // Update or create a LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.upsert({
     *   create: {
     *     // ... data to create a LearningOutcome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningOutcome we want to update
     *   }
     * })
     */
    upsert<T extends LearningOutcomeUpsertArgs>(args: SelectSubset<T, LearningOutcomeUpsertArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeCountArgs} args - Arguments to filter LearningOutcomes to count.
     * @example
     * // Count the number of LearningOutcomes
     * const count = await prisma.learningOutcome.count({
     *   where: {
     *     // ... the filter for the LearningOutcomes we want to count
     *   }
     * })
    **/
    count<T extends LearningOutcomeCountArgs>(
      args?: Subset<T, LearningOutcomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningOutcomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningOutcomeAggregateArgs>(args: Subset<T, LearningOutcomeAggregateArgs>): Prisma.PrismaPromise<GetLearningOutcomeAggregateType<T>>

    /**
     * Group by LearningOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningOutcomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningOutcomeGroupByArgs['orderBy'] }
        : { orderBy?: LearningOutcomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningOutcomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningOutcomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningOutcome model
   */
  readonly fields: LearningOutcomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningOutcome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningOutcomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningOutcome model
   */
  interface LearningOutcomeFieldRefs {
    readonly id: FieldRef<"LearningOutcome", 'Int'>
    readonly courseId: FieldRef<"LearningOutcome", 'Int'>
    readonly description: FieldRef<"LearningOutcome", 'String'>
    readonly orderNumber: FieldRef<"LearningOutcome", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LearningOutcome findUnique
   */
  export type LearningOutcomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome findUniqueOrThrow
   */
  export type LearningOutcomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome findFirst
   */
  export type LearningOutcomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningOutcomes.
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningOutcomes.
     */
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * LearningOutcome findFirstOrThrow
   */
  export type LearningOutcomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningOutcomes.
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningOutcomes.
     */
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * LearningOutcome findMany
   */
  export type LearningOutcomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcomes to fetch.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningOutcomes.
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * LearningOutcome create
   */
  export type LearningOutcomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningOutcome.
     */
    data: XOR<LearningOutcomeCreateInput, LearningOutcomeUncheckedCreateInput>
  }

  /**
   * LearningOutcome createMany
   */
  export type LearningOutcomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningOutcomes.
     */
    data: LearningOutcomeCreateManyInput | LearningOutcomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningOutcome createManyAndReturn
   */
  export type LearningOutcomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * The data used to create many LearningOutcomes.
     */
    data: LearningOutcomeCreateManyInput | LearningOutcomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningOutcome update
   */
  export type LearningOutcomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningOutcome.
     */
    data: XOR<LearningOutcomeUpdateInput, LearningOutcomeUncheckedUpdateInput>
    /**
     * Choose, which LearningOutcome to update.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome updateMany
   */
  export type LearningOutcomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningOutcomes.
     */
    data: XOR<LearningOutcomeUpdateManyMutationInput, LearningOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which LearningOutcomes to update
     */
    where?: LearningOutcomeWhereInput
    /**
     * Limit how many LearningOutcomes to update.
     */
    limit?: number
  }

  /**
   * LearningOutcome updateManyAndReturn
   */
  export type LearningOutcomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * The data used to update LearningOutcomes.
     */
    data: XOR<LearningOutcomeUpdateManyMutationInput, LearningOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which LearningOutcomes to update
     */
    where?: LearningOutcomeWhereInput
    /**
     * Limit how many LearningOutcomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningOutcome upsert
   */
  export type LearningOutcomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningOutcome to update in case it exists.
     */
    where: LearningOutcomeWhereUniqueInput
    /**
     * In case the LearningOutcome found by the `where` argument doesn't exist, create a new LearningOutcome with this data.
     */
    create: XOR<LearningOutcomeCreateInput, LearningOutcomeUncheckedCreateInput>
    /**
     * In case the LearningOutcome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningOutcomeUpdateInput, LearningOutcomeUncheckedUpdateInput>
  }

  /**
   * LearningOutcome delete
   */
  export type LearningOutcomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter which LearningOutcome to delete.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome deleteMany
   */
  export type LearningOutcomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningOutcomes to delete
     */
    where?: LearningOutcomeWhereInput
    /**
     * Limit how many LearningOutcomes to delete.
     */
    limit?: number
  }

  /**
   * LearningOutcome without action
   */
  export type LearningOutcomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
  }


  /**
   * Model CourseRequirement
   */

  export type AggregateCourseRequirement = {
    _count: CourseRequirementCountAggregateOutputType | null
    _avg: CourseRequirementAvgAggregateOutputType | null
    _sum: CourseRequirementSumAggregateOutputType | null
    _min: CourseRequirementMinAggregateOutputType | null
    _max: CourseRequirementMaxAggregateOutputType | null
  }

  export type CourseRequirementAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    orderNumber: number | null
  }

  export type CourseRequirementSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    orderNumber: number | null
  }

  export type CourseRequirementMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    description: string | null
    orderNumber: number | null
  }

  export type CourseRequirementMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    description: string | null
    orderNumber: number | null
  }

  export type CourseRequirementCountAggregateOutputType = {
    id: number
    courseId: number
    description: number
    orderNumber: number
    _all: number
  }


  export type CourseRequirementAvgAggregateInputType = {
    id?: true
    courseId?: true
    orderNumber?: true
  }

  export type CourseRequirementSumAggregateInputType = {
    id?: true
    courseId?: true
    orderNumber?: true
  }

  export type CourseRequirementMinAggregateInputType = {
    id?: true
    courseId?: true
    description?: true
    orderNumber?: true
  }

  export type CourseRequirementMaxAggregateInputType = {
    id?: true
    courseId?: true
    description?: true
    orderNumber?: true
  }

  export type CourseRequirementCountAggregateInputType = {
    id?: true
    courseId?: true
    description?: true
    orderNumber?: true
    _all?: true
  }

  export type CourseRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseRequirement to aggregate.
     */
    where?: CourseRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRequirements to fetch.
     */
    orderBy?: CourseRequirementOrderByWithRelationInput | CourseRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseRequirements
    **/
    _count?: true | CourseRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseRequirementMaxAggregateInputType
  }

  export type GetCourseRequirementAggregateType<T extends CourseRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseRequirement[P]>
      : GetScalarType<T[P], AggregateCourseRequirement[P]>
  }




  export type CourseRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRequirementWhereInput
    orderBy?: CourseRequirementOrderByWithAggregationInput | CourseRequirementOrderByWithAggregationInput[]
    by: CourseRequirementScalarFieldEnum[] | CourseRequirementScalarFieldEnum
    having?: CourseRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseRequirementCountAggregateInputType | true
    _avg?: CourseRequirementAvgAggregateInputType
    _sum?: CourseRequirementSumAggregateInputType
    _min?: CourseRequirementMinAggregateInputType
    _max?: CourseRequirementMaxAggregateInputType
  }

  export type CourseRequirementGroupByOutputType = {
    id: number
    courseId: number
    description: string
    orderNumber: number
    _count: CourseRequirementCountAggregateOutputType | null
    _avg: CourseRequirementAvgAggregateOutputType | null
    _sum: CourseRequirementSumAggregateOutputType | null
    _min: CourseRequirementMinAggregateOutputType | null
    _max: CourseRequirementMaxAggregateOutputType | null
  }

  type GetCourseRequirementGroupByPayload<T extends CourseRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], CourseRequirementGroupByOutputType[P]>
        }
      >
    >


  export type CourseRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRequirement"]>

  export type CourseRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRequirement"]>

  export type CourseRequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRequirement"]>

  export type CourseRequirementSelectScalar = {
    id?: boolean
    courseId?: boolean
    description?: boolean
    orderNumber?: boolean
  }

  export type CourseRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "description" | "orderNumber", ExtArgs["result"]["courseRequirement"]>
  export type CourseRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseRequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseRequirement"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      description: string
      orderNumber: number
    }, ExtArgs["result"]["courseRequirement"]>
    composites: {}
  }

  type CourseRequirementGetPayload<S extends boolean | null | undefined | CourseRequirementDefaultArgs> = $Result.GetResult<Prisma.$CourseRequirementPayload, S>

  type CourseRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseRequirementCountAggregateInputType | true
    }

  export interface CourseRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseRequirement'], meta: { name: 'CourseRequirement' } }
    /**
     * Find zero or one CourseRequirement that matches the filter.
     * @param {CourseRequirementFindUniqueArgs} args - Arguments to find a CourseRequirement
     * @example
     * // Get one CourseRequirement
     * const courseRequirement = await prisma.courseRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseRequirementFindUniqueArgs>(args: SelectSubset<T, CourseRequirementFindUniqueArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseRequirementFindUniqueOrThrowArgs} args - Arguments to find a CourseRequirement
     * @example
     * // Get one CourseRequirement
     * const courseRequirement = await prisma.courseRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementFindFirstArgs} args - Arguments to find a CourseRequirement
     * @example
     * // Get one CourseRequirement
     * const courseRequirement = await prisma.courseRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseRequirementFindFirstArgs>(args?: SelectSubset<T, CourseRequirementFindFirstArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementFindFirstOrThrowArgs} args - Arguments to find a CourseRequirement
     * @example
     * // Get one CourseRequirement
     * const courseRequirement = await prisma.courseRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseRequirements
     * const courseRequirements = await prisma.courseRequirement.findMany()
     * 
     * // Get first 10 CourseRequirements
     * const courseRequirements = await prisma.courseRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseRequirementWithIdOnly = await prisma.courseRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseRequirementFindManyArgs>(args?: SelectSubset<T, CourseRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseRequirement.
     * @param {CourseRequirementCreateArgs} args - Arguments to create a CourseRequirement.
     * @example
     * // Create one CourseRequirement
     * const CourseRequirement = await prisma.courseRequirement.create({
     *   data: {
     *     // ... data to create a CourseRequirement
     *   }
     * })
     * 
     */
    create<T extends CourseRequirementCreateArgs>(args: SelectSubset<T, CourseRequirementCreateArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseRequirements.
     * @param {CourseRequirementCreateManyArgs} args - Arguments to create many CourseRequirements.
     * @example
     * // Create many CourseRequirements
     * const courseRequirement = await prisma.courseRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseRequirementCreateManyArgs>(args?: SelectSubset<T, CourseRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseRequirements and returns the data saved in the database.
     * @param {CourseRequirementCreateManyAndReturnArgs} args - Arguments to create many CourseRequirements.
     * @example
     * // Create many CourseRequirements
     * const courseRequirement = await prisma.courseRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseRequirements and only return the `id`
     * const courseRequirementWithIdOnly = await prisma.courseRequirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseRequirement.
     * @param {CourseRequirementDeleteArgs} args - Arguments to delete one CourseRequirement.
     * @example
     * // Delete one CourseRequirement
     * const CourseRequirement = await prisma.courseRequirement.delete({
     *   where: {
     *     // ... filter to delete one CourseRequirement
     *   }
     * })
     * 
     */
    delete<T extends CourseRequirementDeleteArgs>(args: SelectSubset<T, CourseRequirementDeleteArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseRequirement.
     * @param {CourseRequirementUpdateArgs} args - Arguments to update one CourseRequirement.
     * @example
     * // Update one CourseRequirement
     * const courseRequirement = await prisma.courseRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseRequirementUpdateArgs>(args: SelectSubset<T, CourseRequirementUpdateArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseRequirements.
     * @param {CourseRequirementDeleteManyArgs} args - Arguments to filter CourseRequirements to delete.
     * @example
     * // Delete a few CourseRequirements
     * const { count } = await prisma.courseRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseRequirementDeleteManyArgs>(args?: SelectSubset<T, CourseRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseRequirements
     * const courseRequirement = await prisma.courseRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseRequirementUpdateManyArgs>(args: SelectSubset<T, CourseRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseRequirements and returns the data updated in the database.
     * @param {CourseRequirementUpdateManyAndReturnArgs} args - Arguments to update many CourseRequirements.
     * @example
     * // Update many CourseRequirements
     * const courseRequirement = await prisma.courseRequirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseRequirements and only return the `id`
     * const courseRequirementWithIdOnly = await prisma.courseRequirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseRequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseRequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseRequirement.
     * @param {CourseRequirementUpsertArgs} args - Arguments to update or create a CourseRequirement.
     * @example
     * // Update or create a CourseRequirement
     * const courseRequirement = await prisma.courseRequirement.upsert({
     *   create: {
     *     // ... data to create a CourseRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseRequirement we want to update
     *   }
     * })
     */
    upsert<T extends CourseRequirementUpsertArgs>(args: SelectSubset<T, CourseRequirementUpsertArgs<ExtArgs>>): Prisma__CourseRequirementClient<$Result.GetResult<Prisma.$CourseRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementCountArgs} args - Arguments to filter CourseRequirements to count.
     * @example
     * // Count the number of CourseRequirements
     * const count = await prisma.courseRequirement.count({
     *   where: {
     *     // ... the filter for the CourseRequirements we want to count
     *   }
     * })
    **/
    count<T extends CourseRequirementCountArgs>(
      args?: Subset<T, CourseRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseRequirementAggregateArgs>(args: Subset<T, CourseRequirementAggregateArgs>): Prisma.PrismaPromise<GetCourseRequirementAggregateType<T>>

    /**
     * Group by CourseRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseRequirementGroupByArgs['orderBy'] }
        : { orderBy?: CourseRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseRequirement model
   */
  readonly fields: CourseRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseRequirement model
   */
  interface CourseRequirementFieldRefs {
    readonly id: FieldRef<"CourseRequirement", 'Int'>
    readonly courseId: FieldRef<"CourseRequirement", 'Int'>
    readonly description: FieldRef<"CourseRequirement", 'String'>
    readonly orderNumber: FieldRef<"CourseRequirement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseRequirement findUnique
   */
  export type CourseRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * Filter, which CourseRequirement to fetch.
     */
    where: CourseRequirementWhereUniqueInput
  }

  /**
   * CourseRequirement findUniqueOrThrow
   */
  export type CourseRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * Filter, which CourseRequirement to fetch.
     */
    where: CourseRequirementWhereUniqueInput
  }

  /**
   * CourseRequirement findFirst
   */
  export type CourseRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * Filter, which CourseRequirement to fetch.
     */
    where?: CourseRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRequirements to fetch.
     */
    orderBy?: CourseRequirementOrderByWithRelationInput | CourseRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseRequirements.
     */
    cursor?: CourseRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseRequirements.
     */
    distinct?: CourseRequirementScalarFieldEnum | CourseRequirementScalarFieldEnum[]
  }

  /**
   * CourseRequirement findFirstOrThrow
   */
  export type CourseRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * Filter, which CourseRequirement to fetch.
     */
    where?: CourseRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRequirements to fetch.
     */
    orderBy?: CourseRequirementOrderByWithRelationInput | CourseRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseRequirements.
     */
    cursor?: CourseRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseRequirements.
     */
    distinct?: CourseRequirementScalarFieldEnum | CourseRequirementScalarFieldEnum[]
  }

  /**
   * CourseRequirement findMany
   */
  export type CourseRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * Filter, which CourseRequirements to fetch.
     */
    where?: CourseRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRequirements to fetch.
     */
    orderBy?: CourseRequirementOrderByWithRelationInput | CourseRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseRequirements.
     */
    cursor?: CourseRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRequirements.
     */
    skip?: number
    distinct?: CourseRequirementScalarFieldEnum | CourseRequirementScalarFieldEnum[]
  }

  /**
   * CourseRequirement create
   */
  export type CourseRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseRequirement.
     */
    data: XOR<CourseRequirementCreateInput, CourseRequirementUncheckedCreateInput>
  }

  /**
   * CourseRequirement createMany
   */
  export type CourseRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseRequirements.
     */
    data: CourseRequirementCreateManyInput | CourseRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseRequirement createManyAndReturn
   */
  export type CourseRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * The data used to create many CourseRequirements.
     */
    data: CourseRequirementCreateManyInput | CourseRequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseRequirement update
   */
  export type CourseRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseRequirement.
     */
    data: XOR<CourseRequirementUpdateInput, CourseRequirementUncheckedUpdateInput>
    /**
     * Choose, which CourseRequirement to update.
     */
    where: CourseRequirementWhereUniqueInput
  }

  /**
   * CourseRequirement updateMany
   */
  export type CourseRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseRequirements.
     */
    data: XOR<CourseRequirementUpdateManyMutationInput, CourseRequirementUncheckedUpdateManyInput>
    /**
     * Filter which CourseRequirements to update
     */
    where?: CourseRequirementWhereInput
    /**
     * Limit how many CourseRequirements to update.
     */
    limit?: number
  }

  /**
   * CourseRequirement updateManyAndReturn
   */
  export type CourseRequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * The data used to update CourseRequirements.
     */
    data: XOR<CourseRequirementUpdateManyMutationInput, CourseRequirementUncheckedUpdateManyInput>
    /**
     * Filter which CourseRequirements to update
     */
    where?: CourseRequirementWhereInput
    /**
     * Limit how many CourseRequirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseRequirement upsert
   */
  export type CourseRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseRequirement to update in case it exists.
     */
    where: CourseRequirementWhereUniqueInput
    /**
     * In case the CourseRequirement found by the `where` argument doesn't exist, create a new CourseRequirement with this data.
     */
    create: XOR<CourseRequirementCreateInput, CourseRequirementUncheckedCreateInput>
    /**
     * In case the CourseRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseRequirementUpdateInput, CourseRequirementUncheckedUpdateInput>
  }

  /**
   * CourseRequirement delete
   */
  export type CourseRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
    /**
     * Filter which CourseRequirement to delete.
     */
    where: CourseRequirementWhereUniqueInput
  }

  /**
   * CourseRequirement deleteMany
   */
  export type CourseRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseRequirements to delete
     */
    where?: CourseRequirementWhereInput
    /**
     * Limit how many CourseRequirements to delete.
     */
    limit?: number
  }

  /**
   * CourseRequirement without action
   */
  export type CourseRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRequirement
     */
    select?: CourseRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRequirement
     */
    omit?: CourseRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRequirementInclude<ExtArgs> | null
  }


  /**
   * Model CourseModule
   */

  export type AggregateCourseModule = {
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  export type CourseModuleAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    orderNumber: number | null
    estimatedHours: number | null
  }

  export type CourseModuleSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    orderNumber: number | null
    estimatedHours: number | null
  }

  export type CourseModuleMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    description: string | null
    orderNumber: number | null
    isPublished: boolean | null
    estimatedHours: number | null
    unlockCondition: string | null
    thumbnail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseModuleMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    description: string | null
    orderNumber: number | null
    isPublished: boolean | null
    estimatedHours: number | null
    unlockCondition: string | null
    thumbnail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseModuleCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    orderNumber: number
    isPublished: number
    estimatedHours: number
    unlockCondition: number
    thumbnail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseModuleAvgAggregateInputType = {
    id?: true
    courseId?: true
    orderNumber?: true
    estimatedHours?: true
  }

  export type CourseModuleSumAggregateInputType = {
    id?: true
    courseId?: true
    orderNumber?: true
    estimatedHours?: true
  }

  export type CourseModuleMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderNumber?: true
    isPublished?: true
    estimatedHours?: true
    unlockCondition?: true
    thumbnail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseModuleMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderNumber?: true
    isPublished?: true
    estimatedHours?: true
    unlockCondition?: true
    thumbnail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseModuleCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderNumber?: true
    isPublished?: true
    estimatedHours?: true
    unlockCondition?: true
    thumbnail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModule to aggregate.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseModules
    **/
    _count?: true | CourseModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseModuleMaxAggregateInputType
  }

  export type GetCourseModuleAggregateType<T extends CourseModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseModule[P]>
      : GetScalarType<T[P], AggregateCourseModule[P]>
  }




  export type CourseModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithAggregationInput | CourseModuleOrderByWithAggregationInput[]
    by: CourseModuleScalarFieldEnum[] | CourseModuleScalarFieldEnum
    having?: CourseModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseModuleCountAggregateInputType | true
    _avg?: CourseModuleAvgAggregateInputType
    _sum?: CourseModuleSumAggregateInputType
    _min?: CourseModuleMinAggregateInputType
    _max?: CourseModuleMaxAggregateInputType
  }

  export type CourseModuleGroupByOutputType = {
    id: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished: boolean
    estimatedHours: number | null
    unlockCondition: string | null
    thumbnail: string | null
    createdAt: Date
    updatedAt: Date
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  type GetCourseModuleGroupByPayload<T extends CourseModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
            : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
        }
      >
    >


  export type CourseModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    estimatedHours?: boolean
    unlockCondition?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    units?: boolean | CourseModule$unitsArgs<ExtArgs>
    quizzes?: boolean | CourseModule$quizzesArgs<ExtArgs>
    exercises?: boolean | CourseModule$exercisesArgs<ExtArgs>
    userProgress?: boolean | CourseModule$userProgressArgs<ExtArgs>
    flashcards?: boolean | CourseModule$flashcardsArgs<ExtArgs>
    chatbotMessages?: boolean | CourseModule$chatbotMessagesArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    estimatedHours?: boolean
    unlockCondition?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    estimatedHours?: boolean
    unlockCondition?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    estimatedHours?: boolean
    unlockCondition?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "description" | "orderNumber" | "isPublished" | "estimatedHours" | "unlockCondition" | "thumbnail" | "createdAt" | "updatedAt", ExtArgs["result"]["courseModule"]>
  export type CourseModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    units?: boolean | CourseModule$unitsArgs<ExtArgs>
    quizzes?: boolean | CourseModule$quizzesArgs<ExtArgs>
    exercises?: boolean | CourseModule$exercisesArgs<ExtArgs>
    userProgress?: boolean | CourseModule$userProgressArgs<ExtArgs>
    flashcards?: boolean | CourseModule$flashcardsArgs<ExtArgs>
    chatbotMessages?: boolean | CourseModule$chatbotMessagesArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseModule"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      units: Prisma.$ContentUnitPayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      userProgress: Prisma.$ModuleProgressPayload<ExtArgs>[]
      flashcards: Prisma.$FlashcardPayload<ExtArgs>[]
      chatbotMessages: Prisma.$ChatbotMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      description: string
      orderNumber: number
      isPublished: boolean
      estimatedHours: number | null
      unlockCondition: string | null
      thumbnail: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseModule"]>
    composites: {}
  }

  type CourseModuleGetPayload<S extends boolean | null | undefined | CourseModuleDefaultArgs> = $Result.GetResult<Prisma.$CourseModulePayload, S>

  type CourseModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseModuleCountAggregateInputType | true
    }

  export interface CourseModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseModule'], meta: { name: 'CourseModule' } }
    /**
     * Find zero or one CourseModule that matches the filter.
     * @param {CourseModuleFindUniqueArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseModuleFindUniqueArgs>(args: SelectSubset<T, CourseModuleFindUniqueArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseModuleFindUniqueOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseModuleFindFirstArgs>(args?: SelectSubset<T, CourseModuleFindFirstArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseModules
     * const courseModules = await prisma.courseModule.findMany()
     * 
     * // Get first 10 CourseModules
     * const courseModules = await prisma.courseModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseModuleFindManyArgs>(args?: SelectSubset<T, CourseModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseModule.
     * @param {CourseModuleCreateArgs} args - Arguments to create a CourseModule.
     * @example
     * // Create one CourseModule
     * const CourseModule = await prisma.courseModule.create({
     *   data: {
     *     // ... data to create a CourseModule
     *   }
     * })
     * 
     */
    create<T extends CourseModuleCreateArgs>(args: SelectSubset<T, CourseModuleCreateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseModules.
     * @param {CourseModuleCreateManyArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseModuleCreateManyArgs>(args?: SelectSubset<T, CourseModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseModules and returns the data saved in the database.
     * @param {CourseModuleCreateManyAndReturnArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseModule.
     * @param {CourseModuleDeleteArgs} args - Arguments to delete one CourseModule.
     * @example
     * // Delete one CourseModule
     * const CourseModule = await prisma.courseModule.delete({
     *   where: {
     *     // ... filter to delete one CourseModule
     *   }
     * })
     * 
     */
    delete<T extends CourseModuleDeleteArgs>(args: SelectSubset<T, CourseModuleDeleteArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseModule.
     * @param {CourseModuleUpdateArgs} args - Arguments to update one CourseModule.
     * @example
     * // Update one CourseModule
     * const courseModule = await prisma.courseModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseModuleUpdateArgs>(args: SelectSubset<T, CourseModuleUpdateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseModules.
     * @param {CourseModuleDeleteManyArgs} args - Arguments to filter CourseModules to delete.
     * @example
     * // Delete a few CourseModules
     * const { count } = await prisma.courseModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseModuleDeleteManyArgs>(args?: SelectSubset<T, CourseModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseModuleUpdateManyArgs>(args: SelectSubset<T, CourseModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules and returns the data updated in the database.
     * @param {CourseModuleUpdateManyAndReturnArgs} args - Arguments to update many CourseModules.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseModule.
     * @param {CourseModuleUpsertArgs} args - Arguments to update or create a CourseModule.
     * @example
     * // Update or create a CourseModule
     * const courseModule = await prisma.courseModule.upsert({
     *   create: {
     *     // ... data to create a CourseModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseModule we want to update
     *   }
     * })
     */
    upsert<T extends CourseModuleUpsertArgs>(args: SelectSubset<T, CourseModuleUpsertArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleCountArgs} args - Arguments to filter CourseModules to count.
     * @example
     * // Count the number of CourseModules
     * const count = await prisma.courseModule.count({
     *   where: {
     *     // ... the filter for the CourseModules we want to count
     *   }
     * })
    **/
    count<T extends CourseModuleCountArgs>(
      args?: Subset<T, CourseModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseModuleAggregateArgs>(args: Subset<T, CourseModuleAggregateArgs>): Prisma.PrismaPromise<GetCourseModuleAggregateType<T>>

    /**
     * Group by CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseModuleGroupByArgs['orderBy'] }
        : { orderBy?: CourseModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseModule model
   */
  readonly fields: CourseModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    units<T extends CourseModule$unitsArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends CourseModule$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exercises<T extends CourseModule$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProgress<T extends CourseModule$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flashcards<T extends CourseModule$flashcardsArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$flashcardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatbotMessages<T extends CourseModule$chatbotMessagesArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$chatbotMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseModule model
   */
  interface CourseModuleFieldRefs {
    readonly id: FieldRef<"CourseModule", 'Int'>
    readonly courseId: FieldRef<"CourseModule", 'Int'>
    readonly title: FieldRef<"CourseModule", 'String'>
    readonly description: FieldRef<"CourseModule", 'String'>
    readonly orderNumber: FieldRef<"CourseModule", 'Int'>
    readonly isPublished: FieldRef<"CourseModule", 'Boolean'>
    readonly estimatedHours: FieldRef<"CourseModule", 'Int'>
    readonly unlockCondition: FieldRef<"CourseModule", 'String'>
    readonly thumbnail: FieldRef<"CourseModule", 'String'>
    readonly createdAt: FieldRef<"CourseModule", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseModule findUnique
   */
  export type CourseModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findUniqueOrThrow
   */
  export type CourseModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findFirst
   */
  export type CourseModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findFirstOrThrow
   */
  export type CourseModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findMany
   */
  export type CourseModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModules to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule create
   */
  export type CourseModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseModule.
     */
    data: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
  }

  /**
   * CourseModule createMany
   */
  export type CourseModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseModule createManyAndReturn
   */
  export type CourseModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule update
   */
  export type CourseModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseModule.
     */
    data: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
    /**
     * Choose, which CourseModule to update.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule updateMany
   */
  export type CourseModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
  }

  /**
   * CourseModule updateManyAndReturn
   */
  export type CourseModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule upsert
   */
  export type CourseModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseModule to update in case it exists.
     */
    where: CourseModuleWhereUniqueInput
    /**
     * In case the CourseModule found by the `where` argument doesn't exist, create a new CourseModule with this data.
     */
    create: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
    /**
     * In case the CourseModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
  }

  /**
   * CourseModule delete
   */
  export type CourseModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter which CourseModule to delete.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule deleteMany
   */
  export type CourseModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModules to delete
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to delete.
     */
    limit?: number
  }

  /**
   * CourseModule.units
   */
  export type CourseModule$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    where?: ContentUnitWhereInput
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    cursor?: ContentUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * CourseModule.quizzes
   */
  export type CourseModule$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * CourseModule.exercises
   */
  export type CourseModule$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * CourseModule.userProgress
   */
  export type CourseModule$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    where?: ModuleProgressWhereInput
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    cursor?: ModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * CourseModule.flashcards
   */
  export type CourseModule$flashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    where?: FlashcardWhereInput
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    cursor?: FlashcardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * CourseModule.chatbotMessages
   */
  export type CourseModule$chatbotMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    where?: ChatbotMessageWhereInput
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    cursor?: ChatbotMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * CourseModule without action
   */
  export type CourseModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
  }


  /**
   * Model ContentUnit
   */

  export type AggregateContentUnit = {
    _count: ContentUnitCountAggregateOutputType | null
    _avg: ContentUnitAvgAggregateOutputType | null
    _sum: ContentUnitSumAggregateOutputType | null
    _min: ContentUnitMinAggregateOutputType | null
    _max: ContentUnitMaxAggregateOutputType | null
  }

  export type ContentUnitAvgAggregateOutputType = {
    id: number | null
    moduleId: number | null
    orderNumber: number | null
    estimatedMinutes: number | null
  }

  export type ContentUnitSumAggregateOutputType = {
    id: number | null
    moduleId: number | null
    orderNumber: number | null
    estimatedMinutes: number | null
  }

  export type ContentUnitMinAggregateOutputType = {
    id: number | null
    moduleId: number | null
    title: string | null
    description: string | null
    contentType: $Enums.ContentType | null
    orderNumber: number | null
    estimatedMinutes: number | null
    isRequired: boolean | null
    textContent: string | null
    videoUrl: string | null
    audioUrl: string | null
    fileUrl: string | null
    externalUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentUnitMaxAggregateOutputType = {
    id: number | null
    moduleId: number | null
    title: string | null
    description: string | null
    contentType: $Enums.ContentType | null
    orderNumber: number | null
    estimatedMinutes: number | null
    isRequired: boolean | null
    textContent: string | null
    videoUrl: string | null
    audioUrl: string | null
    fileUrl: string | null
    externalUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentUnitCountAggregateOutputType = {
    id: number
    moduleId: number
    title: number
    description: number
    contentType: number
    orderNumber: number
    estimatedMinutes: number
    isRequired: number
    textContent: number
    videoUrl: number
    audioUrl: number
    fileUrl: number
    externalUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentUnitAvgAggregateInputType = {
    id?: true
    moduleId?: true
    orderNumber?: true
    estimatedMinutes?: true
  }

  export type ContentUnitSumAggregateInputType = {
    id?: true
    moduleId?: true
    orderNumber?: true
    estimatedMinutes?: true
  }

  export type ContentUnitMinAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    contentType?: true
    orderNumber?: true
    estimatedMinutes?: true
    isRequired?: true
    textContent?: true
    videoUrl?: true
    audioUrl?: true
    fileUrl?: true
    externalUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentUnitMaxAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    contentType?: true
    orderNumber?: true
    estimatedMinutes?: true
    isRequired?: true
    textContent?: true
    videoUrl?: true
    audioUrl?: true
    fileUrl?: true
    externalUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentUnitCountAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    contentType?: true
    orderNumber?: true
    estimatedMinutes?: true
    isRequired?: true
    textContent?: true
    videoUrl?: true
    audioUrl?: true
    fileUrl?: true
    externalUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentUnit to aggregate.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentUnits
    **/
    _count?: true | ContentUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentUnitMaxAggregateInputType
  }

  export type GetContentUnitAggregateType<T extends ContentUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateContentUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentUnit[P]>
      : GetScalarType<T[P], AggregateContentUnit[P]>
  }




  export type ContentUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentUnitWhereInput
    orderBy?: ContentUnitOrderByWithAggregationInput | ContentUnitOrderByWithAggregationInput[]
    by: ContentUnitScalarFieldEnum[] | ContentUnitScalarFieldEnum
    having?: ContentUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentUnitCountAggregateInputType | true
    _avg?: ContentUnitAvgAggregateInputType
    _sum?: ContentUnitSumAggregateInputType
    _min?: ContentUnitMinAggregateInputType
    _max?: ContentUnitMaxAggregateInputType
  }

  export type ContentUnitGroupByOutputType = {
    id: number
    moduleId: number
    title: string
    description: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes: number | null
    isRequired: boolean
    textContent: string | null
    videoUrl: string | null
    audioUrl: string | null
    fileUrl: string | null
    externalUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContentUnitCountAggregateOutputType | null
    _avg: ContentUnitAvgAggregateOutputType | null
    _sum: ContentUnitSumAggregateOutputType | null
    _min: ContentUnitMinAggregateOutputType | null
    _max: ContentUnitMaxAggregateOutputType | null
  }

  type GetContentUnitGroupByPayload<T extends ContentUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentUnitGroupByOutputType[P]>
            : GetScalarType<T[P], ContentUnitGroupByOutputType[P]>
        }
      >
    >


  export type ContentUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    orderNumber?: boolean
    estimatedMinutes?: boolean
    isRequired?: boolean
    textContent?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    externalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    progress?: boolean | ContentUnit$progressArgs<ExtArgs>
    attachments?: boolean | ContentUnit$attachmentsArgs<ExtArgs>
    _count?: boolean | ContentUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentUnit"]>

  export type ContentUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    orderNumber?: boolean
    estimatedMinutes?: boolean
    isRequired?: boolean
    textContent?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    externalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentUnit"]>

  export type ContentUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    orderNumber?: boolean
    estimatedMinutes?: boolean
    isRequired?: boolean
    textContent?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    externalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentUnit"]>

  export type ContentUnitSelectScalar = {
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    orderNumber?: boolean
    estimatedMinutes?: boolean
    isRequired?: boolean
    textContent?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    externalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "title" | "description" | "contentType" | "orderNumber" | "estimatedMinutes" | "isRequired" | "textContent" | "videoUrl" | "audioUrl" | "fileUrl" | "externalUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["contentUnit"]>
  export type ContentUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    progress?: boolean | ContentUnit$progressArgs<ExtArgs>
    attachments?: boolean | ContentUnit$attachmentsArgs<ExtArgs>
    _count?: boolean | ContentUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type ContentUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $ContentUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentUnit"
    objects: {
      module: Prisma.$CourseModulePayload<ExtArgs>
      progress: Prisma.$UnitProgressPayload<ExtArgs>[]
      attachments: Prisma.$UnitAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      moduleId: number
      title: string
      description: string | null
      contentType: $Enums.ContentType
      orderNumber: number
      estimatedMinutes: number | null
      isRequired: boolean
      textContent: string | null
      videoUrl: string | null
      audioUrl: string | null
      fileUrl: string | null
      externalUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentUnit"]>
    composites: {}
  }

  type ContentUnitGetPayload<S extends boolean | null | undefined | ContentUnitDefaultArgs> = $Result.GetResult<Prisma.$ContentUnitPayload, S>

  type ContentUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentUnitCountAggregateInputType | true
    }

  export interface ContentUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentUnit'], meta: { name: 'ContentUnit' } }
    /**
     * Find zero or one ContentUnit that matches the filter.
     * @param {ContentUnitFindUniqueArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentUnitFindUniqueArgs>(args: SelectSubset<T, ContentUnitFindUniqueArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentUnitFindUniqueOrThrowArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitFindFirstArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentUnitFindFirstArgs>(args?: SelectSubset<T, ContentUnitFindFirstArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitFindFirstOrThrowArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentUnits
     * const contentUnits = await prisma.contentUnit.findMany()
     * 
     * // Get first 10 ContentUnits
     * const contentUnits = await prisma.contentUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentUnitWithIdOnly = await prisma.contentUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentUnitFindManyArgs>(args?: SelectSubset<T, ContentUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentUnit.
     * @param {ContentUnitCreateArgs} args - Arguments to create a ContentUnit.
     * @example
     * // Create one ContentUnit
     * const ContentUnit = await prisma.contentUnit.create({
     *   data: {
     *     // ... data to create a ContentUnit
     *   }
     * })
     * 
     */
    create<T extends ContentUnitCreateArgs>(args: SelectSubset<T, ContentUnitCreateArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentUnits.
     * @param {ContentUnitCreateManyArgs} args - Arguments to create many ContentUnits.
     * @example
     * // Create many ContentUnits
     * const contentUnit = await prisma.contentUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentUnitCreateManyArgs>(args?: SelectSubset<T, ContentUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentUnits and returns the data saved in the database.
     * @param {ContentUnitCreateManyAndReturnArgs} args - Arguments to create many ContentUnits.
     * @example
     * // Create many ContentUnits
     * const contentUnit = await prisma.contentUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentUnits and only return the `id`
     * const contentUnitWithIdOnly = await prisma.contentUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentUnit.
     * @param {ContentUnitDeleteArgs} args - Arguments to delete one ContentUnit.
     * @example
     * // Delete one ContentUnit
     * const ContentUnit = await prisma.contentUnit.delete({
     *   where: {
     *     // ... filter to delete one ContentUnit
     *   }
     * })
     * 
     */
    delete<T extends ContentUnitDeleteArgs>(args: SelectSubset<T, ContentUnitDeleteArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentUnit.
     * @param {ContentUnitUpdateArgs} args - Arguments to update one ContentUnit.
     * @example
     * // Update one ContentUnit
     * const contentUnit = await prisma.contentUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUnitUpdateArgs>(args: SelectSubset<T, ContentUnitUpdateArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentUnits.
     * @param {ContentUnitDeleteManyArgs} args - Arguments to filter ContentUnits to delete.
     * @example
     * // Delete a few ContentUnits
     * const { count } = await prisma.contentUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentUnitDeleteManyArgs>(args?: SelectSubset<T, ContentUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentUnits
     * const contentUnit = await prisma.contentUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUnitUpdateManyArgs>(args: SelectSubset<T, ContentUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentUnits and returns the data updated in the database.
     * @param {ContentUnitUpdateManyAndReturnArgs} args - Arguments to update many ContentUnits.
     * @example
     * // Update many ContentUnits
     * const contentUnit = await prisma.contentUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentUnits and only return the `id`
     * const contentUnitWithIdOnly = await prisma.contentUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentUnit.
     * @param {ContentUnitUpsertArgs} args - Arguments to update or create a ContentUnit.
     * @example
     * // Update or create a ContentUnit
     * const contentUnit = await prisma.contentUnit.upsert({
     *   create: {
     *     // ... data to create a ContentUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentUnit we want to update
     *   }
     * })
     */
    upsert<T extends ContentUnitUpsertArgs>(args: SelectSubset<T, ContentUnitUpsertArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitCountArgs} args - Arguments to filter ContentUnits to count.
     * @example
     * // Count the number of ContentUnits
     * const count = await prisma.contentUnit.count({
     *   where: {
     *     // ... the filter for the ContentUnits we want to count
     *   }
     * })
    **/
    count<T extends ContentUnitCountArgs>(
      args?: Subset<T, ContentUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentUnitAggregateArgs>(args: Subset<T, ContentUnitAggregateArgs>): Prisma.PrismaPromise<GetContentUnitAggregateType<T>>

    /**
     * Group by ContentUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentUnitGroupByArgs['orderBy'] }
        : { orderBy?: ContentUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentUnit model
   */
  readonly fields: ContentUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    progress<T extends ContentUnit$progressArgs<ExtArgs> = {}>(args?: Subset<T, ContentUnit$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends ContentUnit$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, ContentUnit$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentUnit model
   */
  interface ContentUnitFieldRefs {
    readonly id: FieldRef<"ContentUnit", 'Int'>
    readonly moduleId: FieldRef<"ContentUnit", 'Int'>
    readonly title: FieldRef<"ContentUnit", 'String'>
    readonly description: FieldRef<"ContentUnit", 'String'>
    readonly contentType: FieldRef<"ContentUnit", 'ContentType'>
    readonly orderNumber: FieldRef<"ContentUnit", 'Int'>
    readonly estimatedMinutes: FieldRef<"ContentUnit", 'Int'>
    readonly isRequired: FieldRef<"ContentUnit", 'Boolean'>
    readonly textContent: FieldRef<"ContentUnit", 'String'>
    readonly videoUrl: FieldRef<"ContentUnit", 'String'>
    readonly audioUrl: FieldRef<"ContentUnit", 'String'>
    readonly fileUrl: FieldRef<"ContentUnit", 'String'>
    readonly externalUrl: FieldRef<"ContentUnit", 'String'>
    readonly createdAt: FieldRef<"ContentUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentUnit findUnique
   */
  export type ContentUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit findUniqueOrThrow
   */
  export type ContentUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit findFirst
   */
  export type ContentUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentUnits.
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentUnits.
     */
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentUnit findFirstOrThrow
   */
  export type ContentUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentUnits.
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentUnits.
     */
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentUnit findMany
   */
  export type ContentUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnits to fetch.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentUnits.
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentUnit create
   */
  export type ContentUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentUnit.
     */
    data: XOR<ContentUnitCreateInput, ContentUnitUncheckedCreateInput>
  }

  /**
   * ContentUnit createMany
   */
  export type ContentUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentUnits.
     */
    data: ContentUnitCreateManyInput | ContentUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentUnit createManyAndReturn
   */
  export type ContentUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * The data used to create many ContentUnits.
     */
    data: ContentUnitCreateManyInput | ContentUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentUnit update
   */
  export type ContentUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentUnit.
     */
    data: XOR<ContentUnitUpdateInput, ContentUnitUncheckedUpdateInput>
    /**
     * Choose, which ContentUnit to update.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit updateMany
   */
  export type ContentUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentUnits.
     */
    data: XOR<ContentUnitUpdateManyMutationInput, ContentUnitUncheckedUpdateManyInput>
    /**
     * Filter which ContentUnits to update
     */
    where?: ContentUnitWhereInput
    /**
     * Limit how many ContentUnits to update.
     */
    limit?: number
  }

  /**
   * ContentUnit updateManyAndReturn
   */
  export type ContentUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * The data used to update ContentUnits.
     */
    data: XOR<ContentUnitUpdateManyMutationInput, ContentUnitUncheckedUpdateManyInput>
    /**
     * Filter which ContentUnits to update
     */
    where?: ContentUnitWhereInput
    /**
     * Limit how many ContentUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentUnit upsert
   */
  export type ContentUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentUnit to update in case it exists.
     */
    where: ContentUnitWhereUniqueInput
    /**
     * In case the ContentUnit found by the `where` argument doesn't exist, create a new ContentUnit with this data.
     */
    create: XOR<ContentUnitCreateInput, ContentUnitUncheckedCreateInput>
    /**
     * In case the ContentUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUnitUpdateInput, ContentUnitUncheckedUpdateInput>
  }

  /**
   * ContentUnit delete
   */
  export type ContentUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter which ContentUnit to delete.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit deleteMany
   */
  export type ContentUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentUnits to delete
     */
    where?: ContentUnitWhereInput
    /**
     * Limit how many ContentUnits to delete.
     */
    limit?: number
  }

  /**
   * ContentUnit.progress
   */
  export type ContentUnit$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    where?: UnitProgressWhereInput
    orderBy?: UnitProgressOrderByWithRelationInput | UnitProgressOrderByWithRelationInput[]
    cursor?: UnitProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitProgressScalarFieldEnum | UnitProgressScalarFieldEnum[]
  }

  /**
   * ContentUnit.attachments
   */
  export type ContentUnit$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    where?: UnitAttachmentWhereInput
    orderBy?: UnitAttachmentOrderByWithRelationInput | UnitAttachmentOrderByWithRelationInput[]
    cursor?: UnitAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitAttachmentScalarFieldEnum | UnitAttachmentScalarFieldEnum[]
  }

  /**
   * ContentUnit without action
   */
  export type ContentUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
  }


  /**
   * Model UnitAttachment
   */

  export type AggregateUnitAttachment = {
    _count: UnitAttachmentCountAggregateOutputType | null
    _avg: UnitAttachmentAvgAggregateOutputType | null
    _sum: UnitAttachmentSumAggregateOutputType | null
    _min: UnitAttachmentMinAggregateOutputType | null
    _max: UnitAttachmentMaxAggregateOutputType | null
  }

  export type UnitAttachmentAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
  }

  export type UnitAttachmentSumAggregateOutputType = {
    id: number | null
    unitId: number | null
  }

  export type UnitAttachmentMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
  }

  export type UnitAttachmentMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
  }

  export type UnitAttachmentCountAggregateOutputType = {
    id: number
    unitId: number
    title: number
    description: number
    fileUrl: number
    fileType: number
    _all: number
  }


  export type UnitAttachmentAvgAggregateInputType = {
    id?: true
    unitId?: true
  }

  export type UnitAttachmentSumAggregateInputType = {
    id?: true
    unitId?: true
  }

  export type UnitAttachmentMinAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
  }

  export type UnitAttachmentMaxAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
  }

  export type UnitAttachmentCountAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    _all?: true
  }

  export type UnitAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAttachment to aggregate.
     */
    where?: UnitAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAttachments to fetch.
     */
    orderBy?: UnitAttachmentOrderByWithRelationInput | UnitAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitAttachments
    **/
    _count?: true | UnitAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitAttachmentMaxAggregateInputType
  }

  export type GetUnitAttachmentAggregateType<T extends UnitAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitAttachment[P]>
      : GetScalarType<T[P], AggregateUnitAttachment[P]>
  }




  export type UnitAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAttachmentWhereInput
    orderBy?: UnitAttachmentOrderByWithAggregationInput | UnitAttachmentOrderByWithAggregationInput[]
    by: UnitAttachmentScalarFieldEnum[] | UnitAttachmentScalarFieldEnum
    having?: UnitAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitAttachmentCountAggregateInputType | true
    _avg?: UnitAttachmentAvgAggregateInputType
    _sum?: UnitAttachmentSumAggregateInputType
    _min?: UnitAttachmentMinAggregateInputType
    _max?: UnitAttachmentMaxAggregateInputType
  }

  export type UnitAttachmentGroupByOutputType = {
    id: number
    unitId: number
    title: string
    description: string | null
    fileUrl: string
    fileType: string
    _count: UnitAttachmentCountAggregateOutputType | null
    _avg: UnitAttachmentAvgAggregateOutputType | null
    _sum: UnitAttachmentSumAggregateOutputType | null
    _min: UnitAttachmentMinAggregateOutputType | null
    _max: UnitAttachmentMaxAggregateOutputType | null
  }

  type GetUnitAttachmentGroupByPayload<T extends UnitAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], UnitAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type UnitAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAttachment"]>

  export type UnitAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAttachment"]>

  export type UnitAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAttachment"]>

  export type UnitAttachmentSelectScalar = {
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
  }

  export type UnitAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "title" | "description" | "fileUrl" | "fileType", ExtArgs["result"]["unitAttachment"]>
  export type UnitAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }
  export type UnitAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }
  export type UnitAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }

  export type $UnitAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitAttachment"
    objects: {
      unit: Prisma.$ContentUnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      title: string
      description: string | null
      fileUrl: string
      fileType: string
    }, ExtArgs["result"]["unitAttachment"]>
    composites: {}
  }

  type UnitAttachmentGetPayload<S extends boolean | null | undefined | UnitAttachmentDefaultArgs> = $Result.GetResult<Prisma.$UnitAttachmentPayload, S>

  type UnitAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitAttachmentCountAggregateInputType | true
    }

  export interface UnitAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitAttachment'], meta: { name: 'UnitAttachment' } }
    /**
     * Find zero or one UnitAttachment that matches the filter.
     * @param {UnitAttachmentFindUniqueArgs} args - Arguments to find a UnitAttachment
     * @example
     * // Get one UnitAttachment
     * const unitAttachment = await prisma.unitAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitAttachmentFindUniqueArgs>(args: SelectSubset<T, UnitAttachmentFindUniqueArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitAttachmentFindUniqueOrThrowArgs} args - Arguments to find a UnitAttachment
     * @example
     * // Get one UnitAttachment
     * const unitAttachment = await prisma.unitAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentFindFirstArgs} args - Arguments to find a UnitAttachment
     * @example
     * // Get one UnitAttachment
     * const unitAttachment = await prisma.unitAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitAttachmentFindFirstArgs>(args?: SelectSubset<T, UnitAttachmentFindFirstArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentFindFirstOrThrowArgs} args - Arguments to find a UnitAttachment
     * @example
     * // Get one UnitAttachment
     * const unitAttachment = await prisma.unitAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitAttachments
     * const unitAttachments = await prisma.unitAttachment.findMany()
     * 
     * // Get first 10 UnitAttachments
     * const unitAttachments = await prisma.unitAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitAttachmentWithIdOnly = await prisma.unitAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitAttachmentFindManyArgs>(args?: SelectSubset<T, UnitAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitAttachment.
     * @param {UnitAttachmentCreateArgs} args - Arguments to create a UnitAttachment.
     * @example
     * // Create one UnitAttachment
     * const UnitAttachment = await prisma.unitAttachment.create({
     *   data: {
     *     // ... data to create a UnitAttachment
     *   }
     * })
     * 
     */
    create<T extends UnitAttachmentCreateArgs>(args: SelectSubset<T, UnitAttachmentCreateArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitAttachments.
     * @param {UnitAttachmentCreateManyArgs} args - Arguments to create many UnitAttachments.
     * @example
     * // Create many UnitAttachments
     * const unitAttachment = await prisma.unitAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitAttachmentCreateManyArgs>(args?: SelectSubset<T, UnitAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitAttachments and returns the data saved in the database.
     * @param {UnitAttachmentCreateManyAndReturnArgs} args - Arguments to create many UnitAttachments.
     * @example
     * // Create many UnitAttachments
     * const unitAttachment = await prisma.unitAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitAttachments and only return the `id`
     * const unitAttachmentWithIdOnly = await prisma.unitAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitAttachment.
     * @param {UnitAttachmentDeleteArgs} args - Arguments to delete one UnitAttachment.
     * @example
     * // Delete one UnitAttachment
     * const UnitAttachment = await prisma.unitAttachment.delete({
     *   where: {
     *     // ... filter to delete one UnitAttachment
     *   }
     * })
     * 
     */
    delete<T extends UnitAttachmentDeleteArgs>(args: SelectSubset<T, UnitAttachmentDeleteArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitAttachment.
     * @param {UnitAttachmentUpdateArgs} args - Arguments to update one UnitAttachment.
     * @example
     * // Update one UnitAttachment
     * const unitAttachment = await prisma.unitAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitAttachmentUpdateArgs>(args: SelectSubset<T, UnitAttachmentUpdateArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitAttachments.
     * @param {UnitAttachmentDeleteManyArgs} args - Arguments to filter UnitAttachments to delete.
     * @example
     * // Delete a few UnitAttachments
     * const { count } = await prisma.unitAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitAttachmentDeleteManyArgs>(args?: SelectSubset<T, UnitAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitAttachments
     * const unitAttachment = await prisma.unitAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitAttachmentUpdateManyArgs>(args: SelectSubset<T, UnitAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAttachments and returns the data updated in the database.
     * @param {UnitAttachmentUpdateManyAndReturnArgs} args - Arguments to update many UnitAttachments.
     * @example
     * // Update many UnitAttachments
     * const unitAttachment = await prisma.unitAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitAttachments and only return the `id`
     * const unitAttachmentWithIdOnly = await prisma.unitAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitAttachment.
     * @param {UnitAttachmentUpsertArgs} args - Arguments to update or create a UnitAttachment.
     * @example
     * // Update or create a UnitAttachment
     * const unitAttachment = await prisma.unitAttachment.upsert({
     *   create: {
     *     // ... data to create a UnitAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitAttachment we want to update
     *   }
     * })
     */
    upsert<T extends UnitAttachmentUpsertArgs>(args: SelectSubset<T, UnitAttachmentUpsertArgs<ExtArgs>>): Prisma__UnitAttachmentClient<$Result.GetResult<Prisma.$UnitAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentCountArgs} args - Arguments to filter UnitAttachments to count.
     * @example
     * // Count the number of UnitAttachments
     * const count = await prisma.unitAttachment.count({
     *   where: {
     *     // ... the filter for the UnitAttachments we want to count
     *   }
     * })
    **/
    count<T extends UnitAttachmentCountArgs>(
      args?: Subset<T, UnitAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAttachmentAggregateArgs>(args: Subset<T, UnitAttachmentAggregateArgs>): Prisma.PrismaPromise<GetUnitAttachmentAggregateType<T>>

    /**
     * Group by UnitAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: UnitAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitAttachment model
   */
  readonly fields: UnitAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends ContentUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentUnitDefaultArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitAttachment model
   */
  interface UnitAttachmentFieldRefs {
    readonly id: FieldRef<"UnitAttachment", 'Int'>
    readonly unitId: FieldRef<"UnitAttachment", 'Int'>
    readonly title: FieldRef<"UnitAttachment", 'String'>
    readonly description: FieldRef<"UnitAttachment", 'String'>
    readonly fileUrl: FieldRef<"UnitAttachment", 'String'>
    readonly fileType: FieldRef<"UnitAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnitAttachment findUnique
   */
  export type UnitAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitAttachment to fetch.
     */
    where: UnitAttachmentWhereUniqueInput
  }

  /**
   * UnitAttachment findUniqueOrThrow
   */
  export type UnitAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitAttachment to fetch.
     */
    where: UnitAttachmentWhereUniqueInput
  }

  /**
   * UnitAttachment findFirst
   */
  export type UnitAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitAttachment to fetch.
     */
    where?: UnitAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAttachments to fetch.
     */
    orderBy?: UnitAttachmentOrderByWithRelationInput | UnitAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAttachments.
     */
    cursor?: UnitAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAttachments.
     */
    distinct?: UnitAttachmentScalarFieldEnum | UnitAttachmentScalarFieldEnum[]
  }

  /**
   * UnitAttachment findFirstOrThrow
   */
  export type UnitAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitAttachment to fetch.
     */
    where?: UnitAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAttachments to fetch.
     */
    orderBy?: UnitAttachmentOrderByWithRelationInput | UnitAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAttachments.
     */
    cursor?: UnitAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAttachments.
     */
    distinct?: UnitAttachmentScalarFieldEnum | UnitAttachmentScalarFieldEnum[]
  }

  /**
   * UnitAttachment findMany
   */
  export type UnitAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which UnitAttachments to fetch.
     */
    where?: UnitAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAttachments to fetch.
     */
    orderBy?: UnitAttachmentOrderByWithRelationInput | UnitAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitAttachments.
     */
    cursor?: UnitAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAttachments.
     */
    skip?: number
    distinct?: UnitAttachmentScalarFieldEnum | UnitAttachmentScalarFieldEnum[]
  }

  /**
   * UnitAttachment create
   */
  export type UnitAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitAttachment.
     */
    data: XOR<UnitAttachmentCreateInput, UnitAttachmentUncheckedCreateInput>
  }

  /**
   * UnitAttachment createMany
   */
  export type UnitAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitAttachments.
     */
    data: UnitAttachmentCreateManyInput | UnitAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitAttachment createManyAndReturn
   */
  export type UnitAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many UnitAttachments.
     */
    data: UnitAttachmentCreateManyInput | UnitAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAttachment update
   */
  export type UnitAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitAttachment.
     */
    data: XOR<UnitAttachmentUpdateInput, UnitAttachmentUncheckedUpdateInput>
    /**
     * Choose, which UnitAttachment to update.
     */
    where: UnitAttachmentWhereUniqueInput
  }

  /**
   * UnitAttachment updateMany
   */
  export type UnitAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitAttachments.
     */
    data: XOR<UnitAttachmentUpdateManyMutationInput, UnitAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which UnitAttachments to update
     */
    where?: UnitAttachmentWhereInput
    /**
     * Limit how many UnitAttachments to update.
     */
    limit?: number
  }

  /**
   * UnitAttachment updateManyAndReturn
   */
  export type UnitAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update UnitAttachments.
     */
    data: XOR<UnitAttachmentUpdateManyMutationInput, UnitAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which UnitAttachments to update
     */
    where?: UnitAttachmentWhereInput
    /**
     * Limit how many UnitAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAttachment upsert
   */
  export type UnitAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitAttachment to update in case it exists.
     */
    where: UnitAttachmentWhereUniqueInput
    /**
     * In case the UnitAttachment found by the `where` argument doesn't exist, create a new UnitAttachment with this data.
     */
    create: XOR<UnitAttachmentCreateInput, UnitAttachmentUncheckedCreateInput>
    /**
     * In case the UnitAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitAttachmentUpdateInput, UnitAttachmentUncheckedUpdateInput>
  }

  /**
   * UnitAttachment delete
   */
  export type UnitAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
    /**
     * Filter which UnitAttachment to delete.
     */
    where: UnitAttachmentWhereUniqueInput
  }

  /**
   * UnitAttachment deleteMany
   */
  export type UnitAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAttachments to delete
     */
    where?: UnitAttachmentWhereInput
    /**
     * Limit how many UnitAttachments to delete.
     */
    limit?: number
  }

  /**
   * UnitAttachment without action
   */
  export type UnitAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAttachment
     */
    select?: UnitAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAttachment
     */
    omit?: UnitAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progressPercentage: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progressPercentage: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    enrollmentDate: Date | null
    status: $Enums.EnrollmentStatus | null
    completionDate: Date | null
    progressPercentage: number | null
    lastAccessedAt: Date | null
    unenrollmentDate: Date | null
    unenrollmentReason: string | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    enrollmentDate: Date | null
    status: $Enums.EnrollmentStatus | null
    completionDate: Date | null
    progressPercentage: number | null
    lastAccessedAt: Date | null
    unenrollmentDate: Date | null
    unenrollmentReason: string | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    enrollmentDate: number
    status: number
    completionDate: number
    progressPercentage: number
    lastAccessedAt: number
    unenrollmentDate: number
    unenrollmentReason: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progressPercentage?: true
  }

  export type EnrollmentSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progressPercentage?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrollmentDate?: true
    status?: true
    completionDate?: true
    progressPercentage?: true
    lastAccessedAt?: true
    unenrollmentDate?: true
    unenrollmentReason?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrollmentDate?: true
    status?: true
    completionDate?: true
    progressPercentage?: true
    lastAccessedAt?: true
    unenrollmentDate?: true
    unenrollmentReason?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrollmentDate?: true
    status?: true
    completionDate?: true
    progressPercentage?: true
    lastAccessedAt?: true
    unenrollmentDate?: true
    unenrollmentReason?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    enrollmentDate: Date
    status: $Enums.EnrollmentStatus
    completionDate: Date | null
    progressPercentage: number
    lastAccessedAt: Date | null
    unenrollmentDate: Date | null
    unenrollmentReason: string | null
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    completionDate?: boolean
    progressPercentage?: boolean
    lastAccessedAt?: boolean
    unenrollmentDate?: boolean
    unenrollmentReason?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    moduleProgress?: boolean | Enrollment$moduleProgressArgs<ExtArgs>
    unitProgress?: boolean | Enrollment$unitProgressArgs<ExtArgs>
    quizAttempts?: boolean | Enrollment$quizAttemptsArgs<ExtArgs>
    exerciseSubmissions?: boolean | Enrollment$exerciseSubmissionsArgs<ExtArgs>
    _count?: boolean | EnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    completionDate?: boolean
    progressPercentage?: boolean
    lastAccessedAt?: boolean
    unenrollmentDate?: boolean
    unenrollmentReason?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    completionDate?: boolean
    progressPercentage?: boolean
    lastAccessedAt?: boolean
    unenrollmentDate?: boolean
    unenrollmentReason?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    completionDate?: boolean
    progressPercentage?: boolean
    lastAccessedAt?: boolean
    unenrollmentDate?: boolean
    unenrollmentReason?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "enrollmentDate" | "status" | "completionDate" | "progressPercentage" | "lastAccessedAt" | "unenrollmentDate" | "unenrollmentReason", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    moduleProgress?: boolean | Enrollment$moduleProgressArgs<ExtArgs>
    unitProgress?: boolean | Enrollment$unitProgressArgs<ExtArgs>
    quizAttempts?: boolean | Enrollment$quizAttemptsArgs<ExtArgs>
    exerciseSubmissions?: boolean | Enrollment$exerciseSubmissionsArgs<ExtArgs>
    _count?: boolean | EnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      moduleProgress: Prisma.$ModuleProgressPayload<ExtArgs>[]
      unitProgress: Prisma.$UnitProgressPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      exerciseSubmissions: Prisma.$ExerciseSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      enrollmentDate: Date
      status: $Enums.EnrollmentStatus
      completionDate: Date | null
      progressPercentage: number
      lastAccessedAt: Date | null
      unenrollmentDate: Date | null
      unenrollmentReason: string | null
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    moduleProgress<T extends Enrollment$moduleProgressArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$moduleProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitProgress<T extends Enrollment$unitProgressArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$unitProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAttempts<T extends Enrollment$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exerciseSubmissions<T extends Enrollment$exerciseSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$exerciseSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'Int'>
    readonly userId: FieldRef<"Enrollment", 'Int'>
    readonly courseId: FieldRef<"Enrollment", 'Int'>
    readonly enrollmentDate: FieldRef<"Enrollment", 'DateTime'>
    readonly status: FieldRef<"Enrollment", 'EnrollmentStatus'>
    readonly completionDate: FieldRef<"Enrollment", 'DateTime'>
    readonly progressPercentage: FieldRef<"Enrollment", 'Int'>
    readonly lastAccessedAt: FieldRef<"Enrollment", 'DateTime'>
    readonly unenrollmentDate: FieldRef<"Enrollment", 'DateTime'>
    readonly unenrollmentReason: FieldRef<"Enrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment.moduleProgress
   */
  export type Enrollment$moduleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    where?: ModuleProgressWhereInput
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    cursor?: ModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * Enrollment.unitProgress
   */
  export type Enrollment$unitProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    where?: UnitProgressWhereInput
    orderBy?: UnitProgressOrderByWithRelationInput | UnitProgressOrderByWithRelationInput[]
    cursor?: UnitProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitProgressScalarFieldEnum | UnitProgressScalarFieldEnum[]
  }

  /**
   * Enrollment.quizAttempts
   */
  export type Enrollment$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Enrollment.exerciseSubmissions
   */
  export type Enrollment$exerciseSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    cursor?: ExerciseSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model ModuleProgress
   */

  export type AggregateModuleProgress = {
    _count: ModuleProgressCountAggregateOutputType | null
    _avg: ModuleProgressAvgAggregateOutputType | null
    _sum: ModuleProgressSumAggregateOutputType | null
    _min: ModuleProgressMinAggregateOutputType | null
    _max: ModuleProgressMaxAggregateOutputType | null
  }

  export type ModuleProgressAvgAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    moduleId: number | null
    userId: number | null
    progressPercentage: number | null
  }

  export type ModuleProgressSumAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    moduleId: number | null
    userId: number | null
    progressPercentage: number | null
  }

  export type ModuleProgressMinAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    moduleId: number | null
    userId: number | null
    startedAt: Date | null
    completedAt: Date | null
    progressPercentage: number | null
  }

  export type ModuleProgressMaxAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    moduleId: number | null
    userId: number | null
    startedAt: Date | null
    completedAt: Date | null
    progressPercentage: number | null
  }

  export type ModuleProgressCountAggregateOutputType = {
    id: number
    enrollmentId: number
    moduleId: number
    userId: number
    startedAt: number
    completedAt: number
    progressPercentage: number
    _all: number
  }


  export type ModuleProgressAvgAggregateInputType = {
    id?: true
    enrollmentId?: true
    moduleId?: true
    userId?: true
    progressPercentage?: true
  }

  export type ModuleProgressSumAggregateInputType = {
    id?: true
    enrollmentId?: true
    moduleId?: true
    userId?: true
    progressPercentage?: true
  }

  export type ModuleProgressMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    moduleId?: true
    userId?: true
    startedAt?: true
    completedAt?: true
    progressPercentage?: true
  }

  export type ModuleProgressMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    moduleId?: true
    userId?: true
    startedAt?: true
    completedAt?: true
    progressPercentage?: true
  }

  export type ModuleProgressCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    moduleId?: true
    userId?: true
    startedAt?: true
    completedAt?: true
    progressPercentage?: true
    _all?: true
  }

  export type ModuleProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleProgress to aggregate.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleProgresses
    **/
    _count?: true | ModuleProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleProgressMaxAggregateInputType
  }

  export type GetModuleProgressAggregateType<T extends ModuleProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleProgress[P]>
      : GetScalarType<T[P], AggregateModuleProgress[P]>
  }




  export type ModuleProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleProgressWhereInput
    orderBy?: ModuleProgressOrderByWithAggregationInput | ModuleProgressOrderByWithAggregationInput[]
    by: ModuleProgressScalarFieldEnum[] | ModuleProgressScalarFieldEnum
    having?: ModuleProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleProgressCountAggregateInputType | true
    _avg?: ModuleProgressAvgAggregateInputType
    _sum?: ModuleProgressSumAggregateInputType
    _min?: ModuleProgressMinAggregateInputType
    _max?: ModuleProgressMaxAggregateInputType
  }

  export type ModuleProgressGroupByOutputType = {
    id: number
    enrollmentId: number
    moduleId: number
    userId: number
    startedAt: Date
    completedAt: Date | null
    progressPercentage: number
    _count: ModuleProgressCountAggregateOutputType | null
    _avg: ModuleProgressAvgAggregateOutputType | null
    _sum: ModuleProgressSumAggregateOutputType | null
    _min: ModuleProgressMinAggregateOutputType | null
    _max: ModuleProgressMaxAggregateOutputType | null
  }

  type GetModuleProgressGroupByPayload<T extends ModuleProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleProgressGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleProgressGroupByOutputType[P]>
        }
      >
    >


  export type ModuleProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    moduleId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progressPercentage?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleProgress"]>

  export type ModuleProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    moduleId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progressPercentage?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleProgress"]>

  export type ModuleProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    moduleId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progressPercentage?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleProgress"]>

  export type ModuleProgressSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    moduleId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    progressPercentage?: boolean
  }

  export type ModuleProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "moduleId" | "userId" | "startedAt" | "completedAt" | "progressPercentage", ExtArgs["result"]["moduleProgress"]>
  export type ModuleProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type ModuleProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type ModuleProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $ModuleProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleProgress"
    objects: {
      enrollment: Prisma.$EnrollmentPayload<ExtArgs>
      module: Prisma.$CourseModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enrollmentId: number
      moduleId: number
      userId: number
      startedAt: Date
      completedAt: Date | null
      progressPercentage: number
    }, ExtArgs["result"]["moduleProgress"]>
    composites: {}
  }

  type ModuleProgressGetPayload<S extends boolean | null | undefined | ModuleProgressDefaultArgs> = $Result.GetResult<Prisma.$ModuleProgressPayload, S>

  type ModuleProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleProgressCountAggregateInputType | true
    }

  export interface ModuleProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleProgress'], meta: { name: 'ModuleProgress' } }
    /**
     * Find zero or one ModuleProgress that matches the filter.
     * @param {ModuleProgressFindUniqueArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleProgressFindUniqueArgs>(args: SelectSubset<T, ModuleProgressFindUniqueArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleProgressFindUniqueOrThrowArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressFindFirstArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleProgressFindFirstArgs>(args?: SelectSubset<T, ModuleProgressFindFirstArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressFindFirstOrThrowArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleProgresses
     * const moduleProgresses = await prisma.moduleProgress.findMany()
     * 
     * // Get first 10 ModuleProgresses
     * const moduleProgresses = await prisma.moduleProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleProgressWithIdOnly = await prisma.moduleProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleProgressFindManyArgs>(args?: SelectSubset<T, ModuleProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleProgress.
     * @param {ModuleProgressCreateArgs} args - Arguments to create a ModuleProgress.
     * @example
     * // Create one ModuleProgress
     * const ModuleProgress = await prisma.moduleProgress.create({
     *   data: {
     *     // ... data to create a ModuleProgress
     *   }
     * })
     * 
     */
    create<T extends ModuleProgressCreateArgs>(args: SelectSubset<T, ModuleProgressCreateArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleProgresses.
     * @param {ModuleProgressCreateManyArgs} args - Arguments to create many ModuleProgresses.
     * @example
     * // Create many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleProgressCreateManyArgs>(args?: SelectSubset<T, ModuleProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleProgresses and returns the data saved in the database.
     * @param {ModuleProgressCreateManyAndReturnArgs} args - Arguments to create many ModuleProgresses.
     * @example
     * // Create many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleProgresses and only return the `id`
     * const moduleProgressWithIdOnly = await prisma.moduleProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleProgress.
     * @param {ModuleProgressDeleteArgs} args - Arguments to delete one ModuleProgress.
     * @example
     * // Delete one ModuleProgress
     * const ModuleProgress = await prisma.moduleProgress.delete({
     *   where: {
     *     // ... filter to delete one ModuleProgress
     *   }
     * })
     * 
     */
    delete<T extends ModuleProgressDeleteArgs>(args: SelectSubset<T, ModuleProgressDeleteArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleProgress.
     * @param {ModuleProgressUpdateArgs} args - Arguments to update one ModuleProgress.
     * @example
     * // Update one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleProgressUpdateArgs>(args: SelectSubset<T, ModuleProgressUpdateArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleProgresses.
     * @param {ModuleProgressDeleteManyArgs} args - Arguments to filter ModuleProgresses to delete.
     * @example
     * // Delete a few ModuleProgresses
     * const { count } = await prisma.moduleProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleProgressDeleteManyArgs>(args?: SelectSubset<T, ModuleProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleProgressUpdateManyArgs>(args: SelectSubset<T, ModuleProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleProgresses and returns the data updated in the database.
     * @param {ModuleProgressUpdateManyAndReturnArgs} args - Arguments to update many ModuleProgresses.
     * @example
     * // Update many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleProgresses and only return the `id`
     * const moduleProgressWithIdOnly = await prisma.moduleProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleProgress.
     * @param {ModuleProgressUpsertArgs} args - Arguments to update or create a ModuleProgress.
     * @example
     * // Update or create a ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.upsert({
     *   create: {
     *     // ... data to create a ModuleProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleProgress we want to update
     *   }
     * })
     */
    upsert<T extends ModuleProgressUpsertArgs>(args: SelectSubset<T, ModuleProgressUpsertArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressCountArgs} args - Arguments to filter ModuleProgresses to count.
     * @example
     * // Count the number of ModuleProgresses
     * const count = await prisma.moduleProgress.count({
     *   where: {
     *     // ... the filter for the ModuleProgresses we want to count
     *   }
     * })
    **/
    count<T extends ModuleProgressCountArgs>(
      args?: Subset<T, ModuleProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleProgressAggregateArgs>(args: Subset<T, ModuleProgressAggregateArgs>): Prisma.PrismaPromise<GetModuleProgressAggregateType<T>>

    /**
     * Group by ModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleProgressGroupByArgs['orderBy'] }
        : { orderBy?: ModuleProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleProgress model
   */
  readonly fields: ModuleProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends EnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnrollmentDefaultArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    module<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleProgress model
   */
  interface ModuleProgressFieldRefs {
    readonly id: FieldRef<"ModuleProgress", 'Int'>
    readonly enrollmentId: FieldRef<"ModuleProgress", 'Int'>
    readonly moduleId: FieldRef<"ModuleProgress", 'Int'>
    readonly userId: FieldRef<"ModuleProgress", 'Int'>
    readonly startedAt: FieldRef<"ModuleProgress", 'DateTime'>
    readonly completedAt: FieldRef<"ModuleProgress", 'DateTime'>
    readonly progressPercentage: FieldRef<"ModuleProgress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ModuleProgress findUnique
   */
  export type ModuleProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress findUniqueOrThrow
   */
  export type ModuleProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress findFirst
   */
  export type ModuleProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleProgresses.
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleProgresses.
     */
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * ModuleProgress findFirstOrThrow
   */
  export type ModuleProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleProgresses.
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleProgresses.
     */
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * ModuleProgress findMany
   */
  export type ModuleProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgresses to fetch.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleProgresses.
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * ModuleProgress create
   */
  export type ModuleProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleProgress.
     */
    data: XOR<ModuleProgressCreateInput, ModuleProgressUncheckedCreateInput>
  }

  /**
   * ModuleProgress createMany
   */
  export type ModuleProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleProgresses.
     */
    data: ModuleProgressCreateManyInput | ModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleProgress createManyAndReturn
   */
  export type ModuleProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleProgresses.
     */
    data: ModuleProgressCreateManyInput | ModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleProgress update
   */
  export type ModuleProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleProgress.
     */
    data: XOR<ModuleProgressUpdateInput, ModuleProgressUncheckedUpdateInput>
    /**
     * Choose, which ModuleProgress to update.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress updateMany
   */
  export type ModuleProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleProgresses.
     */
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which ModuleProgresses to update
     */
    where?: ModuleProgressWhereInput
    /**
     * Limit how many ModuleProgresses to update.
     */
    limit?: number
  }

  /**
   * ModuleProgress updateManyAndReturn
   */
  export type ModuleProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * The data used to update ModuleProgresses.
     */
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which ModuleProgresses to update
     */
    where?: ModuleProgressWhereInput
    /**
     * Limit how many ModuleProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleProgress upsert
   */
  export type ModuleProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleProgress to update in case it exists.
     */
    where: ModuleProgressWhereUniqueInput
    /**
     * In case the ModuleProgress found by the `where` argument doesn't exist, create a new ModuleProgress with this data.
     */
    create: XOR<ModuleProgressCreateInput, ModuleProgressUncheckedCreateInput>
    /**
     * In case the ModuleProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleProgressUpdateInput, ModuleProgressUncheckedUpdateInput>
  }

  /**
   * ModuleProgress delete
   */
  export type ModuleProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter which ModuleProgress to delete.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress deleteMany
   */
  export type ModuleProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleProgresses to delete
     */
    where?: ModuleProgressWhereInput
    /**
     * Limit how many ModuleProgresses to delete.
     */
    limit?: number
  }

  /**
   * ModuleProgress without action
   */
  export type ModuleProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleProgress
     */
    omit?: ModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
  }


  /**
   * Model UnitProgress
   */

  export type AggregateUnitProgress = {
    _count: UnitProgressCountAggregateOutputType | null
    _avg: UnitProgressAvgAggregateOutputType | null
    _sum: UnitProgressSumAggregateOutputType | null
    _min: UnitProgressMinAggregateOutputType | null
    _max: UnitProgressMaxAggregateOutputType | null
  }

  export type UnitProgressAvgAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    unitId: number | null
    userId: number | null
    timeSpentMinutes: number | null
  }

  export type UnitProgressSumAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    unitId: number | null
    userId: number | null
    timeSpentMinutes: number | null
  }

  export type UnitProgressMinAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    unitId: number | null
    userId: number | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpentMinutes: number | null
    lastPosition: string | null
  }

  export type UnitProgressMaxAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    unitId: number | null
    userId: number | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpentMinutes: number | null
    lastPosition: string | null
  }

  export type UnitProgressCountAggregateOutputType = {
    id: number
    enrollmentId: number
    unitId: number
    userId: number
    startedAt: number
    completedAt: number
    timeSpentMinutes: number
    lastPosition: number
    _all: number
  }


  export type UnitProgressAvgAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitId?: true
    userId?: true
    timeSpentMinutes?: true
  }

  export type UnitProgressSumAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitId?: true
    userId?: true
    timeSpentMinutes?: true
  }

  export type UnitProgressMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitId?: true
    userId?: true
    startedAt?: true
    completedAt?: true
    timeSpentMinutes?: true
    lastPosition?: true
  }

  export type UnitProgressMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitId?: true
    userId?: true
    startedAt?: true
    completedAt?: true
    timeSpentMinutes?: true
    lastPosition?: true
  }

  export type UnitProgressCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitId?: true
    userId?: true
    startedAt?: true
    completedAt?: true
    timeSpentMinutes?: true
    lastPosition?: true
    _all?: true
  }

  export type UnitProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitProgress to aggregate.
     */
    where?: UnitProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitProgresses to fetch.
     */
    orderBy?: UnitProgressOrderByWithRelationInput | UnitProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitProgresses
    **/
    _count?: true | UnitProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitProgressMaxAggregateInputType
  }

  export type GetUnitProgressAggregateType<T extends UnitProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitProgress[P]>
      : GetScalarType<T[P], AggregateUnitProgress[P]>
  }




  export type UnitProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitProgressWhereInput
    orderBy?: UnitProgressOrderByWithAggregationInput | UnitProgressOrderByWithAggregationInput[]
    by: UnitProgressScalarFieldEnum[] | UnitProgressScalarFieldEnum
    having?: UnitProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitProgressCountAggregateInputType | true
    _avg?: UnitProgressAvgAggregateInputType
    _sum?: UnitProgressSumAggregateInputType
    _min?: UnitProgressMinAggregateInputType
    _max?: UnitProgressMaxAggregateInputType
  }

  export type UnitProgressGroupByOutputType = {
    id: number
    enrollmentId: number
    unitId: number
    userId: number
    startedAt: Date
    completedAt: Date | null
    timeSpentMinutes: number
    lastPosition: string | null
    _count: UnitProgressCountAggregateOutputType | null
    _avg: UnitProgressAvgAggregateOutputType | null
    _sum: UnitProgressSumAggregateOutputType | null
    _min: UnitProgressMinAggregateOutputType | null
    _max: UnitProgressMaxAggregateOutputType | null
  }

  type GetUnitProgressGroupByPayload<T extends UnitProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UnitProgressGroupByOutputType[P]>
        }
      >
    >


  export type UnitProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    unitId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpentMinutes?: boolean
    lastPosition?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitProgress"]>

  export type UnitProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    unitId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpentMinutes?: boolean
    lastPosition?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitProgress"]>

  export type UnitProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    unitId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpentMinutes?: boolean
    lastPosition?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitProgress"]>

  export type UnitProgressSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    unitId?: boolean
    userId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpentMinutes?: boolean
    lastPosition?: boolean
  }

  export type UnitProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "unitId" | "userId" | "startedAt" | "completedAt" | "timeSpentMinutes" | "lastPosition", ExtArgs["result"]["unitProgress"]>
  export type UnitProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }
  export type UnitProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }
  export type UnitProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    unit?: boolean | ContentUnitDefaultArgs<ExtArgs>
  }

  export type $UnitProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitProgress"
    objects: {
      enrollment: Prisma.$EnrollmentPayload<ExtArgs>
      unit: Prisma.$ContentUnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enrollmentId: number
      unitId: number
      userId: number
      startedAt: Date
      completedAt: Date | null
      timeSpentMinutes: number
      lastPosition: string | null
    }, ExtArgs["result"]["unitProgress"]>
    composites: {}
  }

  type UnitProgressGetPayload<S extends boolean | null | undefined | UnitProgressDefaultArgs> = $Result.GetResult<Prisma.$UnitProgressPayload, S>

  type UnitProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitProgressCountAggregateInputType | true
    }

  export interface UnitProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitProgress'], meta: { name: 'UnitProgress' } }
    /**
     * Find zero or one UnitProgress that matches the filter.
     * @param {UnitProgressFindUniqueArgs} args - Arguments to find a UnitProgress
     * @example
     * // Get one UnitProgress
     * const unitProgress = await prisma.unitProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitProgressFindUniqueArgs>(args: SelectSubset<T, UnitProgressFindUniqueArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitProgressFindUniqueOrThrowArgs} args - Arguments to find a UnitProgress
     * @example
     * // Get one UnitProgress
     * const unitProgress = await prisma.unitProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressFindFirstArgs} args - Arguments to find a UnitProgress
     * @example
     * // Get one UnitProgress
     * const unitProgress = await prisma.unitProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitProgressFindFirstArgs>(args?: SelectSubset<T, UnitProgressFindFirstArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressFindFirstOrThrowArgs} args - Arguments to find a UnitProgress
     * @example
     * // Get one UnitProgress
     * const unitProgress = await prisma.unitProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitProgresses
     * const unitProgresses = await prisma.unitProgress.findMany()
     * 
     * // Get first 10 UnitProgresses
     * const unitProgresses = await prisma.unitProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitProgressWithIdOnly = await prisma.unitProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitProgressFindManyArgs>(args?: SelectSubset<T, UnitProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitProgress.
     * @param {UnitProgressCreateArgs} args - Arguments to create a UnitProgress.
     * @example
     * // Create one UnitProgress
     * const UnitProgress = await prisma.unitProgress.create({
     *   data: {
     *     // ... data to create a UnitProgress
     *   }
     * })
     * 
     */
    create<T extends UnitProgressCreateArgs>(args: SelectSubset<T, UnitProgressCreateArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitProgresses.
     * @param {UnitProgressCreateManyArgs} args - Arguments to create many UnitProgresses.
     * @example
     * // Create many UnitProgresses
     * const unitProgress = await prisma.unitProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitProgressCreateManyArgs>(args?: SelectSubset<T, UnitProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitProgresses and returns the data saved in the database.
     * @param {UnitProgressCreateManyAndReturnArgs} args - Arguments to create many UnitProgresses.
     * @example
     * // Create many UnitProgresses
     * const unitProgress = await prisma.unitProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitProgresses and only return the `id`
     * const unitProgressWithIdOnly = await prisma.unitProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitProgress.
     * @param {UnitProgressDeleteArgs} args - Arguments to delete one UnitProgress.
     * @example
     * // Delete one UnitProgress
     * const UnitProgress = await prisma.unitProgress.delete({
     *   where: {
     *     // ... filter to delete one UnitProgress
     *   }
     * })
     * 
     */
    delete<T extends UnitProgressDeleteArgs>(args: SelectSubset<T, UnitProgressDeleteArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitProgress.
     * @param {UnitProgressUpdateArgs} args - Arguments to update one UnitProgress.
     * @example
     * // Update one UnitProgress
     * const unitProgress = await prisma.unitProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitProgressUpdateArgs>(args: SelectSubset<T, UnitProgressUpdateArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitProgresses.
     * @param {UnitProgressDeleteManyArgs} args - Arguments to filter UnitProgresses to delete.
     * @example
     * // Delete a few UnitProgresses
     * const { count } = await prisma.unitProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitProgressDeleteManyArgs>(args?: SelectSubset<T, UnitProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitProgresses
     * const unitProgress = await prisma.unitProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitProgressUpdateManyArgs>(args: SelectSubset<T, UnitProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitProgresses and returns the data updated in the database.
     * @param {UnitProgressUpdateManyAndReturnArgs} args - Arguments to update many UnitProgresses.
     * @example
     * // Update many UnitProgresses
     * const unitProgress = await prisma.unitProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitProgresses and only return the `id`
     * const unitProgressWithIdOnly = await prisma.unitProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitProgress.
     * @param {UnitProgressUpsertArgs} args - Arguments to update or create a UnitProgress.
     * @example
     * // Update or create a UnitProgress
     * const unitProgress = await prisma.unitProgress.upsert({
     *   create: {
     *     // ... data to create a UnitProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitProgress we want to update
     *   }
     * })
     */
    upsert<T extends UnitProgressUpsertArgs>(args: SelectSubset<T, UnitProgressUpsertArgs<ExtArgs>>): Prisma__UnitProgressClient<$Result.GetResult<Prisma.$UnitProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressCountArgs} args - Arguments to filter UnitProgresses to count.
     * @example
     * // Count the number of UnitProgresses
     * const count = await prisma.unitProgress.count({
     *   where: {
     *     // ... the filter for the UnitProgresses we want to count
     *   }
     * })
    **/
    count<T extends UnitProgressCountArgs>(
      args?: Subset<T, UnitProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitProgressAggregateArgs>(args: Subset<T, UnitProgressAggregateArgs>): Prisma.PrismaPromise<GetUnitProgressAggregateType<T>>

    /**
     * Group by UnitProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitProgressGroupByArgs['orderBy'] }
        : { orderBy?: UnitProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitProgress model
   */
  readonly fields: UnitProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends EnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnrollmentDefaultArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends ContentUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentUnitDefaultArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitProgress model
   */
  interface UnitProgressFieldRefs {
    readonly id: FieldRef<"UnitProgress", 'Int'>
    readonly enrollmentId: FieldRef<"UnitProgress", 'Int'>
    readonly unitId: FieldRef<"UnitProgress", 'Int'>
    readonly userId: FieldRef<"UnitProgress", 'Int'>
    readonly startedAt: FieldRef<"UnitProgress", 'DateTime'>
    readonly completedAt: FieldRef<"UnitProgress", 'DateTime'>
    readonly timeSpentMinutes: FieldRef<"UnitProgress", 'Int'>
    readonly lastPosition: FieldRef<"UnitProgress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnitProgress findUnique
   */
  export type UnitProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * Filter, which UnitProgress to fetch.
     */
    where: UnitProgressWhereUniqueInput
  }

  /**
   * UnitProgress findUniqueOrThrow
   */
  export type UnitProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * Filter, which UnitProgress to fetch.
     */
    where: UnitProgressWhereUniqueInput
  }

  /**
   * UnitProgress findFirst
   */
  export type UnitProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * Filter, which UnitProgress to fetch.
     */
    where?: UnitProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitProgresses to fetch.
     */
    orderBy?: UnitProgressOrderByWithRelationInput | UnitProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitProgresses.
     */
    cursor?: UnitProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitProgresses.
     */
    distinct?: UnitProgressScalarFieldEnum | UnitProgressScalarFieldEnum[]
  }

  /**
   * UnitProgress findFirstOrThrow
   */
  export type UnitProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * Filter, which UnitProgress to fetch.
     */
    where?: UnitProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitProgresses to fetch.
     */
    orderBy?: UnitProgressOrderByWithRelationInput | UnitProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitProgresses.
     */
    cursor?: UnitProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitProgresses.
     */
    distinct?: UnitProgressScalarFieldEnum | UnitProgressScalarFieldEnum[]
  }

  /**
   * UnitProgress findMany
   */
  export type UnitProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * Filter, which UnitProgresses to fetch.
     */
    where?: UnitProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitProgresses to fetch.
     */
    orderBy?: UnitProgressOrderByWithRelationInput | UnitProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitProgresses.
     */
    cursor?: UnitProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitProgresses.
     */
    skip?: number
    distinct?: UnitProgressScalarFieldEnum | UnitProgressScalarFieldEnum[]
  }

  /**
   * UnitProgress create
   */
  export type UnitProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitProgress.
     */
    data: XOR<UnitProgressCreateInput, UnitProgressUncheckedCreateInput>
  }

  /**
   * UnitProgress createMany
   */
  export type UnitProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitProgresses.
     */
    data: UnitProgressCreateManyInput | UnitProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitProgress createManyAndReturn
   */
  export type UnitProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UnitProgresses.
     */
    data: UnitProgressCreateManyInput | UnitProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitProgress update
   */
  export type UnitProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitProgress.
     */
    data: XOR<UnitProgressUpdateInput, UnitProgressUncheckedUpdateInput>
    /**
     * Choose, which UnitProgress to update.
     */
    where: UnitProgressWhereUniqueInput
  }

  /**
   * UnitProgress updateMany
   */
  export type UnitProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitProgresses.
     */
    data: XOR<UnitProgressUpdateManyMutationInput, UnitProgressUncheckedUpdateManyInput>
    /**
     * Filter which UnitProgresses to update
     */
    where?: UnitProgressWhereInput
    /**
     * Limit how many UnitProgresses to update.
     */
    limit?: number
  }

  /**
   * UnitProgress updateManyAndReturn
   */
  export type UnitProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * The data used to update UnitProgresses.
     */
    data: XOR<UnitProgressUpdateManyMutationInput, UnitProgressUncheckedUpdateManyInput>
    /**
     * Filter which UnitProgresses to update
     */
    where?: UnitProgressWhereInput
    /**
     * Limit how many UnitProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitProgress upsert
   */
  export type UnitProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitProgress to update in case it exists.
     */
    where: UnitProgressWhereUniqueInput
    /**
     * In case the UnitProgress found by the `where` argument doesn't exist, create a new UnitProgress with this data.
     */
    create: XOR<UnitProgressCreateInput, UnitProgressUncheckedCreateInput>
    /**
     * In case the UnitProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitProgressUpdateInput, UnitProgressUncheckedUpdateInput>
  }

  /**
   * UnitProgress delete
   */
  export type UnitProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
    /**
     * Filter which UnitProgress to delete.
     */
    where: UnitProgressWhereUniqueInput
  }

  /**
   * UnitProgress deleteMany
   */
  export type UnitProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitProgresses to delete
     */
    where?: UnitProgressWhereInput
    /**
     * Limit how many UnitProgresses to delete.
     */
    limit?: number
  }

  /**
   * UnitProgress without action
   */
  export type UnitProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitProgress
     */
    select?: UnitProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitProgress
     */
    omit?: UnitProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitProgressInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    id: number | null
    moduleId: number | null
    timeLimit: number | null
    passingScore: number | null
    maxAttempts: number | null
    orderNumber: number | null
  }

  export type QuizSumAggregateOutputType = {
    id: number | null
    moduleId: number | null
    timeLimit: number | null
    passingScore: number | null
    maxAttempts: number | null
    orderNumber: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: number | null
    moduleId: number | null
    title: string | null
    description: string | null
    timeLimit: number | null
    passingScore: number | null
    allowRetakes: boolean | null
    maxAttempts: number | null
    randomizeQuestions: boolean | null
    showCorrectAnswers: boolean | null
    orderNumber: number | null
    isPublished: boolean | null
  }

  export type QuizMaxAggregateOutputType = {
    id: number | null
    moduleId: number | null
    title: string | null
    description: string | null
    timeLimit: number | null
    passingScore: number | null
    allowRetakes: boolean | null
    maxAttempts: number | null
    randomizeQuestions: boolean | null
    showCorrectAnswers: boolean | null
    orderNumber: number | null
    isPublished: boolean | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    moduleId: number
    title: number
    description: number
    timeLimit: number
    passingScore: number
    allowRetakes: number
    maxAttempts: number
    randomizeQuestions: number
    showCorrectAnswers: number
    orderNumber: number
    isPublished: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    id?: true
    moduleId?: true
    timeLimit?: true
    passingScore?: true
    maxAttempts?: true
    orderNumber?: true
  }

  export type QuizSumAggregateInputType = {
    id?: true
    moduleId?: true
    timeLimit?: true
    passingScore?: true
    maxAttempts?: true
    orderNumber?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    timeLimit?: true
    passingScore?: true
    allowRetakes?: true
    maxAttempts?: true
    randomizeQuestions?: true
    showCorrectAnswers?: true
    orderNumber?: true
    isPublished?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    timeLimit?: true
    passingScore?: true
    allowRetakes?: true
    maxAttempts?: true
    randomizeQuestions?: true
    showCorrectAnswers?: true
    orderNumber?: true
    isPublished?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    timeLimit?: true
    passingScore?: true
    allowRetakes?: true
    maxAttempts?: true
    randomizeQuestions?: true
    showCorrectAnswers?: true
    orderNumber?: true
    isPublished?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: number
    moduleId: number
    title: string
    description: string | null
    timeLimit: number | null
    passingScore: number
    allowRetakes: boolean
    maxAttempts: number | null
    randomizeQuestions: boolean
    showCorrectAnswers: boolean
    orderNumber: number
    isPublished: boolean
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    allowRetakes?: boolean
    maxAttempts?: boolean
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    allowRetakes?: boolean
    maxAttempts?: boolean
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    allowRetakes?: boolean
    maxAttempts?: boolean
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber?: boolean
    isPublished?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    allowRetakes?: boolean
    maxAttempts?: boolean
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber?: boolean
    isPublished?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "title" | "description" | "timeLimit" | "passingScore" | "allowRetakes" | "maxAttempts" | "randomizeQuestions" | "showCorrectAnswers" | "orderNumber" | "isPublished", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      module: Prisma.$CourseModulePayload<ExtArgs>
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      attempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      moduleId: number
      title: string
      description: string | null
      timeLimit: number | null
      passingScore: number
      allowRetakes: boolean
      maxAttempts: number | null
      randomizeQuestions: boolean
      showCorrectAnswers: boolean
      orderNumber: number
      isPublished: boolean
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Quiz$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'Int'>
    readonly moduleId: FieldRef<"Quiz", 'Int'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly timeLimit: FieldRef<"Quiz", 'Int'>
    readonly passingScore: FieldRef<"Quiz", 'Int'>
    readonly allowRetakes: FieldRef<"Quiz", 'Boolean'>
    readonly maxAttempts: FieldRef<"Quiz", 'Int'>
    readonly randomizeQuestions: FieldRef<"Quiz", 'Boolean'>
    readonly showCorrectAnswers: FieldRef<"Quiz", 'Boolean'>
    readonly orderNumber: FieldRef<"Quiz", 'Int'>
    readonly isPublished: FieldRef<"Quiz", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.attempts
   */
  export type Quiz$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
    points: number | null
    orderNumber: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    id: number | null
    quizId: number | null
    points: number | null
    orderNumber: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    points: number | null
    orderNumber: number | null
    options: string | null
    correctAnswer: string | null
    explanation: string | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    points: number | null
    orderNumber: number | null
    options: string | null
    correctAnswer: string | null
    explanation: string | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    quizId: number
    questionText: number
    questionType: number
    points: number
    orderNumber: number
    options: number
    correctAnswer: number
    explanation: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    id?: true
    quizId?: true
    points?: true
    orderNumber?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    id?: true
    quizId?: true
    points?: true
    orderNumber?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    questionText?: true
    questionType?: true
    points?: true
    orderNumber?: true
    options?: true
    correctAnswer?: true
    explanation?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    questionText?: true
    questionType?: true
    points?: true
    orderNumber?: true
    options?: true
    correctAnswer?: true
    explanation?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    questionText?: true
    questionType?: true
    points?: true
    orderNumber?: true
    options?: true
    correctAnswer?: true
    explanation?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: number
    quizId: number
    questionText: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options: string | null
    correctAnswer: string | null
    explanation: string | null
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    quizId?: boolean
    questionText?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "questionText" | "questionType" | "points" | "orderNumber" | "options" | "correctAnswer" | "explanation", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      answers: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quizId: number
      questionText: string
      questionType: $Enums.QuestionType
      points: number
      orderNumber: number
      options: string | null
      correctAnswer: string | null
      explanation: string | null
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuizQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'Int'>
    readonly quizId: FieldRef<"QuizQuestion", 'Int'>
    readonly questionText: FieldRef<"QuizQuestion", 'String'>
    readonly questionType: FieldRef<"QuizQuestion", 'QuestionType'>
    readonly points: FieldRef<"QuizQuestion", 'Int'>
    readonly orderNumber: FieldRef<"QuizQuestion", 'Int'>
    readonly options: FieldRef<"QuizQuestion", 'String'>
    readonly correctAnswer: FieldRef<"QuizQuestion", 'String'>
    readonly explanation: FieldRef<"QuizQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion.answers
   */
  export type QuizQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    quizId: number | null
    userId: number | null
    score: number | null
    percentage: number | null
    attemptNumber: number | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    quizId: number | null
    userId: number | null
    score: number | null
    percentage: number | null
    attemptNumber: number | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    quizId: number | null
    userId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    score: number | null
    percentage: number | null
    passed: boolean | null
    attemptNumber: number | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: number | null
    enrollmentId: number | null
    quizId: number | null
    userId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    score: number | null
    percentage: number | null
    passed: boolean | null
    attemptNumber: number | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    enrollmentId: number
    quizId: number
    userId: number
    startedAt: number
    submittedAt: number
    score: number
    percentage: number
    passed: number
    attemptNumber: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    id?: true
    enrollmentId?: true
    quizId?: true
    userId?: true
    score?: true
    percentage?: true
    attemptNumber?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    id?: true
    enrollmentId?: true
    quizId?: true
    userId?: true
    score?: true
    percentage?: true
    attemptNumber?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    quizId?: true
    userId?: true
    startedAt?: true
    submittedAt?: true
    score?: true
    percentage?: true
    passed?: true
    attemptNumber?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    quizId?: true
    userId?: true
    startedAt?: true
    submittedAt?: true
    score?: true
    percentage?: true
    passed?: true
    attemptNumber?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    quizId?: true
    userId?: true
    startedAt?: true
    submittedAt?: true
    score?: true
    percentage?: true
    passed?: true
    attemptNumber?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: number
    enrollmentId: number
    quizId: number
    userId: number
    startedAt: Date
    submittedAt: Date | null
    score: number | null
    percentage: number | null
    passed: boolean | null
    attemptNumber: number
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    quizId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    percentage?: boolean
    passed?: boolean
    attemptNumber?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    answers?: boolean | QuizAttempt$answersArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    quizId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    percentage?: boolean
    passed?: boolean
    attemptNumber?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    quizId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    percentage?: boolean
    passed?: boolean
    attemptNumber?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    quizId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    percentage?: boolean
    passed?: boolean
    attemptNumber?: boolean
  }

  export type QuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "quizId" | "userId" | "startedAt" | "submittedAt" | "score" | "percentage" | "passed" | "attemptNumber", ExtArgs["result"]["quizAttempt"]>
  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    answers?: boolean | QuizAttempt$answersArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      enrollment: Prisma.$EnrollmentPayload<ExtArgs>
      quiz: Prisma.$QuizPayload<ExtArgs>
      answers: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enrollmentId: number
      quizId: number
      userId: number
      startedAt: Date
      submittedAt: Date | null
      score: number | null
      percentage: number | null
      passed: boolean | null
      attemptNumber: number
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts and returns the data updated in the database.
     * @param {QuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuizAttempts.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends EnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnrollmentDefaultArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuizAttempt$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttempt$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'Int'>
    readonly enrollmentId: FieldRef<"QuizAttempt", 'Int'>
    readonly quizId: FieldRef<"QuizAttempt", 'Int'>
    readonly userId: FieldRef<"QuizAttempt", 'Int'>
    readonly startedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly score: FieldRef<"QuizAttempt", 'Int'>
    readonly percentage: FieldRef<"QuizAttempt", 'Float'>
    readonly passed: FieldRef<"QuizAttempt", 'Boolean'>
    readonly attemptNumber: FieldRef<"QuizAttempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
  }

  /**
   * QuizAttempt updateManyAndReturn
   */
  export type QuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuizAttempt.answers
   */
  export type QuizAttempt$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model QuestionAnswer
   */

  export type AggregateQuestionAnswer = {
    _count: QuestionAnswerCountAggregateOutputType | null
    _avg: QuestionAnswerAvgAggregateOutputType | null
    _sum: QuestionAnswerSumAggregateOutputType | null
    _min: QuestionAnswerMinAggregateOutputType | null
    _max: QuestionAnswerMaxAggregateOutputType | null
  }

  export type QuestionAnswerAvgAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
    pointsAwarded: number | null
  }

  export type QuestionAnswerSumAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
    pointsAwarded: number | null
  }

  export type QuestionAnswerMinAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
    userAnswer: string | null
    isCorrect: boolean | null
    pointsAwarded: number | null
  }

  export type QuestionAnswerMaxAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
    userAnswer: string | null
    isCorrect: boolean | null
    pointsAwarded: number | null
  }

  export type QuestionAnswerCountAggregateOutputType = {
    id: number
    attemptId: number
    questionId: number
    userAnswer: number
    isCorrect: number
    pointsAwarded: number
    _all: number
  }


  export type QuestionAnswerAvgAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    pointsAwarded?: true
  }

  export type QuestionAnswerSumAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    pointsAwarded?: true
  }

  export type QuestionAnswerMinAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    userAnswer?: true
    isCorrect?: true
    pointsAwarded?: true
  }

  export type QuestionAnswerMaxAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    userAnswer?: true
    isCorrect?: true
    pointsAwarded?: true
  }

  export type QuestionAnswerCountAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    userAnswer?: true
    isCorrect?: true
    pointsAwarded?: true
    _all?: true
  }

  export type QuestionAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnswer to aggregate.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionAnswers
    **/
    _count?: true | QuestionAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionAnswerMaxAggregateInputType
  }

  export type GetQuestionAnswerAggregateType<T extends QuestionAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionAnswer[P]>
      : GetScalarType<T[P], AggregateQuestionAnswer[P]>
  }




  export type QuestionAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithAggregationInput | QuestionAnswerOrderByWithAggregationInput[]
    by: QuestionAnswerScalarFieldEnum[] | QuestionAnswerScalarFieldEnum
    having?: QuestionAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionAnswerCountAggregateInputType | true
    _avg?: QuestionAnswerAvgAggregateInputType
    _sum?: QuestionAnswerSumAggregateInputType
    _min?: QuestionAnswerMinAggregateInputType
    _max?: QuestionAnswerMaxAggregateInputType
  }

  export type QuestionAnswerGroupByOutputType = {
    id: number
    attemptId: number
    questionId: number
    userAnswer: string | null
    isCorrect: boolean | null
    pointsAwarded: number | null
    _count: QuestionAnswerCountAggregateOutputType | null
    _avg: QuestionAnswerAvgAggregateOutputType | null
    _sum: QuestionAnswerSumAggregateOutputType | null
    _min: QuestionAnswerMinAggregateOutputType | null
    _max: QuestionAnswerMaxAggregateOutputType | null
  }

  type GetQuestionAnswerGroupByPayload<T extends QuestionAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuestionAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    pointsAwarded?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAnswer"]>

  export type QuestionAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    pointsAwarded?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAnswer"]>

  export type QuestionAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    pointsAwarded?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAnswer"]>

  export type QuestionAnswerSelectScalar = {
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    pointsAwarded?: boolean
  }

  export type QuestionAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attemptId" | "questionId" | "userAnswer" | "isCorrect" | "pointsAwarded", ExtArgs["result"]["questionAnswer"]>
  export type QuestionAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuestionAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuestionAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }

  export type $QuestionAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionAnswer"
    objects: {
      attempt: Prisma.$QuizAttemptPayload<ExtArgs>
      question: Prisma.$QuizQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attemptId: number
      questionId: number
      userAnswer: string | null
      isCorrect: boolean | null
      pointsAwarded: number | null
    }, ExtArgs["result"]["questionAnswer"]>
    composites: {}
  }

  type QuestionAnswerGetPayload<S extends boolean | null | undefined | QuestionAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuestionAnswerPayload, S>

  type QuestionAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionAnswerCountAggregateInputType | true
    }

  export interface QuestionAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAnswer'], meta: { name: 'QuestionAnswer' } }
    /**
     * Find zero or one QuestionAnswer that matches the filter.
     * @param {QuestionAnswerFindUniqueArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionAnswerFindUniqueArgs>(args: SelectSubset<T, QuestionAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindFirstArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionAnswerFindFirstArgs>(args?: SelectSubset<T, QuestionAnswerFindFirstArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindFirstOrThrowArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionAnswers
     * const questionAnswers = await prisma.questionAnswer.findMany()
     * 
     * // Get first 10 QuestionAnswers
     * const questionAnswers = await prisma.questionAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionAnswerWithIdOnly = await prisma.questionAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionAnswerFindManyArgs>(args?: SelectSubset<T, QuestionAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionAnswer.
     * @param {QuestionAnswerCreateArgs} args - Arguments to create a QuestionAnswer.
     * @example
     * // Create one QuestionAnswer
     * const QuestionAnswer = await prisma.questionAnswer.create({
     *   data: {
     *     // ... data to create a QuestionAnswer
     *   }
     * })
     * 
     */
    create<T extends QuestionAnswerCreateArgs>(args: SelectSubset<T, QuestionAnswerCreateArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionAnswers.
     * @param {QuestionAnswerCreateManyArgs} args - Arguments to create many QuestionAnswers.
     * @example
     * // Create many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionAnswerCreateManyArgs>(args?: SelectSubset<T, QuestionAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionAnswers and returns the data saved in the database.
     * @param {QuestionAnswerCreateManyAndReturnArgs} args - Arguments to create many QuestionAnswers.
     * @example
     * // Create many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionAnswers and only return the `id`
     * const questionAnswerWithIdOnly = await prisma.questionAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionAnswer.
     * @param {QuestionAnswerDeleteArgs} args - Arguments to delete one QuestionAnswer.
     * @example
     * // Delete one QuestionAnswer
     * const QuestionAnswer = await prisma.questionAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuestionAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuestionAnswerDeleteArgs>(args: SelectSubset<T, QuestionAnswerDeleteArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionAnswer.
     * @param {QuestionAnswerUpdateArgs} args - Arguments to update one QuestionAnswer.
     * @example
     * // Update one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionAnswerUpdateArgs>(args: SelectSubset<T, QuestionAnswerUpdateArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionAnswers.
     * @param {QuestionAnswerDeleteManyArgs} args - Arguments to filter QuestionAnswers to delete.
     * @example
     * // Delete a few QuestionAnswers
     * const { count } = await prisma.questionAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionAnswerDeleteManyArgs>(args?: SelectSubset<T, QuestionAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionAnswerUpdateManyArgs>(args: SelectSubset<T, QuestionAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAnswers and returns the data updated in the database.
     * @param {QuestionAnswerUpdateManyAndReturnArgs} args - Arguments to update many QuestionAnswers.
     * @example
     * // Update many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionAnswers and only return the `id`
     * const questionAnswerWithIdOnly = await prisma.questionAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionAnswer.
     * @param {QuestionAnswerUpsertArgs} args - Arguments to update or create a QuestionAnswer.
     * @example
     * // Update or create a QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.upsert({
     *   create: {
     *     // ... data to create a QuestionAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuestionAnswerUpsertArgs>(args: SelectSubset<T, QuestionAnswerUpsertArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerCountArgs} args - Arguments to filter QuestionAnswers to count.
     * @example
     * // Count the number of QuestionAnswers
     * const count = await prisma.questionAnswer.count({
     *   where: {
     *     // ... the filter for the QuestionAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuestionAnswerCountArgs>(
      args?: Subset<T, QuestionAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAnswerAggregateArgs>(args: Subset<T, QuestionAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuestionAnswerAggregateType<T>>

    /**
     * Group by QuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuestionAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionAnswer model
   */
  readonly fields: QuestionAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends QuizAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttemptDefaultArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionAnswer model
   */
  interface QuestionAnswerFieldRefs {
    readonly id: FieldRef<"QuestionAnswer", 'Int'>
    readonly attemptId: FieldRef<"QuestionAnswer", 'Int'>
    readonly questionId: FieldRef<"QuestionAnswer", 'Int'>
    readonly userAnswer: FieldRef<"QuestionAnswer", 'String'>
    readonly isCorrect: FieldRef<"QuestionAnswer", 'Boolean'>
    readonly pointsAwarded: FieldRef<"QuestionAnswer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuestionAnswer findUnique
   */
  export type QuestionAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer findUniqueOrThrow
   */
  export type QuestionAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer findFirst
   */
  export type QuestionAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnswers.
     */
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer findFirstOrThrow
   */
  export type QuestionAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnswers.
     */
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer findMany
   */
  export type QuestionAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswers to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer create
   */
  export type QuestionAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionAnswer.
     */
    data: XOR<QuestionAnswerCreateInput, QuestionAnswerUncheckedCreateInput>
  }

  /**
   * QuestionAnswer createMany
   */
  export type QuestionAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionAnswers.
     */
    data: QuestionAnswerCreateManyInput | QuestionAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAnswer createManyAndReturn
   */
  export type QuestionAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionAnswers.
     */
    data: QuestionAnswerCreateManyInput | QuestionAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAnswer update
   */
  export type QuestionAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionAnswer.
     */
    data: XOR<QuestionAnswerUpdateInput, QuestionAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuestionAnswer to update.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer updateMany
   */
  export type QuestionAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionAnswers.
     */
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAnswers to update
     */
    where?: QuestionAnswerWhereInput
    /**
     * Limit how many QuestionAnswers to update.
     */
    limit?: number
  }

  /**
   * QuestionAnswer updateManyAndReturn
   */
  export type QuestionAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * The data used to update QuestionAnswers.
     */
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAnswers to update
     */
    where?: QuestionAnswerWhereInput
    /**
     * Limit how many QuestionAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAnswer upsert
   */
  export type QuestionAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionAnswer to update in case it exists.
     */
    where: QuestionAnswerWhereUniqueInput
    /**
     * In case the QuestionAnswer found by the `where` argument doesn't exist, create a new QuestionAnswer with this data.
     */
    create: XOR<QuestionAnswerCreateInput, QuestionAnswerUncheckedCreateInput>
    /**
     * In case the QuestionAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionAnswerUpdateInput, QuestionAnswerUncheckedUpdateInput>
  }

  /**
   * QuestionAnswer delete
   */
  export type QuestionAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuestionAnswer to delete.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer deleteMany
   */
  export type QuestionAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnswers to delete
     */
    where?: QuestionAnswerWhereInput
    /**
     * Limit how many QuestionAnswers to delete.
     */
    limit?: number
  }

  /**
   * QuestionAnswer without action
   */
  export type QuestionAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnswer
     */
    omit?: QuestionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    id: number | null
    moduleId: number | null
    orderNumber: number | null
    maxScore: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    id: number | null
    moduleId: number | null
    orderNumber: number | null
    maxScore: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: number | null
    moduleId: number | null
    title: string | null
    description: string | null
    instructions: string | null
    exerciseType: $Enums.ExerciseType | null
    orderNumber: number | null
    dueDate: Date | null
    allowLateSubmissions: boolean | null
    maxScore: number | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: number | null
    moduleId: number | null
    title: string | null
    description: string | null
    instructions: string | null
    exerciseType: $Enums.ExerciseType | null
    orderNumber: number | null
    dueDate: Date | null
    allowLateSubmissions: boolean | null
    maxScore: number | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    moduleId: number
    title: number
    description: number
    instructions: number
    exerciseType: number
    orderNumber: number
    dueDate: number
    allowLateSubmissions: number
    maxScore: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    id?: true
    moduleId?: true
    orderNumber?: true
    maxScore?: true
  }

  export type ExerciseSumAggregateInputType = {
    id?: true
    moduleId?: true
    orderNumber?: true
    maxScore?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    instructions?: true
    exerciseType?: true
    orderNumber?: true
    dueDate?: true
    allowLateSubmissions?: true
    maxScore?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    instructions?: true
    exerciseType?: true
    orderNumber?: true
    dueDate?: true
    allowLateSubmissions?: true
    maxScore?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    instructions?: true
    exerciseType?: true
    orderNumber?: true
    dueDate?: true
    allowLateSubmissions?: true
    maxScore?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: number
    moduleId: number
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate: Date | null
    allowLateSubmissions: boolean
    maxScore: number
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    exerciseType?: boolean
    orderNumber?: boolean
    dueDate?: boolean
    allowLateSubmissions?: boolean
    maxScore?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    submissions?: boolean | Exercise$submissionsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    exerciseType?: boolean
    orderNumber?: boolean
    dueDate?: boolean
    allowLateSubmissions?: boolean
    maxScore?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    exerciseType?: boolean
    orderNumber?: boolean
    dueDate?: boolean
    allowLateSubmissions?: boolean
    maxScore?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    exerciseType?: boolean
    orderNumber?: boolean
    dueDate?: boolean
    allowLateSubmissions?: boolean
    maxScore?: boolean
  }

  export type ExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "title" | "description" | "instructions" | "exerciseType" | "orderNumber" | "dueDate" | "allowLateSubmissions" | "maxScore", ExtArgs["result"]["exercise"]>
  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    submissions?: boolean | Exercise$submissionsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      module: Prisma.$CourseModulePayload<ExtArgs>
      submissions: Prisma.$ExerciseSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      moduleId: number
      title: string
      description: string
      instructions: string
      exerciseType: $Enums.ExerciseType
      orderNumber: number
      dueDate: Date | null
      allowLateSubmissions: boolean
      maxScore: number
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises and returns the data updated in the database.
     * @param {ExerciseUpdateManyAndReturnArgs} args - Arguments to update many Exercises.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submissions<T extends Exercise$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'Int'>
    readonly moduleId: FieldRef<"Exercise", 'Int'>
    readonly title: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly instructions: FieldRef<"Exercise", 'String'>
    readonly exerciseType: FieldRef<"Exercise", 'ExerciseType'>
    readonly orderNumber: FieldRef<"Exercise", 'Int'>
    readonly dueDate: FieldRef<"Exercise", 'DateTime'>
    readonly allowLateSubmissions: FieldRef<"Exercise", 'Boolean'>
    readonly maxScore: FieldRef<"Exercise", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise updateManyAndReturn
   */
  export type ExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to delete.
     */
    limit?: number
  }

  /**
   * Exercise.submissions
   */
  export type Exercise$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    cursor?: ExerciseSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseSubmission
   */

  export type AggregateExerciseSubmission = {
    _count: ExerciseSubmissionCountAggregateOutputType | null
    _avg: ExerciseSubmissionAvgAggregateOutputType | null
    _sum: ExerciseSubmissionSumAggregateOutputType | null
    _min: ExerciseSubmissionMinAggregateOutputType | null
    _max: ExerciseSubmissionMaxAggregateOutputType | null
  }

  export type ExerciseSubmissionAvgAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    enrollmentId: number | null
    userId: number | null
    score: number | null
    gradedBy: number | null
  }

  export type ExerciseSubmissionSumAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    enrollmentId: number | null
    userId: number | null
    score: number | null
    gradedBy: number | null
  }

  export type ExerciseSubmissionMinAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    enrollmentId: number | null
    userId: number | null
    submittedAt: Date | null
    content: string | null
    fileUrl: string | null
    score: number | null
    feedback: string | null
    gradedAt: Date | null
    gradedBy: number | null
  }

  export type ExerciseSubmissionMaxAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    enrollmentId: number | null
    userId: number | null
    submittedAt: Date | null
    content: string | null
    fileUrl: string | null
    score: number | null
    feedback: string | null
    gradedAt: Date | null
    gradedBy: number | null
  }

  export type ExerciseSubmissionCountAggregateOutputType = {
    id: number
    exerciseId: number
    enrollmentId: number
    userId: number
    submittedAt: number
    content: number
    fileUrl: number
    score: number
    feedback: number
    gradedAt: number
    gradedBy: number
    _all: number
  }


  export type ExerciseSubmissionAvgAggregateInputType = {
    id?: true
    exerciseId?: true
    enrollmentId?: true
    userId?: true
    score?: true
    gradedBy?: true
  }

  export type ExerciseSubmissionSumAggregateInputType = {
    id?: true
    exerciseId?: true
    enrollmentId?: true
    userId?: true
    score?: true
    gradedBy?: true
  }

  export type ExerciseSubmissionMinAggregateInputType = {
    id?: true
    exerciseId?: true
    enrollmentId?: true
    userId?: true
    submittedAt?: true
    content?: true
    fileUrl?: true
    score?: true
    feedback?: true
    gradedAt?: true
    gradedBy?: true
  }

  export type ExerciseSubmissionMaxAggregateInputType = {
    id?: true
    exerciseId?: true
    enrollmentId?: true
    userId?: true
    submittedAt?: true
    content?: true
    fileUrl?: true
    score?: true
    feedback?: true
    gradedAt?: true
    gradedBy?: true
  }

  export type ExerciseSubmissionCountAggregateInputType = {
    id?: true
    exerciseId?: true
    enrollmentId?: true
    userId?: true
    submittedAt?: true
    content?: true
    fileUrl?: true
    score?: true
    feedback?: true
    gradedAt?: true
    gradedBy?: true
    _all?: true
  }

  export type ExerciseSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseSubmission to aggregate.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseSubmissions
    **/
    _count?: true | ExerciseSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseSubmissionMaxAggregateInputType
  }

  export type GetExerciseSubmissionAggregateType<T extends ExerciseSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseSubmission[P]>
      : GetScalarType<T[P], AggregateExerciseSubmission[P]>
  }




  export type ExerciseSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithAggregationInput | ExerciseSubmissionOrderByWithAggregationInput[]
    by: ExerciseSubmissionScalarFieldEnum[] | ExerciseSubmissionScalarFieldEnum
    having?: ExerciseSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseSubmissionCountAggregateInputType | true
    _avg?: ExerciseSubmissionAvgAggregateInputType
    _sum?: ExerciseSubmissionSumAggregateInputType
    _min?: ExerciseSubmissionMinAggregateInputType
    _max?: ExerciseSubmissionMaxAggregateInputType
  }

  export type ExerciseSubmissionGroupByOutputType = {
    id: number
    exerciseId: number
    enrollmentId: number
    userId: number
    submittedAt: Date
    content: string | null
    fileUrl: string | null
    score: number | null
    feedback: string | null
    gradedAt: Date | null
    gradedBy: number | null
    _count: ExerciseSubmissionCountAggregateOutputType | null
    _avg: ExerciseSubmissionAvgAggregateOutputType | null
    _sum: ExerciseSubmissionSumAggregateOutputType | null
    _min: ExerciseSubmissionMinAggregateOutputType | null
    _max: ExerciseSubmissionMaxAggregateOutputType | null
  }

  type GetExerciseSubmissionGroupByPayload<T extends ExerciseSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    enrollmentId?: boolean
    userId?: boolean
    submittedAt?: boolean
    content?: boolean
    fileUrl?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedBy?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseSubmission"]>

  export type ExerciseSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    enrollmentId?: boolean
    userId?: boolean
    submittedAt?: boolean
    content?: boolean
    fileUrl?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedBy?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseSubmission"]>

  export type ExerciseSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    enrollmentId?: boolean
    userId?: boolean
    submittedAt?: boolean
    content?: boolean
    fileUrl?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedBy?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseSubmission"]>

  export type ExerciseSubmissionSelectScalar = {
    id?: boolean
    exerciseId?: boolean
    enrollmentId?: boolean
    userId?: boolean
    submittedAt?: boolean
    content?: boolean
    fileUrl?: boolean
    score?: boolean
    feedback?: boolean
    gradedAt?: boolean
    gradedBy?: boolean
  }

  export type ExerciseSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exerciseId" | "enrollmentId" | "userId" | "submittedAt" | "content" | "fileUrl" | "score" | "feedback" | "gradedAt" | "gradedBy", ExtArgs["result"]["exerciseSubmission"]>
  export type ExerciseSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }
  export type ExerciseSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }
  export type ExerciseSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }

  export type $ExerciseSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseSubmission"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
      enrollment: Prisma.$EnrollmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exerciseId: number
      enrollmentId: number
      userId: number
      submittedAt: Date
      content: string | null
      fileUrl: string | null
      score: number | null
      feedback: string | null
      gradedAt: Date | null
      gradedBy: number | null
    }, ExtArgs["result"]["exerciseSubmission"]>
    composites: {}
  }

  type ExerciseSubmissionGetPayload<S extends boolean | null | undefined | ExerciseSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ExerciseSubmissionPayload, S>

  type ExerciseSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseSubmissionCountAggregateInputType | true
    }

  export interface ExerciseSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseSubmission'], meta: { name: 'ExerciseSubmission' } }
    /**
     * Find zero or one ExerciseSubmission that matches the filter.
     * @param {ExerciseSubmissionFindUniqueArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseSubmissionFindUniqueArgs>(args: SelectSubset<T, ExerciseSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionFindFirstArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseSubmissionFindFirstArgs>(args?: SelectSubset<T, ExerciseSubmissionFindFirstArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionFindFirstOrThrowArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExerciseSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseSubmissions
     * const exerciseSubmissions = await prisma.exerciseSubmission.findMany()
     * 
     * // Get first 10 ExerciseSubmissions
     * const exerciseSubmissions = await prisma.exerciseSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseSubmissionWithIdOnly = await prisma.exerciseSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseSubmissionFindManyArgs>(args?: SelectSubset<T, ExerciseSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseSubmission.
     * @param {ExerciseSubmissionCreateArgs} args - Arguments to create a ExerciseSubmission.
     * @example
     * // Create one ExerciseSubmission
     * const ExerciseSubmission = await prisma.exerciseSubmission.create({
     *   data: {
     *     // ... data to create a ExerciseSubmission
     *   }
     * })
     * 
     */
    create<T extends ExerciseSubmissionCreateArgs>(args: SelectSubset<T, ExerciseSubmissionCreateArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExerciseSubmissions.
     * @param {ExerciseSubmissionCreateManyArgs} args - Arguments to create many ExerciseSubmissions.
     * @example
     * // Create many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseSubmissionCreateManyArgs>(args?: SelectSubset<T, ExerciseSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseSubmissions and returns the data saved in the database.
     * @param {ExerciseSubmissionCreateManyAndReturnArgs} args - Arguments to create many ExerciseSubmissions.
     * @example
     * // Create many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseSubmissions and only return the `id`
     * const exerciseSubmissionWithIdOnly = await prisma.exerciseSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseSubmission.
     * @param {ExerciseSubmissionDeleteArgs} args - Arguments to delete one ExerciseSubmission.
     * @example
     * // Delete one ExerciseSubmission
     * const ExerciseSubmission = await prisma.exerciseSubmission.delete({
     *   where: {
     *     // ... filter to delete one ExerciseSubmission
     *   }
     * })
     * 
     */
    delete<T extends ExerciseSubmissionDeleteArgs>(args: SelectSubset<T, ExerciseSubmissionDeleteArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseSubmission.
     * @param {ExerciseSubmissionUpdateArgs} args - Arguments to update one ExerciseSubmission.
     * @example
     * // Update one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseSubmissionUpdateArgs>(args: SelectSubset<T, ExerciseSubmissionUpdateArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExerciseSubmissions.
     * @param {ExerciseSubmissionDeleteManyArgs} args - Arguments to filter ExerciseSubmissions to delete.
     * @example
     * // Delete a few ExerciseSubmissions
     * const { count } = await prisma.exerciseSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseSubmissionDeleteManyArgs>(args?: SelectSubset<T, ExerciseSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseSubmissionUpdateManyArgs>(args: SelectSubset<T, ExerciseSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseSubmissions and returns the data updated in the database.
     * @param {ExerciseSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ExerciseSubmissions.
     * @example
     * // Update many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciseSubmissions and only return the `id`
     * const exerciseSubmissionWithIdOnly = await prisma.exerciseSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseSubmission.
     * @param {ExerciseSubmissionUpsertArgs} args - Arguments to update or create a ExerciseSubmission.
     * @example
     * // Update or create a ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.upsert({
     *   create: {
     *     // ... data to create a ExerciseSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseSubmissionUpsertArgs>(args: SelectSubset<T, ExerciseSubmissionUpsertArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExerciseSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionCountArgs} args - Arguments to filter ExerciseSubmissions to count.
     * @example
     * // Count the number of ExerciseSubmissions
     * const count = await prisma.exerciseSubmission.count({
     *   where: {
     *     // ... the filter for the ExerciseSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ExerciseSubmissionCountArgs>(
      args?: Subset<T, ExerciseSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseSubmissionAggregateArgs>(args: Subset<T, ExerciseSubmissionAggregateArgs>): Prisma.PrismaPromise<GetExerciseSubmissionAggregateType<T>>

    /**
     * Group by ExerciseSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseSubmission model
   */
  readonly fields: ExerciseSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enrollment<T extends EnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnrollmentDefaultArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseSubmission model
   */
  interface ExerciseSubmissionFieldRefs {
    readonly id: FieldRef<"ExerciseSubmission", 'Int'>
    readonly exerciseId: FieldRef<"ExerciseSubmission", 'Int'>
    readonly enrollmentId: FieldRef<"ExerciseSubmission", 'Int'>
    readonly userId: FieldRef<"ExerciseSubmission", 'Int'>
    readonly submittedAt: FieldRef<"ExerciseSubmission", 'DateTime'>
    readonly content: FieldRef<"ExerciseSubmission", 'String'>
    readonly fileUrl: FieldRef<"ExerciseSubmission", 'String'>
    readonly score: FieldRef<"ExerciseSubmission", 'Int'>
    readonly feedback: FieldRef<"ExerciseSubmission", 'String'>
    readonly gradedAt: FieldRef<"ExerciseSubmission", 'DateTime'>
    readonly gradedBy: FieldRef<"ExerciseSubmission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseSubmission findUnique
   */
  export type ExerciseSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission findUniqueOrThrow
   */
  export type ExerciseSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission findFirst
   */
  export type ExerciseSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseSubmissions.
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseSubmissions.
     */
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * ExerciseSubmission findFirstOrThrow
   */
  export type ExerciseSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseSubmissions.
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseSubmissions.
     */
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * ExerciseSubmission findMany
   */
  export type ExerciseSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmissions to fetch.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseSubmissions.
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * ExerciseSubmission create
   */
  export type ExerciseSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseSubmission.
     */
    data: XOR<ExerciseSubmissionCreateInput, ExerciseSubmissionUncheckedCreateInput>
  }

  /**
   * ExerciseSubmission createMany
   */
  export type ExerciseSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseSubmissions.
     */
    data: ExerciseSubmissionCreateManyInput | ExerciseSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseSubmission createManyAndReturn
   */
  export type ExerciseSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciseSubmissions.
     */
    data: ExerciseSubmissionCreateManyInput | ExerciseSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseSubmission update
   */
  export type ExerciseSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseSubmission.
     */
    data: XOR<ExerciseSubmissionUpdateInput, ExerciseSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ExerciseSubmission to update.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission updateMany
   */
  export type ExerciseSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseSubmissions.
     */
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseSubmissions to update
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * Limit how many ExerciseSubmissions to update.
     */
    limit?: number
  }

  /**
   * ExerciseSubmission updateManyAndReturn
   */
  export type ExerciseSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ExerciseSubmissions.
     */
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseSubmissions to update
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * Limit how many ExerciseSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseSubmission upsert
   */
  export type ExerciseSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseSubmission to update in case it exists.
     */
    where: ExerciseSubmissionWhereUniqueInput
    /**
     * In case the ExerciseSubmission found by the `where` argument doesn't exist, create a new ExerciseSubmission with this data.
     */
    create: XOR<ExerciseSubmissionCreateInput, ExerciseSubmissionUncheckedCreateInput>
    /**
     * In case the ExerciseSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseSubmissionUpdateInput, ExerciseSubmissionUncheckedUpdateInput>
  }

  /**
   * ExerciseSubmission delete
   */
  export type ExerciseSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter which ExerciseSubmission to delete.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission deleteMany
   */
  export type ExerciseSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseSubmissions to delete
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * Limit how many ExerciseSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ExerciseSubmission without action
   */
  export type ExerciseSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model CourseReview
   */

  export type AggregateCourseReview = {
    _count: CourseReviewCountAggregateOutputType | null
    _avg: CourseReviewAvgAggregateOutputType | null
    _sum: CourseReviewSumAggregateOutputType | null
    _min: CourseReviewMinAggregateOutputType | null
    _max: CourseReviewMaxAggregateOutputType | null
  }

  export type CourseReviewAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    rating: number | null
  }

  export type CourseReviewSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    rating: number | null
  }

  export type CourseReviewMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isPublished: boolean | null
  }

  export type CourseReviewMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isPublished: boolean | null
  }

  export type CourseReviewCountAggregateOutputType = {
    id: number
    courseId: number
    userId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    isPublished: number
    _all: number
  }


  export type CourseReviewAvgAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    rating?: true
  }

  export type CourseReviewSumAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    rating?: true
  }

  export type CourseReviewMinAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    isPublished?: true
  }

  export type CourseReviewMaxAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    isPublished?: true
  }

  export type CourseReviewCountAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    isPublished?: true
    _all?: true
  }

  export type CourseReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseReview to aggregate.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseReviews
    **/
    _count?: true | CourseReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseReviewMaxAggregateInputType
  }

  export type GetCourseReviewAggregateType<T extends CourseReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseReview[P]>
      : GetScalarType<T[P], AggregateCourseReview[P]>
  }




  export type CourseReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseReviewWhereInput
    orderBy?: CourseReviewOrderByWithAggregationInput | CourseReviewOrderByWithAggregationInput[]
    by: CourseReviewScalarFieldEnum[] | CourseReviewScalarFieldEnum
    having?: CourseReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseReviewCountAggregateInputType | true
    _avg?: CourseReviewAvgAggregateInputType
    _sum?: CourseReviewSumAggregateInputType
    _min?: CourseReviewMinAggregateInputType
    _max?: CourseReviewMaxAggregateInputType
  }

  export type CourseReviewGroupByOutputType = {
    id: number
    courseId: number
    userId: number
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    isPublished: boolean
    _count: CourseReviewCountAggregateOutputType | null
    _avg: CourseReviewAvgAggregateOutputType | null
    _sum: CourseReviewSumAggregateOutputType | null
    _min: CourseReviewMinAggregateOutputType | null
    _max: CourseReviewMaxAggregateOutputType | null
  }

  type GetCourseReviewGroupByPayload<T extends CourseReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseReviewGroupByOutputType[P]>
            : GetScalarType<T[P], CourseReviewGroupByOutputType[P]>
        }
      >
    >


  export type CourseReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublished?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseReview"]>

  export type CourseReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublished?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseReview"]>

  export type CourseReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublished?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseReview"]>

  export type CourseReviewSelectScalar = {
    id?: boolean
    courseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isPublished?: boolean
  }

  export type CourseReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "userId" | "rating" | "comment" | "createdAt" | "updatedAt" | "isPublished", ExtArgs["result"]["courseReview"]>
  export type CourseReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseReview"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      userId: number
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
      isPublished: boolean
    }, ExtArgs["result"]["courseReview"]>
    composites: {}
  }

  type CourseReviewGetPayload<S extends boolean | null | undefined | CourseReviewDefaultArgs> = $Result.GetResult<Prisma.$CourseReviewPayload, S>

  type CourseReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseReviewCountAggregateInputType | true
    }

  export interface CourseReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseReview'], meta: { name: 'CourseReview' } }
    /**
     * Find zero or one CourseReview that matches the filter.
     * @param {CourseReviewFindUniqueArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseReviewFindUniqueArgs>(args: SelectSubset<T, CourseReviewFindUniqueArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseReviewFindUniqueOrThrowArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewFindFirstArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseReviewFindFirstArgs>(args?: SelectSubset<T, CourseReviewFindFirstArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewFindFirstOrThrowArgs} args - Arguments to find a CourseReview
     * @example
     * // Get one CourseReview
     * const courseReview = await prisma.courseReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseReviews
     * const courseReviews = await prisma.courseReview.findMany()
     * 
     * // Get first 10 CourseReviews
     * const courseReviews = await prisma.courseReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseReviewWithIdOnly = await prisma.courseReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseReviewFindManyArgs>(args?: SelectSubset<T, CourseReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseReview.
     * @param {CourseReviewCreateArgs} args - Arguments to create a CourseReview.
     * @example
     * // Create one CourseReview
     * const CourseReview = await prisma.courseReview.create({
     *   data: {
     *     // ... data to create a CourseReview
     *   }
     * })
     * 
     */
    create<T extends CourseReviewCreateArgs>(args: SelectSubset<T, CourseReviewCreateArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseReviews.
     * @param {CourseReviewCreateManyArgs} args - Arguments to create many CourseReviews.
     * @example
     * // Create many CourseReviews
     * const courseReview = await prisma.courseReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseReviewCreateManyArgs>(args?: SelectSubset<T, CourseReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseReviews and returns the data saved in the database.
     * @param {CourseReviewCreateManyAndReturnArgs} args - Arguments to create many CourseReviews.
     * @example
     * // Create many CourseReviews
     * const courseReview = await prisma.courseReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseReviews and only return the `id`
     * const courseReviewWithIdOnly = await prisma.courseReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseReview.
     * @param {CourseReviewDeleteArgs} args - Arguments to delete one CourseReview.
     * @example
     * // Delete one CourseReview
     * const CourseReview = await prisma.courseReview.delete({
     *   where: {
     *     // ... filter to delete one CourseReview
     *   }
     * })
     * 
     */
    delete<T extends CourseReviewDeleteArgs>(args: SelectSubset<T, CourseReviewDeleteArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseReview.
     * @param {CourseReviewUpdateArgs} args - Arguments to update one CourseReview.
     * @example
     * // Update one CourseReview
     * const courseReview = await prisma.courseReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseReviewUpdateArgs>(args: SelectSubset<T, CourseReviewUpdateArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseReviews.
     * @param {CourseReviewDeleteManyArgs} args - Arguments to filter CourseReviews to delete.
     * @example
     * // Delete a few CourseReviews
     * const { count } = await prisma.courseReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseReviewDeleteManyArgs>(args?: SelectSubset<T, CourseReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseReviews
     * const courseReview = await prisma.courseReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseReviewUpdateManyArgs>(args: SelectSubset<T, CourseReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseReviews and returns the data updated in the database.
     * @param {CourseReviewUpdateManyAndReturnArgs} args - Arguments to update many CourseReviews.
     * @example
     * // Update many CourseReviews
     * const courseReview = await prisma.courseReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseReviews and only return the `id`
     * const courseReviewWithIdOnly = await prisma.courseReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseReview.
     * @param {CourseReviewUpsertArgs} args - Arguments to update or create a CourseReview.
     * @example
     * // Update or create a CourseReview
     * const courseReview = await prisma.courseReview.upsert({
     *   create: {
     *     // ... data to create a CourseReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseReview we want to update
     *   }
     * })
     */
    upsert<T extends CourseReviewUpsertArgs>(args: SelectSubset<T, CourseReviewUpsertArgs<ExtArgs>>): Prisma__CourseReviewClient<$Result.GetResult<Prisma.$CourseReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewCountArgs} args - Arguments to filter CourseReviews to count.
     * @example
     * // Count the number of CourseReviews
     * const count = await prisma.courseReview.count({
     *   where: {
     *     // ... the filter for the CourseReviews we want to count
     *   }
     * })
    **/
    count<T extends CourseReviewCountArgs>(
      args?: Subset<T, CourseReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseReviewAggregateArgs>(args: Subset<T, CourseReviewAggregateArgs>): Prisma.PrismaPromise<GetCourseReviewAggregateType<T>>

    /**
     * Group by CourseReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseReviewGroupByArgs['orderBy'] }
        : { orderBy?: CourseReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseReview model
   */
  readonly fields: CourseReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseReview model
   */
  interface CourseReviewFieldRefs {
    readonly id: FieldRef<"CourseReview", 'Int'>
    readonly courseId: FieldRef<"CourseReview", 'Int'>
    readonly userId: FieldRef<"CourseReview", 'Int'>
    readonly rating: FieldRef<"CourseReview", 'Int'>
    readonly comment: FieldRef<"CourseReview", 'String'>
    readonly createdAt: FieldRef<"CourseReview", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseReview", 'DateTime'>
    readonly isPublished: FieldRef<"CourseReview", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CourseReview findUnique
   */
  export type CourseReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview findUniqueOrThrow
   */
  export type CourseReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview findFirst
   */
  export type CourseReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseReviews.
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseReviews.
     */
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * CourseReview findFirstOrThrow
   */
  export type CourseReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReview to fetch.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseReviews.
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseReviews.
     */
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * CourseReview findMany
   */
  export type CourseReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter, which CourseReviews to fetch.
     */
    where?: CourseReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseReviews to fetch.
     */
    orderBy?: CourseReviewOrderByWithRelationInput | CourseReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseReviews.
     */
    cursor?: CourseReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseReviews.
     */
    skip?: number
    distinct?: CourseReviewScalarFieldEnum | CourseReviewScalarFieldEnum[]
  }

  /**
   * CourseReview create
   */
  export type CourseReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseReview.
     */
    data: XOR<CourseReviewCreateInput, CourseReviewUncheckedCreateInput>
  }

  /**
   * CourseReview createMany
   */
  export type CourseReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseReviews.
     */
    data: CourseReviewCreateManyInput | CourseReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseReview createManyAndReturn
   */
  export type CourseReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * The data used to create many CourseReviews.
     */
    data: CourseReviewCreateManyInput | CourseReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseReview update
   */
  export type CourseReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseReview.
     */
    data: XOR<CourseReviewUpdateInput, CourseReviewUncheckedUpdateInput>
    /**
     * Choose, which CourseReview to update.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview updateMany
   */
  export type CourseReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseReviews.
     */
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyInput>
    /**
     * Filter which CourseReviews to update
     */
    where?: CourseReviewWhereInput
    /**
     * Limit how many CourseReviews to update.
     */
    limit?: number
  }

  /**
   * CourseReview updateManyAndReturn
   */
  export type CourseReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * The data used to update CourseReviews.
     */
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyInput>
    /**
     * Filter which CourseReviews to update
     */
    where?: CourseReviewWhereInput
    /**
     * Limit how many CourseReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseReview upsert
   */
  export type CourseReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseReview to update in case it exists.
     */
    where: CourseReviewWhereUniqueInput
    /**
     * In case the CourseReview found by the `where` argument doesn't exist, create a new CourseReview with this data.
     */
    create: XOR<CourseReviewCreateInput, CourseReviewUncheckedCreateInput>
    /**
     * In case the CourseReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseReviewUpdateInput, CourseReviewUncheckedUpdateInput>
  }

  /**
   * CourseReview delete
   */
  export type CourseReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
    /**
     * Filter which CourseReview to delete.
     */
    where: CourseReviewWhereUniqueInput
  }

  /**
   * CourseReview deleteMany
   */
  export type CourseReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseReviews to delete
     */
    where?: CourseReviewWhereInput
    /**
     * Limit how many CourseReviews to delete.
     */
    limit?: number
  }

  /**
   * CourseReview without action
   */
  export type CourseReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseReview
     */
    select?: CourseReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseReview
     */
    omit?: CourseReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseReviewInclude<ExtArgs> | null
  }


  /**
   * Model MentorshipProgram
   */

  export type AggregateMentorshipProgram = {
    _count: MentorshipProgramCountAggregateOutputType | null
    _avg: MentorshipProgramAvgAggregateOutputType | null
    _sum: MentorshipProgramSumAggregateOutputType | null
    _min: MentorshipProgramMinAggregateOutputType | null
    _max: MentorshipProgramMaxAggregateOutputType | null
  }

  export type MentorshipProgramAvgAggregateOutputType = {
    id: number | null
    maxMentees: number | null
  }

  export type MentorshipProgramSumAggregateOutputType = {
    id: number | null
    maxMentees: number | null
  }

  export type MentorshipProgramMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    maxMentees: number | null
    isActive: boolean | null
  }

  export type MentorshipProgramMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    maxMentees: number | null
    isActive: boolean | null
  }

  export type MentorshipProgramCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    maxMentees: number
    isActive: number
    _all: number
  }


  export type MentorshipProgramAvgAggregateInputType = {
    id?: true
    maxMentees?: true
  }

  export type MentorshipProgramSumAggregateInputType = {
    id?: true
    maxMentees?: true
  }

  export type MentorshipProgramMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    maxMentees?: true
    isActive?: true
  }

  export type MentorshipProgramMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    maxMentees?: true
    isActive?: true
  }

  export type MentorshipProgramCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    maxMentees?: true
    isActive?: true
    _all?: true
  }

  export type MentorshipProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorshipProgram to aggregate.
     */
    where?: MentorshipProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipPrograms to fetch.
     */
    orderBy?: MentorshipProgramOrderByWithRelationInput | MentorshipProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorshipProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorshipPrograms
    **/
    _count?: true | MentorshipProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorshipProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorshipProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorshipProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorshipProgramMaxAggregateInputType
  }

  export type GetMentorshipProgramAggregateType<T extends MentorshipProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorshipProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorshipProgram[P]>
      : GetScalarType<T[P], AggregateMentorshipProgram[P]>
  }




  export type MentorshipProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipProgramWhereInput
    orderBy?: MentorshipProgramOrderByWithAggregationInput | MentorshipProgramOrderByWithAggregationInput[]
    by: MentorshipProgramScalarFieldEnum[] | MentorshipProgramScalarFieldEnum
    having?: MentorshipProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorshipProgramCountAggregateInputType | true
    _avg?: MentorshipProgramAvgAggregateInputType
    _sum?: MentorshipProgramSumAggregateInputType
    _min?: MentorshipProgramMinAggregateInputType
    _max?: MentorshipProgramMaxAggregateInputType
  }

  export type MentorshipProgramGroupByOutputType = {
    id: number
    title: string
    description: string
    startDate: Date
    endDate: Date | null
    maxMentees: number
    isActive: boolean
    _count: MentorshipProgramCountAggregateOutputType | null
    _avg: MentorshipProgramAvgAggregateOutputType | null
    _sum: MentorshipProgramSumAggregateOutputType | null
    _min: MentorshipProgramMinAggregateOutputType | null
    _max: MentorshipProgramMaxAggregateOutputType | null
  }

  type GetMentorshipProgramGroupByPayload<T extends MentorshipProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorshipProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorshipProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorshipProgramGroupByOutputType[P]>
            : GetScalarType<T[P], MentorshipProgramGroupByOutputType[P]>
        }
      >
    >


  export type MentorshipProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    isActive?: boolean
    relationships?: boolean | MentorshipProgram$relationshipsArgs<ExtArgs>
    _count?: boolean | MentorshipProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipProgram"]>

  export type MentorshipProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["mentorshipProgram"]>

  export type MentorshipProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["mentorshipProgram"]>

  export type MentorshipProgramSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxMentees?: boolean
    isActive?: boolean
  }

  export type MentorshipProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "endDate" | "maxMentees" | "isActive", ExtArgs["result"]["mentorshipProgram"]>
  export type MentorshipProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationships?: boolean | MentorshipProgram$relationshipsArgs<ExtArgs>
    _count?: boolean | MentorshipProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MentorshipProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MentorshipProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MentorshipProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorshipProgram"
    objects: {
      relationships: Prisma.$MentorshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      startDate: Date
      endDate: Date | null
      maxMentees: number
      isActive: boolean
    }, ExtArgs["result"]["mentorshipProgram"]>
    composites: {}
  }

  type MentorshipProgramGetPayload<S extends boolean | null | undefined | MentorshipProgramDefaultArgs> = $Result.GetResult<Prisma.$MentorshipProgramPayload, S>

  type MentorshipProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorshipProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorshipProgramCountAggregateInputType | true
    }

  export interface MentorshipProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorshipProgram'], meta: { name: 'MentorshipProgram' } }
    /**
     * Find zero or one MentorshipProgram that matches the filter.
     * @param {MentorshipProgramFindUniqueArgs} args - Arguments to find a MentorshipProgram
     * @example
     * // Get one MentorshipProgram
     * const mentorshipProgram = await prisma.mentorshipProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorshipProgramFindUniqueArgs>(args: SelectSubset<T, MentorshipProgramFindUniqueArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorshipProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorshipProgramFindUniqueOrThrowArgs} args - Arguments to find a MentorshipProgram
     * @example
     * // Get one MentorshipProgram
     * const mentorshipProgram = await prisma.mentorshipProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorshipProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorshipProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorshipProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramFindFirstArgs} args - Arguments to find a MentorshipProgram
     * @example
     * // Get one MentorshipProgram
     * const mentorshipProgram = await prisma.mentorshipProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorshipProgramFindFirstArgs>(args?: SelectSubset<T, MentorshipProgramFindFirstArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorshipProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramFindFirstOrThrowArgs} args - Arguments to find a MentorshipProgram
     * @example
     * // Get one MentorshipProgram
     * const mentorshipProgram = await prisma.mentorshipProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorshipProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorshipProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorshipPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorshipPrograms
     * const mentorshipPrograms = await prisma.mentorshipProgram.findMany()
     * 
     * // Get first 10 MentorshipPrograms
     * const mentorshipPrograms = await prisma.mentorshipProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorshipProgramWithIdOnly = await prisma.mentorshipProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorshipProgramFindManyArgs>(args?: SelectSubset<T, MentorshipProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorshipProgram.
     * @param {MentorshipProgramCreateArgs} args - Arguments to create a MentorshipProgram.
     * @example
     * // Create one MentorshipProgram
     * const MentorshipProgram = await prisma.mentorshipProgram.create({
     *   data: {
     *     // ... data to create a MentorshipProgram
     *   }
     * })
     * 
     */
    create<T extends MentorshipProgramCreateArgs>(args: SelectSubset<T, MentorshipProgramCreateArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorshipPrograms.
     * @param {MentorshipProgramCreateManyArgs} args - Arguments to create many MentorshipPrograms.
     * @example
     * // Create many MentorshipPrograms
     * const mentorshipProgram = await prisma.mentorshipProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorshipProgramCreateManyArgs>(args?: SelectSubset<T, MentorshipProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorshipPrograms and returns the data saved in the database.
     * @param {MentorshipProgramCreateManyAndReturnArgs} args - Arguments to create many MentorshipPrograms.
     * @example
     * // Create many MentorshipPrograms
     * const mentorshipProgram = await prisma.mentorshipProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorshipPrograms and only return the `id`
     * const mentorshipProgramWithIdOnly = await prisma.mentorshipProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorshipProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorshipProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorshipProgram.
     * @param {MentorshipProgramDeleteArgs} args - Arguments to delete one MentorshipProgram.
     * @example
     * // Delete one MentorshipProgram
     * const MentorshipProgram = await prisma.mentorshipProgram.delete({
     *   where: {
     *     // ... filter to delete one MentorshipProgram
     *   }
     * })
     * 
     */
    delete<T extends MentorshipProgramDeleteArgs>(args: SelectSubset<T, MentorshipProgramDeleteArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorshipProgram.
     * @param {MentorshipProgramUpdateArgs} args - Arguments to update one MentorshipProgram.
     * @example
     * // Update one MentorshipProgram
     * const mentorshipProgram = await prisma.mentorshipProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorshipProgramUpdateArgs>(args: SelectSubset<T, MentorshipProgramUpdateArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorshipPrograms.
     * @param {MentorshipProgramDeleteManyArgs} args - Arguments to filter MentorshipPrograms to delete.
     * @example
     * // Delete a few MentorshipPrograms
     * const { count } = await prisma.mentorshipProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorshipProgramDeleteManyArgs>(args?: SelectSubset<T, MentorshipProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorshipPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorshipPrograms
     * const mentorshipProgram = await prisma.mentorshipProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorshipProgramUpdateManyArgs>(args: SelectSubset<T, MentorshipProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorshipPrograms and returns the data updated in the database.
     * @param {MentorshipProgramUpdateManyAndReturnArgs} args - Arguments to update many MentorshipPrograms.
     * @example
     * // Update many MentorshipPrograms
     * const mentorshipProgram = await prisma.mentorshipProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorshipPrograms and only return the `id`
     * const mentorshipProgramWithIdOnly = await prisma.mentorshipProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorshipProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorshipProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorshipProgram.
     * @param {MentorshipProgramUpsertArgs} args - Arguments to update or create a MentorshipProgram.
     * @example
     * // Update or create a MentorshipProgram
     * const mentorshipProgram = await prisma.mentorshipProgram.upsert({
     *   create: {
     *     // ... data to create a MentorshipProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorshipProgram we want to update
     *   }
     * })
     */
    upsert<T extends MentorshipProgramUpsertArgs>(args: SelectSubset<T, MentorshipProgramUpsertArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorshipPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramCountArgs} args - Arguments to filter MentorshipPrograms to count.
     * @example
     * // Count the number of MentorshipPrograms
     * const count = await prisma.mentorshipProgram.count({
     *   where: {
     *     // ... the filter for the MentorshipPrograms we want to count
     *   }
     * })
    **/
    count<T extends MentorshipProgramCountArgs>(
      args?: Subset<T, MentorshipProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorshipProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorshipProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorshipProgramAggregateArgs>(args: Subset<T, MentorshipProgramAggregateArgs>): Prisma.PrismaPromise<GetMentorshipProgramAggregateType<T>>

    /**
     * Group by MentorshipProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorshipProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorshipProgramGroupByArgs['orderBy'] }
        : { orderBy?: MentorshipProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorshipProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorshipProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorshipProgram model
   */
  readonly fields: MentorshipProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorshipProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorshipProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationships<T extends MentorshipProgram$relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, MentorshipProgram$relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorshipProgram model
   */
  interface MentorshipProgramFieldRefs {
    readonly id: FieldRef<"MentorshipProgram", 'Int'>
    readonly title: FieldRef<"MentorshipProgram", 'String'>
    readonly description: FieldRef<"MentorshipProgram", 'String'>
    readonly startDate: FieldRef<"MentorshipProgram", 'DateTime'>
    readonly endDate: FieldRef<"MentorshipProgram", 'DateTime'>
    readonly maxMentees: FieldRef<"MentorshipProgram", 'Int'>
    readonly isActive: FieldRef<"MentorshipProgram", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MentorshipProgram findUnique
   */
  export type MentorshipProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipProgram to fetch.
     */
    where: MentorshipProgramWhereUniqueInput
  }

  /**
   * MentorshipProgram findUniqueOrThrow
   */
  export type MentorshipProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipProgram to fetch.
     */
    where: MentorshipProgramWhereUniqueInput
  }

  /**
   * MentorshipProgram findFirst
   */
  export type MentorshipProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipProgram to fetch.
     */
    where?: MentorshipProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipPrograms to fetch.
     */
    orderBy?: MentorshipProgramOrderByWithRelationInput | MentorshipProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorshipPrograms.
     */
    cursor?: MentorshipProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorshipPrograms.
     */
    distinct?: MentorshipProgramScalarFieldEnum | MentorshipProgramScalarFieldEnum[]
  }

  /**
   * MentorshipProgram findFirstOrThrow
   */
  export type MentorshipProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipProgram to fetch.
     */
    where?: MentorshipProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipPrograms to fetch.
     */
    orderBy?: MentorshipProgramOrderByWithRelationInput | MentorshipProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorshipPrograms.
     */
    cursor?: MentorshipProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorshipPrograms.
     */
    distinct?: MentorshipProgramScalarFieldEnum | MentorshipProgramScalarFieldEnum[]
  }

  /**
   * MentorshipProgram findMany
   */
  export type MentorshipProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipPrograms to fetch.
     */
    where?: MentorshipProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipPrograms to fetch.
     */
    orderBy?: MentorshipProgramOrderByWithRelationInput | MentorshipProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorshipPrograms.
     */
    cursor?: MentorshipProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipPrograms.
     */
    skip?: number
    distinct?: MentorshipProgramScalarFieldEnum | MentorshipProgramScalarFieldEnum[]
  }

  /**
   * MentorshipProgram create
   */
  export type MentorshipProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorshipProgram.
     */
    data: XOR<MentorshipProgramCreateInput, MentorshipProgramUncheckedCreateInput>
  }

  /**
   * MentorshipProgram createMany
   */
  export type MentorshipProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorshipPrograms.
     */
    data: MentorshipProgramCreateManyInput | MentorshipProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorshipProgram createManyAndReturn
   */
  export type MentorshipProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * The data used to create many MentorshipPrograms.
     */
    data: MentorshipProgramCreateManyInput | MentorshipProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorshipProgram update
   */
  export type MentorshipProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorshipProgram.
     */
    data: XOR<MentorshipProgramUpdateInput, MentorshipProgramUncheckedUpdateInput>
    /**
     * Choose, which MentorshipProgram to update.
     */
    where: MentorshipProgramWhereUniqueInput
  }

  /**
   * MentorshipProgram updateMany
   */
  export type MentorshipProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorshipPrograms.
     */
    data: XOR<MentorshipProgramUpdateManyMutationInput, MentorshipProgramUncheckedUpdateManyInput>
    /**
     * Filter which MentorshipPrograms to update
     */
    where?: MentorshipProgramWhereInput
    /**
     * Limit how many MentorshipPrograms to update.
     */
    limit?: number
  }

  /**
   * MentorshipProgram updateManyAndReturn
   */
  export type MentorshipProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * The data used to update MentorshipPrograms.
     */
    data: XOR<MentorshipProgramUpdateManyMutationInput, MentorshipProgramUncheckedUpdateManyInput>
    /**
     * Filter which MentorshipPrograms to update
     */
    where?: MentorshipProgramWhereInput
    /**
     * Limit how many MentorshipPrograms to update.
     */
    limit?: number
  }

  /**
   * MentorshipProgram upsert
   */
  export type MentorshipProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorshipProgram to update in case it exists.
     */
    where: MentorshipProgramWhereUniqueInput
    /**
     * In case the MentorshipProgram found by the `where` argument doesn't exist, create a new MentorshipProgram with this data.
     */
    create: XOR<MentorshipProgramCreateInput, MentorshipProgramUncheckedCreateInput>
    /**
     * In case the MentorshipProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorshipProgramUpdateInput, MentorshipProgramUncheckedUpdateInput>
  }

  /**
   * MentorshipProgram delete
   */
  export type MentorshipProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    /**
     * Filter which MentorshipProgram to delete.
     */
    where: MentorshipProgramWhereUniqueInput
  }

  /**
   * MentorshipProgram deleteMany
   */
  export type MentorshipProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorshipPrograms to delete
     */
    where?: MentorshipProgramWhereInput
    /**
     * Limit how many MentorshipPrograms to delete.
     */
    limit?: number
  }

  /**
   * MentorshipProgram.relationships
   */
  export type MentorshipProgram$relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    cursor?: MentorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * MentorshipProgram without action
   */
  export type MentorshipProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
  }


  /**
   * Model Mentorship
   */

  export type AggregateMentorship = {
    _count: MentorshipCountAggregateOutputType | null
    _avg: MentorshipAvgAggregateOutputType | null
    _sum: MentorshipSumAggregateOutputType | null
    _min: MentorshipMinAggregateOutputType | null
    _max: MentorshipMaxAggregateOutputType | null
  }

  export type MentorshipAvgAggregateOutputType = {
    id: number | null
    mentorId: number | null
    menteeId: number | null
    programId: number | null
  }

  export type MentorshipSumAggregateOutputType = {
    id: number | null
    mentorId: number | null
    menteeId: number | null
    programId: number | null
  }

  export type MentorshipMinAggregateOutputType = {
    id: number | null
    mentorId: number | null
    menteeId: number | null
    programId: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.StatusType | null
  }

  export type MentorshipMaxAggregateOutputType = {
    id: number | null
    mentorId: number | null
    menteeId: number | null
    programId: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.StatusType | null
  }

  export type MentorshipCountAggregateOutputType = {
    id: number
    mentorId: number
    menteeId: number
    programId: number
    startDate: number
    endDate: number
    status: number
    _all: number
  }


  export type MentorshipAvgAggregateInputType = {
    id?: true
    mentorId?: true
    menteeId?: true
    programId?: true
  }

  export type MentorshipSumAggregateInputType = {
    id?: true
    mentorId?: true
    menteeId?: true
    programId?: true
  }

  export type MentorshipMinAggregateInputType = {
    id?: true
    mentorId?: true
    menteeId?: true
    programId?: true
    startDate?: true
    endDate?: true
    status?: true
  }

  export type MentorshipMaxAggregateInputType = {
    id?: true
    mentorId?: true
    menteeId?: true
    programId?: true
    startDate?: true
    endDate?: true
    status?: true
  }

  export type MentorshipCountAggregateInputType = {
    id?: true
    mentorId?: true
    menteeId?: true
    programId?: true
    startDate?: true
    endDate?: true
    status?: true
    _all?: true
  }

  export type MentorshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentorship to aggregate.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentorships
    **/
    _count?: true | MentorshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorshipMaxAggregateInputType
  }

  export type GetMentorshipAggregateType<T extends MentorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorship[P]>
      : GetScalarType<T[P], AggregateMentorship[P]>
  }




  export type MentorshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipWhereInput
    orderBy?: MentorshipOrderByWithAggregationInput | MentorshipOrderByWithAggregationInput[]
    by: MentorshipScalarFieldEnum[] | MentorshipScalarFieldEnum
    having?: MentorshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorshipCountAggregateInputType | true
    _avg?: MentorshipAvgAggregateInputType
    _sum?: MentorshipSumAggregateInputType
    _min?: MentorshipMinAggregateInputType
    _max?: MentorshipMaxAggregateInputType
  }

  export type MentorshipGroupByOutputType = {
    id: number
    mentorId: number
    menteeId: number
    programId: number | null
    startDate: Date
    endDate: Date | null
    status: $Enums.StatusType
    _count: MentorshipCountAggregateOutputType | null
    _avg: MentorshipAvgAggregateOutputType | null
    _sum: MentorshipSumAggregateOutputType | null
    _min: MentorshipMinAggregateOutputType | null
    _max: MentorshipMaxAggregateOutputType | null
  }

  type GetMentorshipGroupByPayload<T extends MentorshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorshipGroupByOutputType[P]>
            : GetScalarType<T[P], MentorshipGroupByOutputType[P]>
        }
      >
    >


  export type MentorshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    menteeId?: boolean
    programId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | Mentorship$programArgs<ExtArgs>
    sessions?: boolean | Mentorship$sessionsArgs<ExtArgs>
    _count?: boolean | MentorshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorship"]>

  export type MentorshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    menteeId?: boolean
    programId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | Mentorship$programArgs<ExtArgs>
  }, ExtArgs["result"]["mentorship"]>

  export type MentorshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    menteeId?: boolean
    programId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | Mentorship$programArgs<ExtArgs>
  }, ExtArgs["result"]["mentorship"]>

  export type MentorshipSelectScalar = {
    id?: boolean
    mentorId?: boolean
    menteeId?: boolean
    programId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
  }

  export type MentorshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mentorId" | "menteeId" | "programId" | "startDate" | "endDate" | "status", ExtArgs["result"]["mentorship"]>
  export type MentorshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | Mentorship$programArgs<ExtArgs>
    sessions?: boolean | Mentorship$sessionsArgs<ExtArgs>
    _count?: boolean | MentorshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MentorshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | Mentorship$programArgs<ExtArgs>
  }
  export type MentorshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee?: boolean | UserDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | Mentorship$programArgs<ExtArgs>
  }

  export type $MentorshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mentorship"
    objects: {
      mentee: Prisma.$UserPayload<ExtArgs>
      mentor: Prisma.$UserPayload<ExtArgs>
      program: Prisma.$MentorshipProgramPayload<ExtArgs> | null
      sessions: Prisma.$MentorshipSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mentorId: number
      menteeId: number
      programId: number | null
      startDate: Date
      endDate: Date | null
      status: $Enums.StatusType
    }, ExtArgs["result"]["mentorship"]>
    composites: {}
  }

  type MentorshipGetPayload<S extends boolean | null | undefined | MentorshipDefaultArgs> = $Result.GetResult<Prisma.$MentorshipPayload, S>

  type MentorshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorshipCountAggregateInputType | true
    }

  export interface MentorshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentorship'], meta: { name: 'Mentorship' } }
    /**
     * Find zero or one Mentorship that matches the filter.
     * @param {MentorshipFindUniqueArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorshipFindUniqueArgs>(args: SelectSubset<T, MentorshipFindUniqueArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mentorship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorshipFindUniqueOrThrowArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorshipFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentorship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipFindFirstArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorshipFindFirstArgs>(args?: SelectSubset<T, MentorshipFindFirstArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentorship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipFindFirstOrThrowArgs} args - Arguments to find a Mentorship
     * @example
     * // Get one Mentorship
     * const mentorship = await prisma.mentorship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorshipFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mentorships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentorships
     * const mentorships = await prisma.mentorship.findMany()
     * 
     * // Get first 10 Mentorships
     * const mentorships = await prisma.mentorship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorshipWithIdOnly = await prisma.mentorship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorshipFindManyArgs>(args?: SelectSubset<T, MentorshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mentorship.
     * @param {MentorshipCreateArgs} args - Arguments to create a Mentorship.
     * @example
     * // Create one Mentorship
     * const Mentorship = await prisma.mentorship.create({
     *   data: {
     *     // ... data to create a Mentorship
     *   }
     * })
     * 
     */
    create<T extends MentorshipCreateArgs>(args: SelectSubset<T, MentorshipCreateArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mentorships.
     * @param {MentorshipCreateManyArgs} args - Arguments to create many Mentorships.
     * @example
     * // Create many Mentorships
     * const mentorship = await prisma.mentorship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorshipCreateManyArgs>(args?: SelectSubset<T, MentorshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentorships and returns the data saved in the database.
     * @param {MentorshipCreateManyAndReturnArgs} args - Arguments to create many Mentorships.
     * @example
     * // Create many Mentorships
     * const mentorship = await prisma.mentorship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentorships and only return the `id`
     * const mentorshipWithIdOnly = await prisma.mentorship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorshipCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mentorship.
     * @param {MentorshipDeleteArgs} args - Arguments to delete one Mentorship.
     * @example
     * // Delete one Mentorship
     * const Mentorship = await prisma.mentorship.delete({
     *   where: {
     *     // ... filter to delete one Mentorship
     *   }
     * })
     * 
     */
    delete<T extends MentorshipDeleteArgs>(args: SelectSubset<T, MentorshipDeleteArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mentorship.
     * @param {MentorshipUpdateArgs} args - Arguments to update one Mentorship.
     * @example
     * // Update one Mentorship
     * const mentorship = await prisma.mentorship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorshipUpdateArgs>(args: SelectSubset<T, MentorshipUpdateArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mentorships.
     * @param {MentorshipDeleteManyArgs} args - Arguments to filter Mentorships to delete.
     * @example
     * // Delete a few Mentorships
     * const { count } = await prisma.mentorship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorshipDeleteManyArgs>(args?: SelectSubset<T, MentorshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentorships
     * const mentorship = await prisma.mentorship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorshipUpdateManyArgs>(args: SelectSubset<T, MentorshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentorships and returns the data updated in the database.
     * @param {MentorshipUpdateManyAndReturnArgs} args - Arguments to update many Mentorships.
     * @example
     * // Update many Mentorships
     * const mentorship = await prisma.mentorship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mentorships and only return the `id`
     * const mentorshipWithIdOnly = await prisma.mentorship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorshipUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mentorship.
     * @param {MentorshipUpsertArgs} args - Arguments to update or create a Mentorship.
     * @example
     * // Update or create a Mentorship
     * const mentorship = await prisma.mentorship.upsert({
     *   create: {
     *     // ... data to create a Mentorship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentorship we want to update
     *   }
     * })
     */
    upsert<T extends MentorshipUpsertArgs>(args: SelectSubset<T, MentorshipUpsertArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mentorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipCountArgs} args - Arguments to filter Mentorships to count.
     * @example
     * // Count the number of Mentorships
     * const count = await prisma.mentorship.count({
     *   where: {
     *     // ... the filter for the Mentorships we want to count
     *   }
     * })
    **/
    count<T extends MentorshipCountArgs>(
      args?: Subset<T, MentorshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorshipAggregateArgs>(args: Subset<T, MentorshipAggregateArgs>): Prisma.PrismaPromise<GetMentorshipAggregateType<T>>

    /**
     * Group by Mentorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorshipGroupByArgs['orderBy'] }
        : { orderBy?: MentorshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mentorship model
   */
  readonly fields: MentorshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentorship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mentor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends Mentorship$programArgs<ExtArgs> = {}>(args?: Subset<T, Mentorship$programArgs<ExtArgs>>): Prisma__MentorshipProgramClient<$Result.GetResult<Prisma.$MentorshipProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Mentorship$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Mentorship$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mentorship model
   */
  interface MentorshipFieldRefs {
    readonly id: FieldRef<"Mentorship", 'Int'>
    readonly mentorId: FieldRef<"Mentorship", 'Int'>
    readonly menteeId: FieldRef<"Mentorship", 'Int'>
    readonly programId: FieldRef<"Mentorship", 'Int'>
    readonly startDate: FieldRef<"Mentorship", 'DateTime'>
    readonly endDate: FieldRef<"Mentorship", 'DateTime'>
    readonly status: FieldRef<"Mentorship", 'StatusType'>
  }
    

  // Custom InputTypes
  /**
   * Mentorship findUnique
   */
  export type MentorshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship findUniqueOrThrow
   */
  export type MentorshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship findFirst
   */
  export type MentorshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentorships.
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentorships.
     */
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * Mentorship findFirstOrThrow
   */
  export type MentorshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorship to fetch.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentorships.
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentorships.
     */
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * Mentorship findMany
   */
  export type MentorshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter, which Mentorships to fetch.
     */
    where?: MentorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorships to fetch.
     */
    orderBy?: MentorshipOrderByWithRelationInput | MentorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentorships.
     */
    cursor?: MentorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorships.
     */
    skip?: number
    distinct?: MentorshipScalarFieldEnum | MentorshipScalarFieldEnum[]
  }

  /**
   * Mentorship create
   */
  export type MentorshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Mentorship.
     */
    data: XOR<MentorshipCreateInput, MentorshipUncheckedCreateInput>
  }

  /**
   * Mentorship createMany
   */
  export type MentorshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentorships.
     */
    data: MentorshipCreateManyInput | MentorshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mentorship createManyAndReturn
   */
  export type MentorshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * The data used to create many Mentorships.
     */
    data: MentorshipCreateManyInput | MentorshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentorship update
   */
  export type MentorshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Mentorship.
     */
    data: XOR<MentorshipUpdateInput, MentorshipUncheckedUpdateInput>
    /**
     * Choose, which Mentorship to update.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship updateMany
   */
  export type MentorshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentorships.
     */
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyInput>
    /**
     * Filter which Mentorships to update
     */
    where?: MentorshipWhereInput
    /**
     * Limit how many Mentorships to update.
     */
    limit?: number
  }

  /**
   * Mentorship updateManyAndReturn
   */
  export type MentorshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * The data used to update Mentorships.
     */
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyInput>
    /**
     * Filter which Mentorships to update
     */
    where?: MentorshipWhereInput
    /**
     * Limit how many Mentorships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentorship upsert
   */
  export type MentorshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Mentorship to update in case it exists.
     */
    where: MentorshipWhereUniqueInput
    /**
     * In case the Mentorship found by the `where` argument doesn't exist, create a new Mentorship with this data.
     */
    create: XOR<MentorshipCreateInput, MentorshipUncheckedCreateInput>
    /**
     * In case the Mentorship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorshipUpdateInput, MentorshipUncheckedUpdateInput>
  }

  /**
   * Mentorship delete
   */
  export type MentorshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
    /**
     * Filter which Mentorship to delete.
     */
    where: MentorshipWhereUniqueInput
  }

  /**
   * Mentorship deleteMany
   */
  export type MentorshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentorships to delete
     */
    where?: MentorshipWhereInput
    /**
     * Limit how many Mentorships to delete.
     */
    limit?: number
  }

  /**
   * Mentorship.program
   */
  export type Mentorship$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipProgram
     */
    select?: MentorshipProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipProgram
     */
    omit?: MentorshipProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipProgramInclude<ExtArgs> | null
    where?: MentorshipProgramWhereInput
  }

  /**
   * Mentorship.sessions
   */
  export type Mentorship$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    where?: MentorshipSessionWhereInput
    orderBy?: MentorshipSessionOrderByWithRelationInput | MentorshipSessionOrderByWithRelationInput[]
    cursor?: MentorshipSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorshipSessionScalarFieldEnum | MentorshipSessionScalarFieldEnum[]
  }

  /**
   * Mentorship without action
   */
  export type MentorshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentorship
     */
    select?: MentorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentorship
     */
    omit?: MentorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipInclude<ExtArgs> | null
  }


  /**
   * Model MentorshipSession
   */

  export type AggregateMentorshipSession = {
    _count: MentorshipSessionCountAggregateOutputType | null
    _avg: MentorshipSessionAvgAggregateOutputType | null
    _sum: MentorshipSessionSumAggregateOutputType | null
    _min: MentorshipSessionMinAggregateOutputType | null
    _max: MentorshipSessionMaxAggregateOutputType | null
  }

  export type MentorshipSessionAvgAggregateOutputType = {
    id: number | null
    relationshipId: number | null
    durationMinutes: number | null
  }

  export type MentorshipSessionSumAggregateOutputType = {
    id: number | null
    relationshipId: number | null
    durationMinutes: number | null
  }

  export type MentorshipSessionMinAggregateOutputType = {
    id: number | null
    relationshipId: number | null
    sessionDate: Date | null
    durationMinutes: number | null
    notes: string | null
    status: $Enums.SessionStatus | null
    feedback: string | null
  }

  export type MentorshipSessionMaxAggregateOutputType = {
    id: number | null
    relationshipId: number | null
    sessionDate: Date | null
    durationMinutes: number | null
    notes: string | null
    status: $Enums.SessionStatus | null
    feedback: string | null
  }

  export type MentorshipSessionCountAggregateOutputType = {
    id: number
    relationshipId: number
    sessionDate: number
    durationMinutes: number
    notes: number
    status: number
    feedback: number
    _all: number
  }


  export type MentorshipSessionAvgAggregateInputType = {
    id?: true
    relationshipId?: true
    durationMinutes?: true
  }

  export type MentorshipSessionSumAggregateInputType = {
    id?: true
    relationshipId?: true
    durationMinutes?: true
  }

  export type MentorshipSessionMinAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    durationMinutes?: true
    notes?: true
    status?: true
    feedback?: true
  }

  export type MentorshipSessionMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    durationMinutes?: true
    notes?: true
    status?: true
    feedback?: true
  }

  export type MentorshipSessionCountAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    durationMinutes?: true
    notes?: true
    status?: true
    feedback?: true
    _all?: true
  }

  export type MentorshipSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorshipSession to aggregate.
     */
    where?: MentorshipSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipSessions to fetch.
     */
    orderBy?: MentorshipSessionOrderByWithRelationInput | MentorshipSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorshipSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorshipSessions
    **/
    _count?: true | MentorshipSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorshipSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorshipSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorshipSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorshipSessionMaxAggregateInputType
  }

  export type GetMentorshipSessionAggregateType<T extends MentorshipSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorshipSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorshipSession[P]>
      : GetScalarType<T[P], AggregateMentorshipSession[P]>
  }




  export type MentorshipSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorshipSessionWhereInput
    orderBy?: MentorshipSessionOrderByWithAggregationInput | MentorshipSessionOrderByWithAggregationInput[]
    by: MentorshipSessionScalarFieldEnum[] | MentorshipSessionScalarFieldEnum
    having?: MentorshipSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorshipSessionCountAggregateInputType | true
    _avg?: MentorshipSessionAvgAggregateInputType
    _sum?: MentorshipSessionSumAggregateInputType
    _min?: MentorshipSessionMinAggregateInputType
    _max?: MentorshipSessionMaxAggregateInputType
  }

  export type MentorshipSessionGroupByOutputType = {
    id: number
    relationshipId: number
    sessionDate: Date
    durationMinutes: number
    notes: string | null
    status: $Enums.SessionStatus
    feedback: string | null
    _count: MentorshipSessionCountAggregateOutputType | null
    _avg: MentorshipSessionAvgAggregateOutputType | null
    _sum: MentorshipSessionSumAggregateOutputType | null
    _min: MentorshipSessionMinAggregateOutputType | null
    _max: MentorshipSessionMaxAggregateOutputType | null
  }

  type GetMentorshipSessionGroupByPayload<T extends MentorshipSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorshipSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorshipSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorshipSessionGroupByOutputType[P]>
            : GetScalarType<T[P], MentorshipSessionGroupByOutputType[P]>
        }
      >
    >


  export type MentorshipSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    durationMinutes?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    relationship?: boolean | MentorshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipSession"]>

  export type MentorshipSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    durationMinutes?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    relationship?: boolean | MentorshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipSession"]>

  export type MentorshipSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    durationMinutes?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    relationship?: boolean | MentorshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorshipSession"]>

  export type MentorshipSessionSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    durationMinutes?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
  }

  export type MentorshipSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationshipId" | "sessionDate" | "durationMinutes" | "notes" | "status" | "feedback", ExtArgs["result"]["mentorshipSession"]>
  export type MentorshipSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | MentorshipDefaultArgs<ExtArgs>
  }
  export type MentorshipSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | MentorshipDefaultArgs<ExtArgs>
  }
  export type MentorshipSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | MentorshipDefaultArgs<ExtArgs>
  }

  export type $MentorshipSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorshipSession"
    objects: {
      relationship: Prisma.$MentorshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      relationshipId: number
      sessionDate: Date
      durationMinutes: number
      notes: string | null
      status: $Enums.SessionStatus
      feedback: string | null
    }, ExtArgs["result"]["mentorshipSession"]>
    composites: {}
  }

  type MentorshipSessionGetPayload<S extends boolean | null | undefined | MentorshipSessionDefaultArgs> = $Result.GetResult<Prisma.$MentorshipSessionPayload, S>

  type MentorshipSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorshipSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorshipSessionCountAggregateInputType | true
    }

  export interface MentorshipSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorshipSession'], meta: { name: 'MentorshipSession' } }
    /**
     * Find zero or one MentorshipSession that matches the filter.
     * @param {MentorshipSessionFindUniqueArgs} args - Arguments to find a MentorshipSession
     * @example
     * // Get one MentorshipSession
     * const mentorshipSession = await prisma.mentorshipSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorshipSessionFindUniqueArgs>(args: SelectSubset<T, MentorshipSessionFindUniqueArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorshipSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorshipSessionFindUniqueOrThrowArgs} args - Arguments to find a MentorshipSession
     * @example
     * // Get one MentorshipSession
     * const mentorshipSession = await prisma.mentorshipSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorshipSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorshipSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorshipSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionFindFirstArgs} args - Arguments to find a MentorshipSession
     * @example
     * // Get one MentorshipSession
     * const mentorshipSession = await prisma.mentorshipSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorshipSessionFindFirstArgs>(args?: SelectSubset<T, MentorshipSessionFindFirstArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorshipSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionFindFirstOrThrowArgs} args - Arguments to find a MentorshipSession
     * @example
     * // Get one MentorshipSession
     * const mentorshipSession = await prisma.mentorshipSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorshipSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorshipSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorshipSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorshipSessions
     * const mentorshipSessions = await prisma.mentorshipSession.findMany()
     * 
     * // Get first 10 MentorshipSessions
     * const mentorshipSessions = await prisma.mentorshipSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorshipSessionWithIdOnly = await prisma.mentorshipSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorshipSessionFindManyArgs>(args?: SelectSubset<T, MentorshipSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorshipSession.
     * @param {MentorshipSessionCreateArgs} args - Arguments to create a MentorshipSession.
     * @example
     * // Create one MentorshipSession
     * const MentorshipSession = await prisma.mentorshipSession.create({
     *   data: {
     *     // ... data to create a MentorshipSession
     *   }
     * })
     * 
     */
    create<T extends MentorshipSessionCreateArgs>(args: SelectSubset<T, MentorshipSessionCreateArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorshipSessions.
     * @param {MentorshipSessionCreateManyArgs} args - Arguments to create many MentorshipSessions.
     * @example
     * // Create many MentorshipSessions
     * const mentorshipSession = await prisma.mentorshipSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorshipSessionCreateManyArgs>(args?: SelectSubset<T, MentorshipSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorshipSessions and returns the data saved in the database.
     * @param {MentorshipSessionCreateManyAndReturnArgs} args - Arguments to create many MentorshipSessions.
     * @example
     * // Create many MentorshipSessions
     * const mentorshipSession = await prisma.mentorshipSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorshipSessions and only return the `id`
     * const mentorshipSessionWithIdOnly = await prisma.mentorshipSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorshipSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorshipSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorshipSession.
     * @param {MentorshipSessionDeleteArgs} args - Arguments to delete one MentorshipSession.
     * @example
     * // Delete one MentorshipSession
     * const MentorshipSession = await prisma.mentorshipSession.delete({
     *   where: {
     *     // ... filter to delete one MentorshipSession
     *   }
     * })
     * 
     */
    delete<T extends MentorshipSessionDeleteArgs>(args: SelectSubset<T, MentorshipSessionDeleteArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorshipSession.
     * @param {MentorshipSessionUpdateArgs} args - Arguments to update one MentorshipSession.
     * @example
     * // Update one MentorshipSession
     * const mentorshipSession = await prisma.mentorshipSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorshipSessionUpdateArgs>(args: SelectSubset<T, MentorshipSessionUpdateArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorshipSessions.
     * @param {MentorshipSessionDeleteManyArgs} args - Arguments to filter MentorshipSessions to delete.
     * @example
     * // Delete a few MentorshipSessions
     * const { count } = await prisma.mentorshipSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorshipSessionDeleteManyArgs>(args?: SelectSubset<T, MentorshipSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorshipSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorshipSessions
     * const mentorshipSession = await prisma.mentorshipSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorshipSessionUpdateManyArgs>(args: SelectSubset<T, MentorshipSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorshipSessions and returns the data updated in the database.
     * @param {MentorshipSessionUpdateManyAndReturnArgs} args - Arguments to update many MentorshipSessions.
     * @example
     * // Update many MentorshipSessions
     * const mentorshipSession = await prisma.mentorshipSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorshipSessions and only return the `id`
     * const mentorshipSessionWithIdOnly = await prisma.mentorshipSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorshipSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorshipSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorshipSession.
     * @param {MentorshipSessionUpsertArgs} args - Arguments to update or create a MentorshipSession.
     * @example
     * // Update or create a MentorshipSession
     * const mentorshipSession = await prisma.mentorshipSession.upsert({
     *   create: {
     *     // ... data to create a MentorshipSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorshipSession we want to update
     *   }
     * })
     */
    upsert<T extends MentorshipSessionUpsertArgs>(args: SelectSubset<T, MentorshipSessionUpsertArgs<ExtArgs>>): Prisma__MentorshipSessionClient<$Result.GetResult<Prisma.$MentorshipSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorshipSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionCountArgs} args - Arguments to filter MentorshipSessions to count.
     * @example
     * // Count the number of MentorshipSessions
     * const count = await prisma.mentorshipSession.count({
     *   where: {
     *     // ... the filter for the MentorshipSessions we want to count
     *   }
     * })
    **/
    count<T extends MentorshipSessionCountArgs>(
      args?: Subset<T, MentorshipSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorshipSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorshipSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorshipSessionAggregateArgs>(args: Subset<T, MentorshipSessionAggregateArgs>): Prisma.PrismaPromise<GetMentorshipSessionAggregateType<T>>

    /**
     * Group by MentorshipSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorshipSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorshipSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorshipSessionGroupByArgs['orderBy'] }
        : { orderBy?: MentorshipSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorshipSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorshipSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorshipSession model
   */
  readonly fields: MentorshipSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorshipSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorshipSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends MentorshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorshipDefaultArgs<ExtArgs>>): Prisma__MentorshipClient<$Result.GetResult<Prisma.$MentorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorshipSession model
   */
  interface MentorshipSessionFieldRefs {
    readonly id: FieldRef<"MentorshipSession", 'Int'>
    readonly relationshipId: FieldRef<"MentorshipSession", 'Int'>
    readonly sessionDate: FieldRef<"MentorshipSession", 'DateTime'>
    readonly durationMinutes: FieldRef<"MentorshipSession", 'Int'>
    readonly notes: FieldRef<"MentorshipSession", 'String'>
    readonly status: FieldRef<"MentorshipSession", 'SessionStatus'>
    readonly feedback: FieldRef<"MentorshipSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MentorshipSession findUnique
   */
  export type MentorshipSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipSession to fetch.
     */
    where: MentorshipSessionWhereUniqueInput
  }

  /**
   * MentorshipSession findUniqueOrThrow
   */
  export type MentorshipSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipSession to fetch.
     */
    where: MentorshipSessionWhereUniqueInput
  }

  /**
   * MentorshipSession findFirst
   */
  export type MentorshipSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipSession to fetch.
     */
    where?: MentorshipSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipSessions to fetch.
     */
    orderBy?: MentorshipSessionOrderByWithRelationInput | MentorshipSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorshipSessions.
     */
    cursor?: MentorshipSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorshipSessions.
     */
    distinct?: MentorshipSessionScalarFieldEnum | MentorshipSessionScalarFieldEnum[]
  }

  /**
   * MentorshipSession findFirstOrThrow
   */
  export type MentorshipSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipSession to fetch.
     */
    where?: MentorshipSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipSessions to fetch.
     */
    orderBy?: MentorshipSessionOrderByWithRelationInput | MentorshipSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorshipSessions.
     */
    cursor?: MentorshipSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorshipSessions.
     */
    distinct?: MentorshipSessionScalarFieldEnum | MentorshipSessionScalarFieldEnum[]
  }

  /**
   * MentorshipSession findMany
   */
  export type MentorshipSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorshipSessions to fetch.
     */
    where?: MentorshipSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorshipSessions to fetch.
     */
    orderBy?: MentorshipSessionOrderByWithRelationInput | MentorshipSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorshipSessions.
     */
    cursor?: MentorshipSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorshipSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorshipSessions.
     */
    skip?: number
    distinct?: MentorshipSessionScalarFieldEnum | MentorshipSessionScalarFieldEnum[]
  }

  /**
   * MentorshipSession create
   */
  export type MentorshipSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorshipSession.
     */
    data: XOR<MentorshipSessionCreateInput, MentorshipSessionUncheckedCreateInput>
  }

  /**
   * MentorshipSession createMany
   */
  export type MentorshipSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorshipSessions.
     */
    data: MentorshipSessionCreateManyInput | MentorshipSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorshipSession createManyAndReturn
   */
  export type MentorshipSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * The data used to create many MentorshipSessions.
     */
    data: MentorshipSessionCreateManyInput | MentorshipSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorshipSession update
   */
  export type MentorshipSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorshipSession.
     */
    data: XOR<MentorshipSessionUpdateInput, MentorshipSessionUncheckedUpdateInput>
    /**
     * Choose, which MentorshipSession to update.
     */
    where: MentorshipSessionWhereUniqueInput
  }

  /**
   * MentorshipSession updateMany
   */
  export type MentorshipSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorshipSessions.
     */
    data: XOR<MentorshipSessionUpdateManyMutationInput, MentorshipSessionUncheckedUpdateManyInput>
    /**
     * Filter which MentorshipSessions to update
     */
    where?: MentorshipSessionWhereInput
    /**
     * Limit how many MentorshipSessions to update.
     */
    limit?: number
  }

  /**
   * MentorshipSession updateManyAndReturn
   */
  export type MentorshipSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * The data used to update MentorshipSessions.
     */
    data: XOR<MentorshipSessionUpdateManyMutationInput, MentorshipSessionUncheckedUpdateManyInput>
    /**
     * Filter which MentorshipSessions to update
     */
    where?: MentorshipSessionWhereInput
    /**
     * Limit how many MentorshipSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorshipSession upsert
   */
  export type MentorshipSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorshipSession to update in case it exists.
     */
    where: MentorshipSessionWhereUniqueInput
    /**
     * In case the MentorshipSession found by the `where` argument doesn't exist, create a new MentorshipSession with this data.
     */
    create: XOR<MentorshipSessionCreateInput, MentorshipSessionUncheckedCreateInput>
    /**
     * In case the MentorshipSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorshipSessionUpdateInput, MentorshipSessionUncheckedUpdateInput>
  }

  /**
   * MentorshipSession delete
   */
  export type MentorshipSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
    /**
     * Filter which MentorshipSession to delete.
     */
    where: MentorshipSessionWhereUniqueInput
  }

  /**
   * MentorshipSession deleteMany
   */
  export type MentorshipSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorshipSessions to delete
     */
    where?: MentorshipSessionWhereInput
    /**
     * Limit how many MentorshipSessions to delete.
     */
    limit?: number
  }

  /**
   * MentorshipSession without action
   */
  export type MentorshipSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorshipSession
     */
    select?: MentorshipSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorshipSession
     */
    omit?: MentorshipSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorshipSessionInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    maxParticipants: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    maxParticipants: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    eventDate: Date | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    virtualLink: string | null
    isVirtual: boolean | null
    maxParticipants: number | null
    thumbnail: string | null
    registrationDeadline: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    eventDate: Date | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    virtualLink: string | null
    isVirtual: boolean | null
    maxParticipants: number | null
    thumbnail: string | null
    registrationDeadline: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    eventDate: number
    startTime: number
    endTime: number
    location: number
    virtualLink: number
    isVirtual: number
    maxParticipants: number
    thumbnail: number
    registrationDeadline: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    maxParticipants?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    maxParticipants?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    location?: true
    virtualLink?: true
    isVirtual?: true
    maxParticipants?: true
    thumbnail?: true
    registrationDeadline?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    location?: true
    virtualLink?: true
    isVirtual?: true
    maxParticipants?: true
    thumbnail?: true
    registrationDeadline?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    location?: true
    virtualLink?: true
    isVirtual?: true
    maxParticipants?: true
    thumbnail?: true
    registrationDeadline?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    title: string
    description: string
    eventDate: Date
    startTime: Date
    endTime: Date
    location: string | null
    virtualLink: string | null
    isVirtual: boolean
    maxParticipants: number | null
    thumbnail: string | null
    registrationDeadline: Date | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    virtualLink?: boolean
    isVirtual?: boolean
    maxParticipants?: boolean
    thumbnail?: boolean
    registrationDeadline?: boolean
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    virtualLink?: boolean
    isVirtual?: boolean
    maxParticipants?: boolean
    thumbnail?: boolean
    registrationDeadline?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    virtualLink?: boolean
    isVirtual?: boolean
    maxParticipants?: boolean
    thumbnail?: boolean
    registrationDeadline?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    virtualLink?: boolean
    isVirtual?: boolean
    maxParticipants?: boolean
    thumbnail?: boolean
    registrationDeadline?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "eventDate" | "startTime" | "endTime" | "location" | "virtualLink" | "isVirtual" | "maxParticipants" | "thumbnail" | "registrationDeadline", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      registrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      eventDate: Date
      startTime: Date
      endTime: Date
      location: string | null
      virtualLink: string | null
      isVirtual: boolean
      maxParticipants: number | null
      thumbnail: string | null
      registrationDeadline: Date | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    registrations<T extends Event$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Event$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'Int'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly eventDate: FieldRef<"Event", 'DateTime'>
    readonly startTime: FieldRef<"Event", 'DateTime'>
    readonly endTime: FieldRef<"Event", 'DateTime'>
    readonly location: FieldRef<"Event", 'String'>
    readonly virtualLink: FieldRef<"Event", 'String'>
    readonly isVirtual: FieldRef<"Event", 'Boolean'>
    readonly maxParticipants: FieldRef<"Event", 'Int'>
    readonly thumbnail: FieldRef<"Event", 'String'>
    readonly registrationDeadline: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.registrations
   */
  export type Event$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventRegistration
   */

  export type AggregateEventRegistration = {
    _count: EventRegistrationCountAggregateOutputType | null
    _avg: EventRegistrationAvgAggregateOutputType | null
    _sum: EventRegistrationSumAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  export type EventRegistrationAvgAggregateOutputType = {
    id: number | null
    eventId: number | null
    userId: number | null
  }

  export type EventRegistrationSumAggregateOutputType = {
    id: number | null
    eventId: number | null
    userId: number | null
  }

  export type EventRegistrationMinAggregateOutputType = {
    id: number | null
    eventId: number | null
    userId: number | null
    registrationDate: Date | null
    attendanceConfirmed: boolean | null
  }

  export type EventRegistrationMaxAggregateOutputType = {
    id: number | null
    eventId: number | null
    userId: number | null
    registrationDate: Date | null
    attendanceConfirmed: boolean | null
  }

  export type EventRegistrationCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    registrationDate: number
    attendanceConfirmed: number
    _all: number
  }


  export type EventRegistrationAvgAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
  }

  export type EventRegistrationSumAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
  }

  export type EventRegistrationMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    registrationDate?: true
    attendanceConfirmed?: true
  }

  export type EventRegistrationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    registrationDate?: true
    attendanceConfirmed?: true
  }

  export type EventRegistrationCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    registrationDate?: true
    attendanceConfirmed?: true
    _all?: true
  }

  export type EventRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistration to aggregate.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRegistrations
    **/
    _count?: true | EventRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type GetEventRegistrationAggregateType<T extends EventRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRegistration[P]>
      : GetScalarType<T[P], AggregateEventRegistration[P]>
  }




  export type EventRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithAggregationInput | EventRegistrationOrderByWithAggregationInput[]
    by: EventRegistrationScalarFieldEnum[] | EventRegistrationScalarFieldEnum
    having?: EventRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRegistrationCountAggregateInputType | true
    _avg?: EventRegistrationAvgAggregateInputType
    _sum?: EventRegistrationSumAggregateInputType
    _min?: EventRegistrationMinAggregateInputType
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type EventRegistrationGroupByOutputType = {
    id: number
    eventId: number
    userId: number
    registrationDate: Date
    attendanceConfirmed: boolean
    _count: EventRegistrationCountAggregateOutputType | null
    _avg: EventRegistrationAvgAggregateOutputType | null
    _sum: EventRegistrationSumAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  type GetEventRegistrationGroupByPayload<T extends EventRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type EventRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    registrationDate?: boolean
    attendanceConfirmed?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    registrationDate?: boolean
    attendanceConfirmed?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    registrationDate?: boolean
    attendanceConfirmed?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    registrationDate?: boolean
    attendanceConfirmed?: boolean
  }

  export type EventRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "registrationDate" | "attendanceConfirmed", ExtArgs["result"]["eventRegistration"]>
  export type EventRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventRegistration"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      eventId: number
      userId: number
      registrationDate: Date
      attendanceConfirmed: boolean
    }, ExtArgs["result"]["eventRegistration"]>
    composites: {}
  }

  type EventRegistrationGetPayload<S extends boolean | null | undefined | EventRegistrationDefaultArgs> = $Result.GetResult<Prisma.$EventRegistrationPayload, S>

  type EventRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventRegistrationCountAggregateInputType | true
    }

  export interface EventRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRegistration'], meta: { name: 'EventRegistration' } }
    /**
     * Find zero or one EventRegistration that matches the filter.
     * @param {EventRegistrationFindUniqueArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRegistrationFindUniqueArgs>(args: SelectSubset<T, EventRegistrationFindUniqueArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventRegistrationFindUniqueOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRegistrationFindFirstArgs>(args?: SelectSubset<T, EventRegistrationFindFirstArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany()
     * 
     * // Get first 10 EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventRegistrationFindManyArgs>(args?: SelectSubset<T, EventRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventRegistration.
     * @param {EventRegistrationCreateArgs} args - Arguments to create a EventRegistration.
     * @example
     * // Create one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.create({
     *   data: {
     *     // ... data to create a EventRegistration
     *   }
     * })
     * 
     */
    create<T extends EventRegistrationCreateArgs>(args: SelectSubset<T, EventRegistrationCreateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventRegistrations.
     * @param {EventRegistrationCreateManyArgs} args - Arguments to create many EventRegistrations.
     * @example
     * // Create many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventRegistrationCreateManyArgs>(args?: SelectSubset<T, EventRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventRegistrations and returns the data saved in the database.
     * @param {EventRegistrationCreateManyAndReturnArgs} args - Arguments to create many EventRegistrations.
     * @example
     * // Create many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventRegistrations and only return the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, EventRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventRegistration.
     * @param {EventRegistrationDeleteArgs} args - Arguments to delete one EventRegistration.
     * @example
     * // Delete one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.delete({
     *   where: {
     *     // ... filter to delete one EventRegistration
     *   }
     * })
     * 
     */
    delete<T extends EventRegistrationDeleteArgs>(args: SelectSubset<T, EventRegistrationDeleteArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventRegistration.
     * @param {EventRegistrationUpdateArgs} args - Arguments to update one EventRegistration.
     * @example
     * // Update one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventRegistrationUpdateArgs>(args: SelectSubset<T, EventRegistrationUpdateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventRegistrations.
     * @param {EventRegistrationDeleteManyArgs} args - Arguments to filter EventRegistrations to delete.
     * @example
     * // Delete a few EventRegistrations
     * const { count } = await prisma.eventRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventRegistrationDeleteManyArgs>(args?: SelectSubset<T, EventRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventRegistrationUpdateManyArgs>(args: SelectSubset<T, EventRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations and returns the data updated in the database.
     * @param {EventRegistrationUpdateManyAndReturnArgs} args - Arguments to update many EventRegistrations.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventRegistrations and only return the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, EventRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventRegistration.
     * @param {EventRegistrationUpsertArgs} args - Arguments to update or create a EventRegistration.
     * @example
     * // Update or create a EventRegistration
     * const eventRegistration = await prisma.eventRegistration.upsert({
     *   create: {
     *     // ... data to create a EventRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRegistration we want to update
     *   }
     * })
     */
    upsert<T extends EventRegistrationUpsertArgs>(args: SelectSubset<T, EventRegistrationUpsertArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationCountArgs} args - Arguments to filter EventRegistrations to count.
     * @example
     * // Count the number of EventRegistrations
     * const count = await prisma.eventRegistration.count({
     *   where: {
     *     // ... the filter for the EventRegistrations we want to count
     *   }
     * })
    **/
    count<T extends EventRegistrationCountArgs>(
      args?: Subset<T, EventRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRegistrationAggregateArgs>(args: Subset<T, EventRegistrationAggregateArgs>): Prisma.PrismaPromise<GetEventRegistrationAggregateType<T>>

    /**
     * Group by EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: EventRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventRegistration model
   */
  readonly fields: EventRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventRegistration model
   */
  interface EventRegistrationFieldRefs {
    readonly id: FieldRef<"EventRegistration", 'Int'>
    readonly eventId: FieldRef<"EventRegistration", 'Int'>
    readonly userId: FieldRef<"EventRegistration", 'Int'>
    readonly registrationDate: FieldRef<"EventRegistration", 'DateTime'>
    readonly attendanceConfirmed: FieldRef<"EventRegistration", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EventRegistration findUnique
   */
  export type EventRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findUniqueOrThrow
   */
  export type EventRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findFirst
   */
  export type EventRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findFirstOrThrow
   */
  export type EventRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findMany
   */
  export type EventRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistrations to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration create
   */
  export type EventRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRegistration.
     */
    data: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
  }

  /**
   * EventRegistration createMany
   */
  export type EventRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRegistrations.
     */
    data: EventRegistrationCreateManyInput | EventRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventRegistration createManyAndReturn
   */
  export type EventRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many EventRegistrations.
     */
    data: EventRegistrationCreateManyInput | EventRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventRegistration update
   */
  export type EventRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRegistration.
     */
    data: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
    /**
     * Choose, which EventRegistration to update.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration updateMany
   */
  export type EventRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to update.
     */
    limit?: number
  }

  /**
   * EventRegistration updateManyAndReturn
   */
  export type EventRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventRegistration upsert
   */
  export type EventRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRegistration to update in case it exists.
     */
    where: EventRegistrationWhereUniqueInput
    /**
     * In case the EventRegistration found by the `where` argument doesn't exist, create a new EventRegistration with this data.
     */
    create: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
    /**
     * In case the EventRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
  }

  /**
   * EventRegistration delete
   */
  export type EventRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter which EventRegistration to delete.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration deleteMany
   */
  export type EventRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistrations to delete
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to delete.
     */
    limit?: number
  }

  /**
   * EventRegistration without action
   */
  export type EventRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type CommunitySumAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    thumbnail: string | null
    creatorId: number | null
    createdAt: Date | null
    isPrivate: boolean | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    thumbnail: string | null
    creatorId: number | null
    createdAt: Date | null
    isPrivate: boolean | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    thumbnail: number
    creatorId: number
    createdAt: number
    isPrivate: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type CommunitySumAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    thumbnail?: true
    creatorId?: true
    createdAt?: true
    isPrivate?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    thumbnail?: true
    creatorId?: true
    createdAt?: true
    isPrivate?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    thumbnail?: true
    creatorId?: true
    createdAt?: true
    isPrivate?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: number
    name: string
    description: string
    thumbnail: string | null
    creatorId: number
    createdAt: Date
    isPrivate: boolean
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    creatorId?: boolean
    createdAt?: boolean
    isPrivate?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Community$membersArgs<ExtArgs>
    posts?: boolean | Community$postsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    creatorId?: boolean
    createdAt?: boolean
    isPrivate?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    creatorId?: boolean
    createdAt?: boolean
    isPrivate?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    thumbnail?: boolean
    creatorId?: boolean
    createdAt?: boolean
    isPrivate?: boolean
  }

  export type CommunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "thumbnail" | "creatorId" | "createdAt" | "isPrivate", ExtArgs["result"]["community"]>
  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Community$membersArgs<ExtArgs>
    posts?: boolean | Community$postsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$CommunityMemberPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      thumbnail: string | null
      creatorId: number
      createdAt: Date
      isPrivate: boolean
    }, ExtArgs["result"]["community"]>
    composites: {}
  }

  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityFindUniqueArgs>(args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Community that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityFindFirstArgs>(args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityFindManyArgs>(args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
     */
    create<T extends CommunityCreateArgs>(args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communities.
     * @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCreateManyArgs>(args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communities and returns the data saved in the database.
     * @param {CommunityCreateManyAndReturnArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
     */
    delete<T extends CommunityDeleteArgs>(args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityUpdateArgs>(args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityDeleteManyArgs>(args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityUpdateManyArgs>(args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities and returns the data updated in the database.
     * @param {CommunityUpdateManyAndReturnArgs} args - Arguments to update many Communities.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
     */
    upsert<T extends CommunityUpsertArgs>(args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Community$membersArgs<ExtArgs> = {}>(args?: Subset<T, Community$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Community$postsArgs<ExtArgs> = {}>(args?: Subset<T, Community$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Community model
   */
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'Int'>
    readonly name: FieldRef<"Community", 'String'>
    readonly description: FieldRef<"Community", 'String'>
    readonly thumbnail: FieldRef<"Community", 'String'>
    readonly creatorId: FieldRef<"Community", 'Int'>
    readonly createdAt: FieldRef<"Community", 'DateTime'>
    readonly isPrivate: FieldRef<"Community", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community createManyAndReturn
   */
  export type CommunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
  }

  /**
   * Community updateManyAndReturn
   */
  export type CommunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to delete.
     */
    limit?: number
  }

  /**
   * Community.members
   */
  export type Community$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    where?: CommunityMemberWhereInput
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    cursor?: CommunityMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * Community.posts
   */
  export type Community$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model CommunityMember
   */

  export type AggregateCommunityMember = {
    _count: CommunityMemberCountAggregateOutputType | null
    _avg: CommunityMemberAvgAggregateOutputType | null
    _sum: CommunityMemberSumAggregateOutputType | null
    _min: CommunityMemberMinAggregateOutputType | null
    _max: CommunityMemberMaxAggregateOutputType | null
  }

  export type CommunityMemberAvgAggregateOutputType = {
    id: number | null
    communityId: number | null
    userId: number | null
  }

  export type CommunityMemberSumAggregateOutputType = {
    id: number | null
    communityId: number | null
    userId: number | null
  }

  export type CommunityMemberMinAggregateOutputType = {
    id: number | null
    communityId: number | null
    userId: number | null
    joinedDate: Date | null
    role: $Enums.CommunityRole | null
  }

  export type CommunityMemberMaxAggregateOutputType = {
    id: number | null
    communityId: number | null
    userId: number | null
    joinedDate: Date | null
    role: $Enums.CommunityRole | null
  }

  export type CommunityMemberCountAggregateOutputType = {
    id: number
    communityId: number
    userId: number
    joinedDate: number
    role: number
    _all: number
  }


  export type CommunityMemberAvgAggregateInputType = {
    id?: true
    communityId?: true
    userId?: true
  }

  export type CommunityMemberSumAggregateInputType = {
    id?: true
    communityId?: true
    userId?: true
  }

  export type CommunityMemberMinAggregateInputType = {
    id?: true
    communityId?: true
    userId?: true
    joinedDate?: true
    role?: true
  }

  export type CommunityMemberMaxAggregateInputType = {
    id?: true
    communityId?: true
    userId?: true
    joinedDate?: true
    role?: true
  }

  export type CommunityMemberCountAggregateInputType = {
    id?: true
    communityId?: true
    userId?: true
    joinedDate?: true
    role?: true
    _all?: true
  }

  export type CommunityMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityMember to aggregate.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityMembers
    **/
    _count?: true | CommunityMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMemberMaxAggregateInputType
  }

  export type GetCommunityMemberAggregateType<T extends CommunityMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityMember[P]>
      : GetScalarType<T[P], AggregateCommunityMember[P]>
  }




  export type CommunityMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMemberWhereInput
    orderBy?: CommunityMemberOrderByWithAggregationInput | CommunityMemberOrderByWithAggregationInput[]
    by: CommunityMemberScalarFieldEnum[] | CommunityMemberScalarFieldEnum
    having?: CommunityMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityMemberCountAggregateInputType | true
    _avg?: CommunityMemberAvgAggregateInputType
    _sum?: CommunityMemberSumAggregateInputType
    _min?: CommunityMemberMinAggregateInputType
    _max?: CommunityMemberMaxAggregateInputType
  }

  export type CommunityMemberGroupByOutputType = {
    id: number
    communityId: number
    userId: number
    joinedDate: Date
    role: $Enums.CommunityRole
    _count: CommunityMemberCountAggregateOutputType | null
    _avg: CommunityMemberAvgAggregateOutputType | null
    _sum: CommunityMemberSumAggregateOutputType | null
    _min: CommunityMemberMinAggregateOutputType | null
    _max: CommunityMemberMaxAggregateOutputType | null
  }

  type GetCommunityMemberGroupByPayload<T extends CommunityMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityMemberGroupByOutputType[P]>
        }
      >
    >


  export type CommunityMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    userId?: boolean
    joinedDate?: boolean
    role?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityMember"]>

  export type CommunityMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    userId?: boolean
    joinedDate?: boolean
    role?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityMember"]>

  export type CommunityMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    userId?: boolean
    joinedDate?: boolean
    role?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityMember"]>

  export type CommunityMemberSelectScalar = {
    id?: boolean
    communityId?: boolean
    userId?: boolean
    joinedDate?: boolean
    role?: boolean
  }

  export type CommunityMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "communityId" | "userId" | "joinedDate" | "role", ExtArgs["result"]["communityMember"]>
  export type CommunityMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommunityMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommunityMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommunityMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityMember"
    objects: {
      community: Prisma.$CommunityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      communityId: number
      userId: number
      joinedDate: Date
      role: $Enums.CommunityRole
    }, ExtArgs["result"]["communityMember"]>
    composites: {}
  }

  type CommunityMemberGetPayload<S extends boolean | null | undefined | CommunityMemberDefaultArgs> = $Result.GetResult<Prisma.$CommunityMemberPayload, S>

  type CommunityMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityMemberCountAggregateInputType | true
    }

  export interface CommunityMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityMember'], meta: { name: 'CommunityMember' } }
    /**
     * Find zero or one CommunityMember that matches the filter.
     * @param {CommunityMemberFindUniqueArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityMemberFindUniqueArgs>(args: SelectSubset<T, CommunityMemberFindUniqueArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityMemberFindUniqueOrThrowArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberFindFirstArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityMemberFindFirstArgs>(args?: SelectSubset<T, CommunityMemberFindFirstArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberFindFirstOrThrowArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityMembers
     * const communityMembers = await prisma.communityMember.findMany()
     * 
     * // Get first 10 CommunityMembers
     * const communityMembers = await prisma.communityMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityMemberWithIdOnly = await prisma.communityMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityMemberFindManyArgs>(args?: SelectSubset<T, CommunityMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityMember.
     * @param {CommunityMemberCreateArgs} args - Arguments to create a CommunityMember.
     * @example
     * // Create one CommunityMember
     * const CommunityMember = await prisma.communityMember.create({
     *   data: {
     *     // ... data to create a CommunityMember
     *   }
     * })
     * 
     */
    create<T extends CommunityMemberCreateArgs>(args: SelectSubset<T, CommunityMemberCreateArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityMembers.
     * @param {CommunityMemberCreateManyArgs} args - Arguments to create many CommunityMembers.
     * @example
     * // Create many CommunityMembers
     * const communityMember = await prisma.communityMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityMemberCreateManyArgs>(args?: SelectSubset<T, CommunityMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityMembers and returns the data saved in the database.
     * @param {CommunityMemberCreateManyAndReturnArgs} args - Arguments to create many CommunityMembers.
     * @example
     * // Create many CommunityMembers
     * const communityMember = await prisma.communityMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityMembers and only return the `id`
     * const communityMemberWithIdOnly = await prisma.communityMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityMember.
     * @param {CommunityMemberDeleteArgs} args - Arguments to delete one CommunityMember.
     * @example
     * // Delete one CommunityMember
     * const CommunityMember = await prisma.communityMember.delete({
     *   where: {
     *     // ... filter to delete one CommunityMember
     *   }
     * })
     * 
     */
    delete<T extends CommunityMemberDeleteArgs>(args: SelectSubset<T, CommunityMemberDeleteArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityMember.
     * @param {CommunityMemberUpdateArgs} args - Arguments to update one CommunityMember.
     * @example
     * // Update one CommunityMember
     * const communityMember = await prisma.communityMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityMemberUpdateArgs>(args: SelectSubset<T, CommunityMemberUpdateArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityMembers.
     * @param {CommunityMemberDeleteManyArgs} args - Arguments to filter CommunityMembers to delete.
     * @example
     * // Delete a few CommunityMembers
     * const { count } = await prisma.communityMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityMemberDeleteManyArgs>(args?: SelectSubset<T, CommunityMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityMembers
     * const communityMember = await prisma.communityMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityMemberUpdateManyArgs>(args: SelectSubset<T, CommunityMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityMembers and returns the data updated in the database.
     * @param {CommunityMemberUpdateManyAndReturnArgs} args - Arguments to update many CommunityMembers.
     * @example
     * // Update many CommunityMembers
     * const communityMember = await prisma.communityMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommunityMembers and only return the `id`
     * const communityMemberWithIdOnly = await prisma.communityMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommunityMember.
     * @param {CommunityMemberUpsertArgs} args - Arguments to update or create a CommunityMember.
     * @example
     * // Update or create a CommunityMember
     * const communityMember = await prisma.communityMember.upsert({
     *   create: {
     *     // ... data to create a CommunityMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityMember we want to update
     *   }
     * })
     */
    upsert<T extends CommunityMemberUpsertArgs>(args: SelectSubset<T, CommunityMemberUpsertArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberCountArgs} args - Arguments to filter CommunityMembers to count.
     * @example
     * // Count the number of CommunityMembers
     * const count = await prisma.communityMember.count({
     *   where: {
     *     // ... the filter for the CommunityMembers we want to count
     *   }
     * })
    **/
    count<T extends CommunityMemberCountArgs>(
      args?: Subset<T, CommunityMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityMemberAggregateArgs>(args: Subset<T, CommunityMemberAggregateArgs>): Prisma.PrismaPromise<GetCommunityMemberAggregateType<T>>

    /**
     * Group by CommunityMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityMemberGroupByArgs['orderBy'] }
        : { orderBy?: CommunityMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityMember model
   */
  readonly fields: CommunityMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityMember model
   */
  interface CommunityMemberFieldRefs {
    readonly id: FieldRef<"CommunityMember", 'Int'>
    readonly communityId: FieldRef<"CommunityMember", 'Int'>
    readonly userId: FieldRef<"CommunityMember", 'Int'>
    readonly joinedDate: FieldRef<"CommunityMember", 'DateTime'>
    readonly role: FieldRef<"CommunityMember", 'CommunityRole'>
  }
    

  // Custom InputTypes
  /**
   * CommunityMember findUnique
   */
  export type CommunityMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember findUniqueOrThrow
   */
  export type CommunityMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember findFirst
   */
  export type CommunityMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityMembers.
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityMembers.
     */
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * CommunityMember findFirstOrThrow
   */
  export type CommunityMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityMembers.
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityMembers.
     */
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * CommunityMember findMany
   */
  export type CommunityMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMembers to fetch.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityMembers.
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * CommunityMember create
   */
  export type CommunityMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityMember.
     */
    data: XOR<CommunityMemberCreateInput, CommunityMemberUncheckedCreateInput>
  }

  /**
   * CommunityMember createMany
   */
  export type CommunityMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityMembers.
     */
    data: CommunityMemberCreateManyInput | CommunityMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityMember createManyAndReturn
   */
  export type CommunityMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityMembers.
     */
    data: CommunityMemberCreateManyInput | CommunityMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityMember update
   */
  export type CommunityMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityMember.
     */
    data: XOR<CommunityMemberUpdateInput, CommunityMemberUncheckedUpdateInput>
    /**
     * Choose, which CommunityMember to update.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember updateMany
   */
  export type CommunityMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityMembers.
     */
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyInput>
    /**
     * Filter which CommunityMembers to update
     */
    where?: CommunityMemberWhereInput
    /**
     * Limit how many CommunityMembers to update.
     */
    limit?: number
  }

  /**
   * CommunityMember updateManyAndReturn
   */
  export type CommunityMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * The data used to update CommunityMembers.
     */
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyInput>
    /**
     * Filter which CommunityMembers to update
     */
    where?: CommunityMemberWhereInput
    /**
     * Limit how many CommunityMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityMember upsert
   */
  export type CommunityMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityMember to update in case it exists.
     */
    where: CommunityMemberWhereUniqueInput
    /**
     * In case the CommunityMember found by the `where` argument doesn't exist, create a new CommunityMember with this data.
     */
    create: XOR<CommunityMemberCreateInput, CommunityMemberUncheckedCreateInput>
    /**
     * In case the CommunityMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityMemberUpdateInput, CommunityMemberUncheckedUpdateInput>
  }

  /**
   * CommunityMember delete
   */
  export type CommunityMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter which CommunityMember to delete.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember deleteMany
   */
  export type CommunityMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityMembers to delete
     */
    where?: CommunityMemberWhereInput
    /**
     * Limit how many CommunityMembers to delete.
     */
    limit?: number
  }

  /**
   * CommunityMember without action
   */
  export type CommunityMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    communityId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    communityId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    authorId: number | null
    communityId: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    authorId: number | null
    communityId: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    communityId: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    authorId: number
    communityId: number
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "communityId" | "title" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      authorId: number
      communityId: number
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly authorId: FieldRef<"Post", 'Int'>
    readonly communityId: FieldRef<"Post", 'Int'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    postId: number
    userId: number
    content: string
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "content" | "createdAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly postId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    creatorId: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ProjectStatus | null
    githubUrl: string | null
    demoUrl: string | null
    thumbnail: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    creatorId: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ProjectStatus | null
    githubUrl: string | null
    demoUrl: string | null
    thumbnail: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    creatorId: number
    startDate: number
    endDate: number
    status: number
    githubUrl: number
    demoUrl: number
    thumbnail: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    creatorId?: true
    startDate?: true
    endDate?: true
    status?: true
    githubUrl?: true
    demoUrl?: true
    thumbnail?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    creatorId?: true
    startDate?: true
    endDate?: true
    status?: true
    githubUrl?: true
    demoUrl?: true
    thumbnail?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    creatorId?: true
    startDate?: true
    endDate?: true
    status?: true
    githubUrl?: true
    demoUrl?: true
    thumbnail?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    title: string
    description: string
    creatorId: number
    startDate: Date
    endDate: Date | null
    status: $Enums.ProjectStatus
    githubUrl: string | null
    demoUrl: string | null
    thumbnail: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    githubUrl?: boolean
    demoUrl?: boolean
    thumbnail?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    githubUrl?: boolean
    demoUrl?: boolean
    thumbnail?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    githubUrl?: boolean
    demoUrl?: boolean
    thumbnail?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    githubUrl?: boolean
    demoUrl?: boolean
    thumbnail?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "creatorId" | "startDate" | "endDate" | "status" | "githubUrl" | "demoUrl" | "thumbnail", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      creatorId: number
      startDate: Date
      endDate: Date | null
      status: $Enums.ProjectStatus
      githubUrl: string | null
      demoUrl: string | null
      thumbnail: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly creatorId: FieldRef<"Project", 'Int'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly githubUrl: FieldRef<"Project", 'String'>
    readonly demoUrl: FieldRef<"Project", 'String'>
    readonly thumbnail: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectMemberSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: $Enums.ProjectRole | null
    joinedDate: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: $Enums.ProjectRole | null
    joinedDate: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    joinedDate: number
    _all: number
  }


  export type ProjectMemberAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedDate?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedDate?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedDate?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _avg?: ProjectMemberAvgAggregateInputType
    _sum?: ProjectMemberSumAggregateInputType
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    role: $Enums.ProjectRole
    joinedDate: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedDate?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "joinedDate", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      role: $Enums.ProjectRole
      joinedDate: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'Int'>
    readonly projectId: FieldRef<"ProjectMember", 'Int'>
    readonly userId: FieldRef<"ProjectMember", 'Int'>
    readonly role: FieldRef<"ProjectMember", 'ProjectRole'>
    readonly joinedDate: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model Sponsor
   */

  export type AggregateSponsor = {
    _count: SponsorCountAggregateOutputType | null
    _avg: SponsorAvgAggregateOutputType | null
    _sum: SponsorSumAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  export type SponsorAvgAggregateOutputType = {
    id: number | null
  }

  export type SponsorSumAggregateOutputType = {
    id: number | null
  }

  export type SponsorMinAggregateOutputType = {
    id: number | null
    organizationName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    website: string | null
    logo: string | null
    description: string | null
    partnershipStart: Date | null
  }

  export type SponsorMaxAggregateOutputType = {
    id: number | null
    organizationName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    website: string | null
    logo: string | null
    description: string | null
    partnershipStart: Date | null
  }

  export type SponsorCountAggregateOutputType = {
    id: number
    organizationName: number
    contactPerson: number
    email: number
    phone: number
    website: number
    logo: number
    description: number
    partnershipStart: number
    _all: number
  }


  export type SponsorAvgAggregateInputType = {
    id?: true
  }

  export type SponsorSumAggregateInputType = {
    id?: true
  }

  export type SponsorMinAggregateInputType = {
    id?: true
    organizationName?: true
    contactPerson?: true
    email?: true
    phone?: true
    website?: true
    logo?: true
    description?: true
    partnershipStart?: true
  }

  export type SponsorMaxAggregateInputType = {
    id?: true
    organizationName?: true
    contactPerson?: true
    email?: true
    phone?: true
    website?: true
    logo?: true
    description?: true
    partnershipStart?: true
  }

  export type SponsorCountAggregateInputType = {
    id?: true
    organizationName?: true
    contactPerson?: true
    email?: true
    phone?: true
    website?: true
    logo?: true
    description?: true
    partnershipStart?: true
    _all?: true
  }

  export type SponsorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsor to aggregate.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsors
    **/
    _count?: true | SponsorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorMaxAggregateInputType
  }

  export type GetSponsorAggregateType<T extends SponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsor[P]>
      : GetScalarType<T[P], AggregateSponsor[P]>
  }




  export type SponsorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithAggregationInput | SponsorOrderByWithAggregationInput[]
    by: SponsorScalarFieldEnum[] | SponsorScalarFieldEnum
    having?: SponsorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorCountAggregateInputType | true
    _avg?: SponsorAvgAggregateInputType
    _sum?: SponsorSumAggregateInputType
    _min?: SponsorMinAggregateInputType
    _max?: SponsorMaxAggregateInputType
  }

  export type SponsorGroupByOutputType = {
    id: number
    organizationName: string
    contactPerson: string
    email: string
    phone: string | null
    website: string | null
    logo: string | null
    description: string
    partnershipStart: Date
    _count: SponsorCountAggregateOutputType | null
    _avg: SponsorAvgAggregateOutputType | null
    _sum: SponsorSumAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  type GetSponsorGroupByPayload<T extends SponsorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorGroupByOutputType[P]>
        }
      >
    >


  export type SponsorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    partnershipStart?: boolean
    sponsorships?: boolean | Sponsor$sponsorshipsArgs<ExtArgs>
    _count?: boolean | SponsorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    partnershipStart?: boolean
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    partnershipStart?: boolean
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectScalar = {
    id?: boolean
    organizationName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    partnershipStart?: boolean
  }

  export type SponsorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationName" | "contactPerson" | "email" | "phone" | "website" | "logo" | "description" | "partnershipStart", ExtArgs["result"]["sponsor"]>
  export type SponsorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsorships?: boolean | Sponsor$sponsorshipsArgs<ExtArgs>
    _count?: boolean | SponsorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SponsorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SponsorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SponsorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsor"
    objects: {
      sponsorships: Prisma.$SponsorshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organizationName: string
      contactPerson: string
      email: string
      phone: string | null
      website: string | null
      logo: string | null
      description: string
      partnershipStart: Date
    }, ExtArgs["result"]["sponsor"]>
    composites: {}
  }

  type SponsorGetPayload<S extends boolean | null | undefined | SponsorDefaultArgs> = $Result.GetResult<Prisma.$SponsorPayload, S>

  type SponsorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorCountAggregateInputType | true
    }

  export interface SponsorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsor'], meta: { name: 'Sponsor' } }
    /**
     * Find zero or one Sponsor that matches the filter.
     * @param {SponsorFindUniqueArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorFindUniqueArgs>(args: SelectSubset<T, SponsorFindUniqueArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sponsor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorFindUniqueOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorFindFirstArgs>(args?: SelectSubset<T, SponsorFindFirstArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsor.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sponsorWithIdOnly = await prisma.sponsor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SponsorFindManyArgs>(args?: SelectSubset<T, SponsorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sponsor.
     * @param {SponsorCreateArgs} args - Arguments to create a Sponsor.
     * @example
     * // Create one Sponsor
     * const Sponsor = await prisma.sponsor.create({
     *   data: {
     *     // ... data to create a Sponsor
     *   }
     * })
     * 
     */
    create<T extends SponsorCreateArgs>(args: SelectSubset<T, SponsorCreateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sponsors.
     * @param {SponsorCreateManyArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsor = await prisma.sponsor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorCreateManyArgs>(args?: SelectSubset<T, SponsorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sponsors and returns the data saved in the database.
     * @param {SponsorCreateManyAndReturnArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsor = await prisma.sponsor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sponsors and only return the `id`
     * const sponsorWithIdOnly = await prisma.sponsor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SponsorCreateManyAndReturnArgs>(args?: SelectSubset<T, SponsorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sponsor.
     * @param {SponsorDeleteArgs} args - Arguments to delete one Sponsor.
     * @example
     * // Delete one Sponsor
     * const Sponsor = await prisma.sponsor.delete({
     *   where: {
     *     // ... filter to delete one Sponsor
     *   }
     * })
     * 
     */
    delete<T extends SponsorDeleteArgs>(args: SelectSubset<T, SponsorDeleteArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sponsor.
     * @param {SponsorUpdateArgs} args - Arguments to update one Sponsor.
     * @example
     * // Update one Sponsor
     * const sponsor = await prisma.sponsor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorUpdateArgs>(args: SelectSubset<T, SponsorUpdateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sponsors.
     * @param {SponsorDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorDeleteManyArgs>(args?: SelectSubset<T, SponsorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorUpdateManyArgs>(args: SelectSubset<T, SponsorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors and returns the data updated in the database.
     * @param {SponsorUpdateManyAndReturnArgs} args - Arguments to update many Sponsors.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sponsors and only return the `id`
     * const sponsorWithIdOnly = await prisma.sponsor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SponsorUpdateManyAndReturnArgs>(args: SelectSubset<T, SponsorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sponsor.
     * @param {SponsorUpsertArgs} args - Arguments to update or create a Sponsor.
     * @example
     * // Update or create a Sponsor
     * const sponsor = await prisma.sponsor.upsert({
     *   create: {
     *     // ... data to create a Sponsor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsor we want to update
     *   }
     * })
     */
    upsert<T extends SponsorUpsertArgs>(args: SelectSubset<T, SponsorUpsertArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsor.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends SponsorCountArgs>(
      args?: Subset<T, SponsorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorAggregateArgs>(args: Subset<T, SponsorAggregateArgs>): Prisma.PrismaPromise<GetSponsorAggregateType<T>>

    /**
     * Group by Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorGroupByArgs['orderBy'] }
        : { orderBy?: SponsorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsor model
   */
  readonly fields: SponsorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sponsorships<T extends Sponsor$sponsorshipsArgs<ExtArgs> = {}>(args?: Subset<T, Sponsor$sponsorshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sponsor model
   */
  interface SponsorFieldRefs {
    readonly id: FieldRef<"Sponsor", 'Int'>
    readonly organizationName: FieldRef<"Sponsor", 'String'>
    readonly contactPerson: FieldRef<"Sponsor", 'String'>
    readonly email: FieldRef<"Sponsor", 'String'>
    readonly phone: FieldRef<"Sponsor", 'String'>
    readonly website: FieldRef<"Sponsor", 'String'>
    readonly logo: FieldRef<"Sponsor", 'String'>
    readonly description: FieldRef<"Sponsor", 'String'>
    readonly partnershipStart: FieldRef<"Sponsor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sponsor findUnique
   */
  export type SponsorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findUniqueOrThrow
   */
  export type SponsorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findFirst
   */
  export type SponsorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findFirstOrThrow
   */
  export type SponsorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findMany
   */
  export type SponsorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor create
   */
  export type SponsorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sponsor.
     */
    data: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
  }

  /**
   * Sponsor createMany
   */
  export type SponsorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sponsor createManyAndReturn
   */
  export type SponsorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sponsor update
   */
  export type SponsorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sponsor.
     */
    data: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
    /**
     * Choose, which Sponsor to update.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor updateMany
   */
  export type SponsorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
  }

  /**
   * Sponsor updateManyAndReturn
   */
  export type SponsorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
  }

  /**
   * Sponsor upsert
   */
  export type SponsorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sponsor to update in case it exists.
     */
    where: SponsorWhereUniqueInput
    /**
     * In case the Sponsor found by the `where` argument doesn't exist, create a new Sponsor with this data.
     */
    create: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
    /**
     * In case the Sponsor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
  }

  /**
   * Sponsor delete
   */
  export type SponsorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter which Sponsor to delete.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor deleteMany
   */
  export type SponsorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to delete
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to delete.
     */
    limit?: number
  }

  /**
   * Sponsor.sponsorships
   */
  export type Sponsor$sponsorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    where?: SponsorshipWhereInput
    orderBy?: SponsorshipOrderByWithRelationInput | SponsorshipOrderByWithRelationInput[]
    cursor?: SponsorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsorshipScalarFieldEnum | SponsorshipScalarFieldEnum[]
  }

  /**
   * Sponsor without action
   */
  export type SponsorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
  }


  /**
   * Model Sponsorship
   */

  export type AggregateSponsorship = {
    _count: SponsorshipCountAggregateOutputType | null
    _avg: SponsorshipAvgAggregateOutputType | null
    _sum: SponsorshipSumAggregateOutputType | null
    _min: SponsorshipMinAggregateOutputType | null
    _max: SponsorshipMaxAggregateOutputType | null
  }

  export type SponsorshipAvgAggregateOutputType = {
    id: number | null
    sponsorId: number | null
    amount: Decimal | null
  }

  export type SponsorshipSumAggregateOutputType = {
    id: number | null
    sponsorId: number | null
    amount: Decimal | null
  }

  export type SponsorshipMinAggregateOutputType = {
    id: number | null
    sponsorId: number | null
    title: string | null
    description: string | null
    amount: Decimal | null
    type: $Enums.SponsorshipType | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SponsorshipMaxAggregateOutputType = {
    id: number | null
    sponsorId: number | null
    title: string | null
    description: string | null
    amount: Decimal | null
    type: $Enums.SponsorshipType | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SponsorshipCountAggregateOutputType = {
    id: number
    sponsorId: number
    title: number
    description: number
    amount: number
    type: number
    startDate: number
    endDate: number
    _all: number
  }


  export type SponsorshipAvgAggregateInputType = {
    id?: true
    sponsorId?: true
    amount?: true
  }

  export type SponsorshipSumAggregateInputType = {
    id?: true
    sponsorId?: true
    amount?: true
  }

  export type SponsorshipMinAggregateInputType = {
    id?: true
    sponsorId?: true
    title?: true
    description?: true
    amount?: true
    type?: true
    startDate?: true
    endDate?: true
  }

  export type SponsorshipMaxAggregateInputType = {
    id?: true
    sponsorId?: true
    title?: true
    description?: true
    amount?: true
    type?: true
    startDate?: true
    endDate?: true
  }

  export type SponsorshipCountAggregateInputType = {
    id?: true
    sponsorId?: true
    title?: true
    description?: true
    amount?: true
    type?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type SponsorshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsorship to aggregate.
     */
    where?: SponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsorships to fetch.
     */
    orderBy?: SponsorshipOrderByWithRelationInput | SponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsorships
    **/
    _count?: true | SponsorshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsorshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsorshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorshipMaxAggregateInputType
  }

  export type GetSponsorshipAggregateType<T extends SponsorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsorship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsorship[P]>
      : GetScalarType<T[P], AggregateSponsorship[P]>
  }




  export type SponsorshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorshipWhereInput
    orderBy?: SponsorshipOrderByWithAggregationInput | SponsorshipOrderByWithAggregationInput[]
    by: SponsorshipScalarFieldEnum[] | SponsorshipScalarFieldEnum
    having?: SponsorshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorshipCountAggregateInputType | true
    _avg?: SponsorshipAvgAggregateInputType
    _sum?: SponsorshipSumAggregateInputType
    _min?: SponsorshipMinAggregateInputType
    _max?: SponsorshipMaxAggregateInputType
  }

  export type SponsorshipGroupByOutputType = {
    id: number
    sponsorId: number
    title: string
    description: string
    amount: Decimal
    type: $Enums.SponsorshipType
    startDate: Date
    endDate: Date | null
    _count: SponsorshipCountAggregateOutputType | null
    _avg: SponsorshipAvgAggregateOutputType | null
    _sum: SponsorshipSumAggregateOutputType | null
    _min: SponsorshipMinAggregateOutputType | null
    _max: SponsorshipMaxAggregateOutputType | null
  }

  type GetSponsorshipGroupByPayload<T extends SponsorshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorshipGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorshipGroupByOutputType[P]>
        }
      >
    >


  export type SponsorshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsorship"]>

  export type SponsorshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsorship"]>

  export type SponsorshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsorship"]>

  export type SponsorshipSelectScalar = {
    id?: boolean
    sponsorId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type SponsorshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sponsorId" | "title" | "description" | "amount" | "type" | "startDate" | "endDate", ExtArgs["result"]["sponsorship"]>
  export type SponsorshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }
  export type SponsorshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }
  export type SponsorshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }

  export type $SponsorshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsorship"
    objects: {
      sponsor: Prisma.$SponsorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sponsorId: number
      title: string
      description: string
      amount: Prisma.Decimal
      type: $Enums.SponsorshipType
      startDate: Date
      endDate: Date | null
    }, ExtArgs["result"]["sponsorship"]>
    composites: {}
  }

  type SponsorshipGetPayload<S extends boolean | null | undefined | SponsorshipDefaultArgs> = $Result.GetResult<Prisma.$SponsorshipPayload, S>

  type SponsorshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorshipCountAggregateInputType | true
    }

  export interface SponsorshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsorship'], meta: { name: 'Sponsorship' } }
    /**
     * Find zero or one Sponsorship that matches the filter.
     * @param {SponsorshipFindUniqueArgs} args - Arguments to find a Sponsorship
     * @example
     * // Get one Sponsorship
     * const sponsorship = await prisma.sponsorship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorshipFindUniqueArgs>(args: SelectSubset<T, SponsorshipFindUniqueArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sponsorship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorshipFindUniqueOrThrowArgs} args - Arguments to find a Sponsorship
     * @example
     * // Get one Sponsorship
     * const sponsorship = await prisma.sponsorship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorshipFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsorship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipFindFirstArgs} args - Arguments to find a Sponsorship
     * @example
     * // Get one Sponsorship
     * const sponsorship = await prisma.sponsorship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorshipFindFirstArgs>(args?: SelectSubset<T, SponsorshipFindFirstArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsorship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipFindFirstOrThrowArgs} args - Arguments to find a Sponsorship
     * @example
     * // Get one Sponsorship
     * const sponsorship = await prisma.sponsorship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorshipFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsorships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsorships
     * const sponsorships = await prisma.sponsorship.findMany()
     * 
     * // Get first 10 Sponsorships
     * const sponsorships = await prisma.sponsorship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sponsorshipWithIdOnly = await prisma.sponsorship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SponsorshipFindManyArgs>(args?: SelectSubset<T, SponsorshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sponsorship.
     * @param {SponsorshipCreateArgs} args - Arguments to create a Sponsorship.
     * @example
     * // Create one Sponsorship
     * const Sponsorship = await prisma.sponsorship.create({
     *   data: {
     *     // ... data to create a Sponsorship
     *   }
     * })
     * 
     */
    create<T extends SponsorshipCreateArgs>(args: SelectSubset<T, SponsorshipCreateArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sponsorships.
     * @param {SponsorshipCreateManyArgs} args - Arguments to create many Sponsorships.
     * @example
     * // Create many Sponsorships
     * const sponsorship = await prisma.sponsorship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorshipCreateManyArgs>(args?: SelectSubset<T, SponsorshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sponsorships and returns the data saved in the database.
     * @param {SponsorshipCreateManyAndReturnArgs} args - Arguments to create many Sponsorships.
     * @example
     * // Create many Sponsorships
     * const sponsorship = await prisma.sponsorship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sponsorships and only return the `id`
     * const sponsorshipWithIdOnly = await prisma.sponsorship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SponsorshipCreateManyAndReturnArgs>(args?: SelectSubset<T, SponsorshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sponsorship.
     * @param {SponsorshipDeleteArgs} args - Arguments to delete one Sponsorship.
     * @example
     * // Delete one Sponsorship
     * const Sponsorship = await prisma.sponsorship.delete({
     *   where: {
     *     // ... filter to delete one Sponsorship
     *   }
     * })
     * 
     */
    delete<T extends SponsorshipDeleteArgs>(args: SelectSubset<T, SponsorshipDeleteArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sponsorship.
     * @param {SponsorshipUpdateArgs} args - Arguments to update one Sponsorship.
     * @example
     * // Update one Sponsorship
     * const sponsorship = await prisma.sponsorship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorshipUpdateArgs>(args: SelectSubset<T, SponsorshipUpdateArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sponsorships.
     * @param {SponsorshipDeleteManyArgs} args - Arguments to filter Sponsorships to delete.
     * @example
     * // Delete a few Sponsorships
     * const { count } = await prisma.sponsorship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorshipDeleteManyArgs>(args?: SelectSubset<T, SponsorshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsorships
     * const sponsorship = await prisma.sponsorship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorshipUpdateManyArgs>(args: SelectSubset<T, SponsorshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsorships and returns the data updated in the database.
     * @param {SponsorshipUpdateManyAndReturnArgs} args - Arguments to update many Sponsorships.
     * @example
     * // Update many Sponsorships
     * const sponsorship = await prisma.sponsorship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sponsorships and only return the `id`
     * const sponsorshipWithIdOnly = await prisma.sponsorship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SponsorshipUpdateManyAndReturnArgs>(args: SelectSubset<T, SponsorshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sponsorship.
     * @param {SponsorshipUpsertArgs} args - Arguments to update or create a Sponsorship.
     * @example
     * // Update or create a Sponsorship
     * const sponsorship = await prisma.sponsorship.upsert({
     *   create: {
     *     // ... data to create a Sponsorship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsorship we want to update
     *   }
     * })
     */
    upsert<T extends SponsorshipUpsertArgs>(args: SelectSubset<T, SponsorshipUpsertArgs<ExtArgs>>): Prisma__SponsorshipClient<$Result.GetResult<Prisma.$SponsorshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sponsorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipCountArgs} args - Arguments to filter Sponsorships to count.
     * @example
     * // Count the number of Sponsorships
     * const count = await prisma.sponsorship.count({
     *   where: {
     *     // ... the filter for the Sponsorships we want to count
     *   }
     * })
    **/
    count<T extends SponsorshipCountArgs>(
      args?: Subset<T, SponsorshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorshipAggregateArgs>(args: Subset<T, SponsorshipAggregateArgs>): Prisma.PrismaPromise<GetSponsorshipAggregateType<T>>

    /**
     * Group by Sponsorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorshipGroupByArgs['orderBy'] }
        : { orderBy?: SponsorshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsorship model
   */
  readonly fields: SponsorshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsorship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sponsor<T extends SponsorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SponsorDefaultArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sponsorship model
   */
  interface SponsorshipFieldRefs {
    readonly id: FieldRef<"Sponsorship", 'Int'>
    readonly sponsorId: FieldRef<"Sponsorship", 'Int'>
    readonly title: FieldRef<"Sponsorship", 'String'>
    readonly description: FieldRef<"Sponsorship", 'String'>
    readonly amount: FieldRef<"Sponsorship", 'Decimal'>
    readonly type: FieldRef<"Sponsorship", 'SponsorshipType'>
    readonly startDate: FieldRef<"Sponsorship", 'DateTime'>
    readonly endDate: FieldRef<"Sponsorship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sponsorship findUnique
   */
  export type SponsorshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which Sponsorship to fetch.
     */
    where: SponsorshipWhereUniqueInput
  }

  /**
   * Sponsorship findUniqueOrThrow
   */
  export type SponsorshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which Sponsorship to fetch.
     */
    where: SponsorshipWhereUniqueInput
  }

  /**
   * Sponsorship findFirst
   */
  export type SponsorshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which Sponsorship to fetch.
     */
    where?: SponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsorships to fetch.
     */
    orderBy?: SponsorshipOrderByWithRelationInput | SponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsorships.
     */
    cursor?: SponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsorships.
     */
    distinct?: SponsorshipScalarFieldEnum | SponsorshipScalarFieldEnum[]
  }

  /**
   * Sponsorship findFirstOrThrow
   */
  export type SponsorshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which Sponsorship to fetch.
     */
    where?: SponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsorships to fetch.
     */
    orderBy?: SponsorshipOrderByWithRelationInput | SponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsorships.
     */
    cursor?: SponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsorships.
     */
    distinct?: SponsorshipScalarFieldEnum | SponsorshipScalarFieldEnum[]
  }

  /**
   * Sponsorship findMany
   */
  export type SponsorshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which Sponsorships to fetch.
     */
    where?: SponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsorships to fetch.
     */
    orderBy?: SponsorshipOrderByWithRelationInput | SponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsorships.
     */
    cursor?: SponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsorships.
     */
    skip?: number
    distinct?: SponsorshipScalarFieldEnum | SponsorshipScalarFieldEnum[]
  }

  /**
   * Sponsorship create
   */
  export type SponsorshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Sponsorship.
     */
    data: XOR<SponsorshipCreateInput, SponsorshipUncheckedCreateInput>
  }

  /**
   * Sponsorship createMany
   */
  export type SponsorshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsorships.
     */
    data: SponsorshipCreateManyInput | SponsorshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sponsorship createManyAndReturn
   */
  export type SponsorshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * The data used to create many Sponsorships.
     */
    data: SponsorshipCreateManyInput | SponsorshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sponsorship update
   */
  export type SponsorshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Sponsorship.
     */
    data: XOR<SponsorshipUpdateInput, SponsorshipUncheckedUpdateInput>
    /**
     * Choose, which Sponsorship to update.
     */
    where: SponsorshipWhereUniqueInput
  }

  /**
   * Sponsorship updateMany
   */
  export type SponsorshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsorships.
     */
    data: XOR<SponsorshipUpdateManyMutationInput, SponsorshipUncheckedUpdateManyInput>
    /**
     * Filter which Sponsorships to update
     */
    where?: SponsorshipWhereInput
    /**
     * Limit how many Sponsorships to update.
     */
    limit?: number
  }

  /**
   * Sponsorship updateManyAndReturn
   */
  export type SponsorshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * The data used to update Sponsorships.
     */
    data: XOR<SponsorshipUpdateManyMutationInput, SponsorshipUncheckedUpdateManyInput>
    /**
     * Filter which Sponsorships to update
     */
    where?: SponsorshipWhereInput
    /**
     * Limit how many Sponsorships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sponsorship upsert
   */
  export type SponsorshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Sponsorship to update in case it exists.
     */
    where: SponsorshipWhereUniqueInput
    /**
     * In case the Sponsorship found by the `where` argument doesn't exist, create a new Sponsorship with this data.
     */
    create: XOR<SponsorshipCreateInput, SponsorshipUncheckedCreateInput>
    /**
     * In case the Sponsorship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorshipUpdateInput, SponsorshipUncheckedUpdateInput>
  }

  /**
   * Sponsorship delete
   */
  export type SponsorshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
    /**
     * Filter which Sponsorship to delete.
     */
    where: SponsorshipWhereUniqueInput
  }

  /**
   * Sponsorship deleteMany
   */
  export type SponsorshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsorships to delete
     */
    where?: SponsorshipWhereInput
    /**
     * Limit how many Sponsorships to delete.
     */
    limit?: number
  }

  /**
   * Sponsorship without action
   */
  export type SponsorshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsorship
     */
    select?: SponsorshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsorship
     */
    omit?: SponsorshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorshipInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    badgeImage: string | null
    points: number | null
    category: $Enums.AchievementCategory | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    badgeImage: string | null
    points: number | null
    category: $Enums.AchievementCategory | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    badgeImage: number
    points: number
    category: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    id?: true
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    id?: true
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    badgeImage?: true
    points?: true
    category?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    badgeImage?: true
    points?: true
    category?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    badgeImage?: true
    points?: true
    category?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: number
    title: string
    description: string
    badgeImage: string
    points: number
    category: $Enums.AchievementCategory
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    badgeImage?: boolean
    points?: boolean
    category?: boolean
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    badgeImage?: boolean
    points?: boolean
    category?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    badgeImage?: boolean
    points?: boolean
    category?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    badgeImage?: boolean
    points?: boolean
    category?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "badgeImage" | "points" | "category", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      badgeImage: string
      points: number
      category: $Enums.AchievementCategory
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAchievements<T extends Achievement$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'Int'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly badgeImage: FieldRef<"Achievement", 'String'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.userAchievements
   */
  export type Achievement$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    achievementId: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    id: number | null
    userId: number | null
    achievementId: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: number | null
    userId: number | null
    achievementId: number | null
    earnedDate: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    achievementId: number | null
    earnedDate: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    earnedDate: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
  }

  export type UserAchievementSumAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedDate?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedDate?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedDate?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: number
    userId: number
    achievementId: number
    earnedDate: Date
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "earnedDate", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      achievementId: number
      earnedDate: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'Int'>
    readonly userId: FieldRef<"UserAchievement", 'Int'>
    readonly achievementId: FieldRef<"UserAchievement", 'Int'>
    readonly earnedDate: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    type: $Enums.NotificationType | null
    actionUrl: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    type: $Enums.NotificationType | null
    actionUrl: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    isRead: number
    createdAt: number
    type: number
    actionUrl: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    type?: true
    actionUrl?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    type?: true
    actionUrl?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    type?: true
    actionUrl?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    title: string
    content: string
    isRead: boolean
    createdAt: Date
    type: $Enums.NotificationType
    actionUrl: string | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    type?: boolean
    actionUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    type?: boolean
    actionUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    type?: boolean
    actionUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    type?: boolean
    actionUrl?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "isRead" | "createdAt" | "type" | "actionUrl", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      content: string
      isRead: boolean
      createdAt: Date
      type: $Enums.NotificationType
      actionUrl: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    uploaderId: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    uploaderId: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    fileUrl: string | null
    type: $Enums.ResourceType | null
    uploaderId: number | null
    uploadDate: Date | null
    isApproved: boolean | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    fileUrl: string | null
    type: $Enums.ResourceType | null
    uploaderId: number | null
    uploadDate: Date | null
    isApproved: boolean | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fileUrl: number
    type: number
    uploaderId: number
    uploadDate: number
    isApproved: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    uploaderId?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    uploaderId?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    type?: true
    uploaderId?: true
    uploadDate?: true
    isApproved?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    type?: true
    uploaderId?: true
    uploadDate?: true
    isApproved?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    type?: true
    uploaderId?: true
    uploadDate?: true
    isApproved?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploaderId: number
    uploadDate: Date
    isApproved: boolean
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    type?: boolean
    uploaderId?: boolean
    uploadDate?: boolean
    isApproved?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    type?: boolean
    uploaderId?: boolean
    uploadDate?: boolean
    isApproved?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    type?: boolean
    uploaderId?: boolean
    uploadDate?: boolean
    isApproved?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    type?: boolean
    uploaderId?: boolean
    uploadDate?: boolean
    isApproved?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "fileUrl" | "type" | "uploaderId" | "uploadDate" | "isApproved", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      fileUrl: string
      type: $Enums.ResourceType
      uploaderId: number
      uploadDate: Date
      isApproved: boolean
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly fileUrl: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'ResourceType'>
    readonly uploaderId: FieldRef<"Resource", 'Int'>
    readonly uploadDate: FieldRef<"Resource", 'DateTime'>
    readonly isApproved: FieldRef<"Resource", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Assessment
   */

  export type AggregateAssessment = {
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  export type AssessmentAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    totalPoints: number | null
    passingPoints: number | null
  }

  export type AssessmentSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    totalPoints: number | null
    passingPoints: number | null
  }

  export type AssessmentMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    description: string | null
    totalPoints: number | null
    passingPoints: number | null
    createdAt: Date | null
  }

  export type AssessmentMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    description: string | null
    totalPoints: number | null
    passingPoints: number | null
    createdAt: Date | null
  }

  export type AssessmentCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    totalPoints: number
    passingPoints: number
    createdAt: number
    _all: number
  }


  export type AssessmentAvgAggregateInputType = {
    id?: true
    courseId?: true
    totalPoints?: true
    passingPoints?: true
  }

  export type AssessmentSumAggregateInputType = {
    id?: true
    courseId?: true
    totalPoints?: true
    passingPoints?: true
  }

  export type AssessmentMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    totalPoints?: true
    passingPoints?: true
    createdAt?: true
  }

  export type AssessmentMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    totalPoints?: true
    passingPoints?: true
    createdAt?: true
  }

  export type AssessmentCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    totalPoints?: true
    passingPoints?: true
    createdAt?: true
    _all?: true
  }

  export type AssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessment to aggregate.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assessments
    **/
    _count?: true | AssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMaxAggregateInputType
  }

  export type GetAssessmentAggregateType<T extends AssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessment[P]>
      : GetScalarType<T[P], AggregateAssessment[P]>
  }




  export type AssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithAggregationInput | AssessmentOrderByWithAggregationInput[]
    by: AssessmentScalarFieldEnum[] | AssessmentScalarFieldEnum
    having?: AssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentCountAggregateInputType | true
    _avg?: AssessmentAvgAggregateInputType
    _sum?: AssessmentSumAggregateInputType
    _min?: AssessmentMinAggregateInputType
    _max?: AssessmentMaxAggregateInputType
  }

  export type AssessmentGroupByOutputType = {
    id: number
    courseId: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt: Date
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  type GetAssessmentGroupByPayload<T extends AssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    totalPoints?: boolean
    passingPoints?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    questions?: boolean | Assessment$questionsArgs<ExtArgs>
    attempts?: boolean | Assessment$attemptsArgs<ExtArgs>
    _count?: boolean | AssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    totalPoints?: boolean
    passingPoints?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    totalPoints?: boolean
    passingPoints?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    totalPoints?: boolean
    passingPoints?: boolean
    createdAt?: boolean
  }

  export type AssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "description" | "totalPoints" | "passingPoints" | "createdAt", ExtArgs["result"]["assessment"]>
  export type AssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    questions?: boolean | Assessment$questionsArgs<ExtArgs>
    attempts?: boolean | Assessment$attemptsArgs<ExtArgs>
    _count?: boolean | AssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type AssessmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $AssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assessment"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      questions: Prisma.$AssessmentQuestionPayload<ExtArgs>[]
      attempts: Prisma.$UserAssessmentAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      description: string
      totalPoints: number
      passingPoints: number
      createdAt: Date
    }, ExtArgs["result"]["assessment"]>
    composites: {}
  }

  type AssessmentGetPayload<S extends boolean | null | undefined | AssessmentDefaultArgs> = $Result.GetResult<Prisma.$AssessmentPayload, S>

  type AssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentCountAggregateInputType | true
    }

  export interface AssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assessment'], meta: { name: 'Assessment' } }
    /**
     * Find zero or one Assessment that matches the filter.
     * @param {AssessmentFindUniqueArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentFindUniqueArgs>(args: SelectSubset<T, AssessmentFindUniqueArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentFindUniqueOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentFindFirstArgs>(args?: SelectSubset<T, AssessmentFindFirstArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessment.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentWithIdOnly = await prisma.assessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentFindManyArgs>(args?: SelectSubset<T, AssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assessment.
     * @param {AssessmentCreateArgs} args - Arguments to create a Assessment.
     * @example
     * // Create one Assessment
     * const Assessment = await prisma.assessment.create({
     *   data: {
     *     // ... data to create a Assessment
     *   }
     * })
     * 
     */
    create<T extends AssessmentCreateArgs>(args: SelectSubset<T, AssessmentCreateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assessments.
     * @param {AssessmentCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentCreateManyArgs>(args?: SelectSubset<T, AssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assessments and returns the data saved in the database.
     * @param {AssessmentCreateManyAndReturnArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assessments and only return the `id`
     * const assessmentWithIdOnly = await prisma.assessment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assessment.
     * @param {AssessmentDeleteArgs} args - Arguments to delete one Assessment.
     * @example
     * // Delete one Assessment
     * const Assessment = await prisma.assessment.delete({
     *   where: {
     *     // ... filter to delete one Assessment
     *   }
     * })
     * 
     */
    delete<T extends AssessmentDeleteArgs>(args: SelectSubset<T, AssessmentDeleteArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assessment.
     * @param {AssessmentUpdateArgs} args - Arguments to update one Assessment.
     * @example
     * // Update one Assessment
     * const assessment = await prisma.assessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentUpdateArgs>(args: SelectSubset<T, AssessmentUpdateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentDeleteManyArgs>(args?: SelectSubset<T, AssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentUpdateManyArgs>(args: SelectSubset<T, AssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments and returns the data updated in the database.
     * @param {AssessmentUpdateManyAndReturnArgs} args - Arguments to update many Assessments.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assessments and only return the `id`
     * const assessmentWithIdOnly = await prisma.assessment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssessmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssessmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assessment.
     * @param {AssessmentUpsertArgs} args - Arguments to update or create a Assessment.
     * @example
     * // Update or create a Assessment
     * const assessment = await prisma.assessment.upsert({
     *   create: {
     *     // ... data to create a Assessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessment we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentUpsertArgs>(args: SelectSubset<T, AssessmentUpsertArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessment.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends AssessmentCountArgs>(
      args?: Subset<T, AssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentAggregateArgs>(args: Subset<T, AssessmentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentAggregateType<T>>

    /**
     * Group by Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assessment model
   */
  readonly fields: AssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends Assessment$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Assessment$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assessment model
   */
  interface AssessmentFieldRefs {
    readonly id: FieldRef<"Assessment", 'Int'>
    readonly courseId: FieldRef<"Assessment", 'Int'>
    readonly title: FieldRef<"Assessment", 'String'>
    readonly description: FieldRef<"Assessment", 'String'>
    readonly totalPoints: FieldRef<"Assessment", 'Int'>
    readonly passingPoints: FieldRef<"Assessment", 'Int'>
    readonly createdAt: FieldRef<"Assessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assessment findUnique
   */
  export type AssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findUniqueOrThrow
   */
  export type AssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findFirst
   */
  export type AssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findFirstOrThrow
   */
  export type AssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findMany
   */
  export type AssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment create
   */
  export type AssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assessment.
     */
    data: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
  }

  /**
   * Assessment createMany
   */
  export type AssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assessment createManyAndReturn
   */
  export type AssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assessment update
   */
  export type AssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assessment.
     */
    data: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
    /**
     * Choose, which Assessment to update.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment updateMany
   */
  export type AssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
    /**
     * Limit how many Assessments to update.
     */
    limit?: number
  }

  /**
   * Assessment updateManyAndReturn
   */
  export type AssessmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
    /**
     * Limit how many Assessments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assessment upsert
   */
  export type AssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assessment to update in case it exists.
     */
    where: AssessmentWhereUniqueInput
    /**
     * In case the Assessment found by the `where` argument doesn't exist, create a new Assessment with this data.
     */
    create: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
    /**
     * In case the Assessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
  }

  /**
   * Assessment delete
   */
  export type AssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter which Assessment to delete.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment deleteMany
   */
  export type AssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentWhereInput
    /**
     * Limit how many Assessments to delete.
     */
    limit?: number
  }

  /**
   * Assessment.questions
   */
  export type Assessment$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    where?: AssessmentQuestionWhereInput
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    cursor?: AssessmentQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * Assessment.attempts
   */
  export type Assessment$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    where?: UserAssessmentAttemptWhereInput
    orderBy?: UserAssessmentAttemptOrderByWithRelationInput | UserAssessmentAttemptOrderByWithRelationInput[]
    cursor?: UserAssessmentAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssessmentAttemptScalarFieldEnum | UserAssessmentAttemptScalarFieldEnum[]
  }

  /**
   * Assessment without action
   */
  export type AssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentQuestion
   */

  export type AggregateAssessmentQuestion = {
    _count: AssessmentQuestionCountAggregateOutputType | null
    _avg: AssessmentQuestionAvgAggregateOutputType | null
    _sum: AssessmentQuestionSumAggregateOutputType | null
    _min: AssessmentQuestionMinAggregateOutputType | null
    _max: AssessmentQuestionMaxAggregateOutputType | null
  }

  export type AssessmentQuestionAvgAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    points: number | null
    orderNumber: number | null
  }

  export type AssessmentQuestionSumAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    points: number | null
    orderNumber: number | null
  }

  export type AssessmentQuestionMinAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    question: string | null
    questionType: $Enums.QuestionType | null
    points: number | null
    orderNumber: number | null
    options: string | null
    correctAnswer: string | null
  }

  export type AssessmentQuestionMaxAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    question: string | null
    questionType: $Enums.QuestionType | null
    points: number | null
    orderNumber: number | null
    options: string | null
    correctAnswer: string | null
  }

  export type AssessmentQuestionCountAggregateOutputType = {
    id: number
    assessmentId: number
    question: number
    questionType: number
    points: number
    orderNumber: number
    options: number
    correctAnswer: number
    _all: number
  }


  export type AssessmentQuestionAvgAggregateInputType = {
    id?: true
    assessmentId?: true
    points?: true
    orderNumber?: true
  }

  export type AssessmentQuestionSumAggregateInputType = {
    id?: true
    assessmentId?: true
    points?: true
    orderNumber?: true
  }

  export type AssessmentQuestionMinAggregateInputType = {
    id?: true
    assessmentId?: true
    question?: true
    questionType?: true
    points?: true
    orderNumber?: true
    options?: true
    correctAnswer?: true
  }

  export type AssessmentQuestionMaxAggregateInputType = {
    id?: true
    assessmentId?: true
    question?: true
    questionType?: true
    points?: true
    orderNumber?: true
    options?: true
    correctAnswer?: true
  }

  export type AssessmentQuestionCountAggregateInputType = {
    id?: true
    assessmentId?: true
    question?: true
    questionType?: true
    points?: true
    orderNumber?: true
    options?: true
    correctAnswer?: true
    _all?: true
  }

  export type AssessmentQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestion to aggregate.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentQuestions
    **/
    _count?: true | AssessmentQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentQuestionMaxAggregateInputType
  }

  export type GetAssessmentQuestionAggregateType<T extends AssessmentQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentQuestion[P]>
      : GetScalarType<T[P], AggregateAssessmentQuestion[P]>
  }




  export type AssessmentQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionWhereInput
    orderBy?: AssessmentQuestionOrderByWithAggregationInput | AssessmentQuestionOrderByWithAggregationInput[]
    by: AssessmentQuestionScalarFieldEnum[] | AssessmentQuestionScalarFieldEnum
    having?: AssessmentQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentQuestionCountAggregateInputType | true
    _avg?: AssessmentQuestionAvgAggregateInputType
    _sum?: AssessmentQuestionSumAggregateInputType
    _min?: AssessmentQuestionMinAggregateInputType
    _max?: AssessmentQuestionMaxAggregateInputType
  }

  export type AssessmentQuestionGroupByOutputType = {
    id: number
    assessmentId: number
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options: string | null
    correctAnswer: string | null
    _count: AssessmentQuestionCountAggregateOutputType | null
    _avg: AssessmentQuestionAvgAggregateOutputType | null
    _sum: AssessmentQuestionSumAggregateOutputType | null
    _min: AssessmentQuestionMinAggregateOutputType | null
    _max: AssessmentQuestionMaxAggregateOutputType | null
  }

  type GetAssessmentQuestionGroupByPayload<T extends AssessmentQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentQuestionGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>

  export type AssessmentQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>

  export type AssessmentQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>

  export type AssessmentQuestionSelectScalar = {
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    questionType?: boolean
    points?: boolean
    orderNumber?: boolean
    options?: boolean
    correctAnswer?: boolean
  }

  export type AssessmentQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assessmentId" | "question" | "questionType" | "points" | "orderNumber" | "options" | "correctAnswer", ExtArgs["result"]["assessmentQuestion"]>
  export type AssessmentQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type AssessmentQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type AssessmentQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }

  export type $AssessmentQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentQuestion"
    objects: {
      assessment: Prisma.$AssessmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assessmentId: number
      question: string
      questionType: $Enums.QuestionType
      points: number
      orderNumber: number
      options: string | null
      correctAnswer: string | null
    }, ExtArgs["result"]["assessmentQuestion"]>
    composites: {}
  }

  type AssessmentQuestionGetPayload<S extends boolean | null | undefined | AssessmentQuestionDefaultArgs> = $Result.GetResult<Prisma.$AssessmentQuestionPayload, S>

  type AssessmentQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentQuestionCountAggregateInputType | true
    }

  export interface AssessmentQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentQuestion'], meta: { name: 'AssessmentQuestion' } }
    /**
     * Find zero or one AssessmentQuestion that matches the filter.
     * @param {AssessmentQuestionFindUniqueArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentQuestionFindUniqueArgs>(args: SelectSubset<T, AssessmentQuestionFindUniqueArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssessmentQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentQuestionFindUniqueOrThrowArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssessmentQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindFirstArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentQuestionFindFirstArgs>(args?: SelectSubset<T, AssessmentQuestionFindFirstArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssessmentQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindFirstOrThrowArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssessmentQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestion.findMany()
     * 
     * // Get first 10 AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentQuestionFindManyArgs>(args?: SelectSubset<T, AssessmentQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssessmentQuestion.
     * @param {AssessmentQuestionCreateArgs} args - Arguments to create a AssessmentQuestion.
     * @example
     * // Create one AssessmentQuestion
     * const AssessmentQuestion = await prisma.assessmentQuestion.create({
     *   data: {
     *     // ... data to create a AssessmentQuestion
     *   }
     * })
     * 
     */
    create<T extends AssessmentQuestionCreateArgs>(args: SelectSubset<T, AssessmentQuestionCreateArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssessmentQuestions.
     * @param {AssessmentQuestionCreateManyArgs} args - Arguments to create many AssessmentQuestions.
     * @example
     * // Create many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentQuestionCreateManyArgs>(args?: SelectSubset<T, AssessmentQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssessmentQuestions and returns the data saved in the database.
     * @param {AssessmentQuestionCreateManyAndReturnArgs} args - Arguments to create many AssessmentQuestions.
     * @example
     * // Create many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssessmentQuestions and only return the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssessmentQuestion.
     * @param {AssessmentQuestionDeleteArgs} args - Arguments to delete one AssessmentQuestion.
     * @example
     * // Delete one AssessmentQuestion
     * const AssessmentQuestion = await prisma.assessmentQuestion.delete({
     *   where: {
     *     // ... filter to delete one AssessmentQuestion
     *   }
     * })
     * 
     */
    delete<T extends AssessmentQuestionDeleteArgs>(args: SelectSubset<T, AssessmentQuestionDeleteArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssessmentQuestion.
     * @param {AssessmentQuestionUpdateArgs} args - Arguments to update one AssessmentQuestion.
     * @example
     * // Update one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentQuestionUpdateArgs>(args: SelectSubset<T, AssessmentQuestionUpdateArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssessmentQuestions.
     * @param {AssessmentQuestionDeleteManyArgs} args - Arguments to filter AssessmentQuestions to delete.
     * @example
     * // Delete a few AssessmentQuestions
     * const { count } = await prisma.assessmentQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentQuestionDeleteManyArgs>(args?: SelectSubset<T, AssessmentQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentQuestionUpdateManyArgs>(args: SelectSubset<T, AssessmentQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentQuestions and returns the data updated in the database.
     * @param {AssessmentQuestionUpdateManyAndReturnArgs} args - Arguments to update many AssessmentQuestions.
     * @example
     * // Update many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssessmentQuestions and only return the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssessmentQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssessmentQuestion.
     * @param {AssessmentQuestionUpsertArgs} args - Arguments to update or create a AssessmentQuestion.
     * @example
     * // Update or create a AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.upsert({
     *   create: {
     *     // ... data to create a AssessmentQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentQuestion we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentQuestionUpsertArgs>(args: SelectSubset<T, AssessmentQuestionUpsertArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionCountArgs} args - Arguments to filter AssessmentQuestions to count.
     * @example
     * // Count the number of AssessmentQuestions
     * const count = await prisma.assessmentQuestion.count({
     *   where: {
     *     // ... the filter for the AssessmentQuestions we want to count
     *   }
     * })
    **/
    count<T extends AssessmentQuestionCountArgs>(
      args?: Subset<T, AssessmentQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentQuestionAggregateArgs>(args: Subset<T, AssessmentQuestionAggregateArgs>): Prisma.PrismaPromise<GetAssessmentQuestionAggregateType<T>>

    /**
     * Group by AssessmentQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentQuestionGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentQuestion model
   */
  readonly fields: AssessmentQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assessment<T extends AssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentDefaultArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentQuestion model
   */
  interface AssessmentQuestionFieldRefs {
    readonly id: FieldRef<"AssessmentQuestion", 'Int'>
    readonly assessmentId: FieldRef<"AssessmentQuestion", 'Int'>
    readonly question: FieldRef<"AssessmentQuestion", 'String'>
    readonly questionType: FieldRef<"AssessmentQuestion", 'QuestionType'>
    readonly points: FieldRef<"AssessmentQuestion", 'Int'>
    readonly orderNumber: FieldRef<"AssessmentQuestion", 'Int'>
    readonly options: FieldRef<"AssessmentQuestion", 'String'>
    readonly correctAnswer: FieldRef<"AssessmentQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentQuestion findUnique
   */
  export type AssessmentQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion findUniqueOrThrow
   */
  export type AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion findFirst
   */
  export type AssessmentQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion findFirstOrThrow
   */
  export type AssessmentQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion findMany
   */
  export type AssessmentQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion create
   */
  export type AssessmentQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentQuestion.
     */
    data: XOR<AssessmentQuestionCreateInput, AssessmentQuestionUncheckedCreateInput>
  }

  /**
   * AssessmentQuestion createMany
   */
  export type AssessmentQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentQuestions.
     */
    data: AssessmentQuestionCreateManyInput | AssessmentQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentQuestion createManyAndReturn
   */
  export type AssessmentQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many AssessmentQuestions.
     */
    data: AssessmentQuestionCreateManyInput | AssessmentQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentQuestion update
   */
  export type AssessmentQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentQuestion.
     */
    data: XOR<AssessmentQuestionUpdateInput, AssessmentQuestionUncheckedUpdateInput>
    /**
     * Choose, which AssessmentQuestion to update.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion updateMany
   */
  export type AssessmentQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentQuestions to update
     */
    where?: AssessmentQuestionWhereInput
    /**
     * Limit how many AssessmentQuestions to update.
     */
    limit?: number
  }

  /**
   * AssessmentQuestion updateManyAndReturn
   */
  export type AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * The data used to update AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentQuestions to update
     */
    where?: AssessmentQuestionWhereInput
    /**
     * Limit how many AssessmentQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentQuestion upsert
   */
  export type AssessmentQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentQuestion to update in case it exists.
     */
    where: AssessmentQuestionWhereUniqueInput
    /**
     * In case the AssessmentQuestion found by the `where` argument doesn't exist, create a new AssessmentQuestion with this data.
     */
    create: XOR<AssessmentQuestionCreateInput, AssessmentQuestionUncheckedCreateInput>
    /**
     * In case the AssessmentQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentQuestionUpdateInput, AssessmentQuestionUncheckedUpdateInput>
  }

  /**
   * AssessmentQuestion delete
   */
  export type AssessmentQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter which AssessmentQuestion to delete.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion deleteMany
   */
  export type AssessmentQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestions to delete
     */
    where?: AssessmentQuestionWhereInput
    /**
     * Limit how many AssessmentQuestions to delete.
     */
    limit?: number
  }

  /**
   * AssessmentQuestion without action
   */
  export type AssessmentQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
  }


  /**
   * Model UserAssessmentAttempt
   */

  export type AggregateUserAssessmentAttempt = {
    _count: UserAssessmentAttemptCountAggregateOutputType | null
    _avg: UserAssessmentAttemptAvgAggregateOutputType | null
    _sum: UserAssessmentAttemptSumAggregateOutputType | null
    _min: UserAssessmentAttemptMinAggregateOutputType | null
    _max: UserAssessmentAttemptMaxAggregateOutputType | null
  }

  export type UserAssessmentAttemptAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    attemptNumber: number | null
  }

  export type UserAssessmentAttemptSumAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    attemptNumber: number | null
  }

  export type UserAssessmentAttemptMinAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    passed: boolean | null
    attemptDate: Date | null
    attemptNumber: number | null
    answers: string | null
  }

  export type UserAssessmentAttemptMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    passed: boolean | null
    attemptDate: Date | null
    attemptNumber: number | null
    answers: string | null
  }

  export type UserAssessmentAttemptCountAggregateOutputType = {
    id: number
    userId: number
    assessmentId: number
    score: number
    passed: number
    attemptDate: number
    attemptNumber: number
    answers: number
    _all: number
  }


  export type UserAssessmentAttemptAvgAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    attemptNumber?: true
  }

  export type UserAssessmentAttemptSumAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    attemptNumber?: true
  }

  export type UserAssessmentAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    passed?: true
    attemptDate?: true
    attemptNumber?: true
    answers?: true
  }

  export type UserAssessmentAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    passed?: true
    attemptDate?: true
    attemptNumber?: true
    answers?: true
  }

  export type UserAssessmentAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    passed?: true
    attemptDate?: true
    attemptNumber?: true
    answers?: true
    _all?: true
  }

  export type UserAssessmentAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAssessmentAttempt to aggregate.
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessmentAttempts to fetch.
     */
    orderBy?: UserAssessmentAttemptOrderByWithRelationInput | UserAssessmentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAssessmentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessmentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessmentAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAssessmentAttempts
    **/
    _count?: true | UserAssessmentAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAssessmentAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAssessmentAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAssessmentAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAssessmentAttemptMaxAggregateInputType
  }

  export type GetUserAssessmentAttemptAggregateType<T extends UserAssessmentAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAssessmentAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAssessmentAttempt[P]>
      : GetScalarType<T[P], AggregateUserAssessmentAttempt[P]>
  }




  export type UserAssessmentAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentAttemptWhereInput
    orderBy?: UserAssessmentAttemptOrderByWithAggregationInput | UserAssessmentAttemptOrderByWithAggregationInput[]
    by: UserAssessmentAttemptScalarFieldEnum[] | UserAssessmentAttemptScalarFieldEnum
    having?: UserAssessmentAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAssessmentAttemptCountAggregateInputType | true
    _avg?: UserAssessmentAttemptAvgAggregateInputType
    _sum?: UserAssessmentAttemptSumAggregateInputType
    _min?: UserAssessmentAttemptMinAggregateInputType
    _max?: UserAssessmentAttemptMaxAggregateInputType
  }

  export type UserAssessmentAttemptGroupByOutputType = {
    id: number
    userId: number
    assessmentId: number
    score: number
    passed: boolean
    attemptDate: Date
    attemptNumber: number
    answers: string | null
    _count: UserAssessmentAttemptCountAggregateOutputType | null
    _avg: UserAssessmentAttemptAvgAggregateOutputType | null
    _sum: UserAssessmentAttemptSumAggregateOutputType | null
    _min: UserAssessmentAttemptMinAggregateOutputType | null
    _max: UserAssessmentAttemptMaxAggregateOutputType | null
  }

  type GetUserAssessmentAttemptGroupByPayload<T extends UserAssessmentAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAssessmentAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAssessmentAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAssessmentAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], UserAssessmentAttemptGroupByOutputType[P]>
        }
      >
    >


  export type UserAssessmentAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    passed?: boolean
    attemptDate?: boolean
    attemptNumber?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssessmentAttempt"]>

  export type UserAssessmentAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    passed?: boolean
    attemptDate?: boolean
    attemptNumber?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssessmentAttempt"]>

  export type UserAssessmentAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    passed?: boolean
    attemptDate?: boolean
    attemptNumber?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssessmentAttempt"]>

  export type UserAssessmentAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    passed?: boolean
    attemptDate?: boolean
    attemptNumber?: boolean
    answers?: boolean
  }

  export type UserAssessmentAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assessmentId" | "score" | "passed" | "attemptDate" | "attemptNumber" | "answers", ExtArgs["result"]["userAssessmentAttempt"]>
  export type UserAssessmentAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type UserAssessmentAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type UserAssessmentAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }

  export type $UserAssessmentAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAssessmentAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assessment: Prisma.$AssessmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      assessmentId: number
      score: number
      passed: boolean
      attemptDate: Date
      attemptNumber: number
      answers: string | null
    }, ExtArgs["result"]["userAssessmentAttempt"]>
    composites: {}
  }

  type UserAssessmentAttemptGetPayload<S extends boolean | null | undefined | UserAssessmentAttemptDefaultArgs> = $Result.GetResult<Prisma.$UserAssessmentAttemptPayload, S>

  type UserAssessmentAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAssessmentAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAssessmentAttemptCountAggregateInputType | true
    }

  export interface UserAssessmentAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAssessmentAttempt'], meta: { name: 'UserAssessmentAttempt' } }
    /**
     * Find zero or one UserAssessmentAttempt that matches the filter.
     * @param {UserAssessmentAttemptFindUniqueArgs} args - Arguments to find a UserAssessmentAttempt
     * @example
     * // Get one UserAssessmentAttempt
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAssessmentAttemptFindUniqueArgs>(args: SelectSubset<T, UserAssessmentAttemptFindUniqueArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAssessmentAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAssessmentAttemptFindUniqueOrThrowArgs} args - Arguments to find a UserAssessmentAttempt
     * @example
     * // Get one UserAssessmentAttempt
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAssessmentAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAssessmentAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAssessmentAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptFindFirstArgs} args - Arguments to find a UserAssessmentAttempt
     * @example
     * // Get one UserAssessmentAttempt
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAssessmentAttemptFindFirstArgs>(args?: SelectSubset<T, UserAssessmentAttemptFindFirstArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAssessmentAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptFindFirstOrThrowArgs} args - Arguments to find a UserAssessmentAttempt
     * @example
     * // Get one UserAssessmentAttempt
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAssessmentAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAssessmentAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAssessmentAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAssessmentAttempts
     * const userAssessmentAttempts = await prisma.userAssessmentAttempt.findMany()
     * 
     * // Get first 10 UserAssessmentAttempts
     * const userAssessmentAttempts = await prisma.userAssessmentAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAssessmentAttemptWithIdOnly = await prisma.userAssessmentAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAssessmentAttemptFindManyArgs>(args?: SelectSubset<T, UserAssessmentAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAssessmentAttempt.
     * @param {UserAssessmentAttemptCreateArgs} args - Arguments to create a UserAssessmentAttempt.
     * @example
     * // Create one UserAssessmentAttempt
     * const UserAssessmentAttempt = await prisma.userAssessmentAttempt.create({
     *   data: {
     *     // ... data to create a UserAssessmentAttempt
     *   }
     * })
     * 
     */
    create<T extends UserAssessmentAttemptCreateArgs>(args: SelectSubset<T, UserAssessmentAttemptCreateArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAssessmentAttempts.
     * @param {UserAssessmentAttemptCreateManyArgs} args - Arguments to create many UserAssessmentAttempts.
     * @example
     * // Create many UserAssessmentAttempts
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAssessmentAttemptCreateManyArgs>(args?: SelectSubset<T, UserAssessmentAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAssessmentAttempts and returns the data saved in the database.
     * @param {UserAssessmentAttemptCreateManyAndReturnArgs} args - Arguments to create many UserAssessmentAttempts.
     * @example
     * // Create many UserAssessmentAttempts
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAssessmentAttempts and only return the `id`
     * const userAssessmentAttemptWithIdOnly = await prisma.userAssessmentAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAssessmentAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAssessmentAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAssessmentAttempt.
     * @param {UserAssessmentAttemptDeleteArgs} args - Arguments to delete one UserAssessmentAttempt.
     * @example
     * // Delete one UserAssessmentAttempt
     * const UserAssessmentAttempt = await prisma.userAssessmentAttempt.delete({
     *   where: {
     *     // ... filter to delete one UserAssessmentAttempt
     *   }
     * })
     * 
     */
    delete<T extends UserAssessmentAttemptDeleteArgs>(args: SelectSubset<T, UserAssessmentAttemptDeleteArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAssessmentAttempt.
     * @param {UserAssessmentAttemptUpdateArgs} args - Arguments to update one UserAssessmentAttempt.
     * @example
     * // Update one UserAssessmentAttempt
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAssessmentAttemptUpdateArgs>(args: SelectSubset<T, UserAssessmentAttemptUpdateArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAssessmentAttempts.
     * @param {UserAssessmentAttemptDeleteManyArgs} args - Arguments to filter UserAssessmentAttempts to delete.
     * @example
     * // Delete a few UserAssessmentAttempts
     * const { count } = await prisma.userAssessmentAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAssessmentAttemptDeleteManyArgs>(args?: SelectSubset<T, UserAssessmentAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAssessmentAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAssessmentAttempts
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAssessmentAttemptUpdateManyArgs>(args: SelectSubset<T, UserAssessmentAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAssessmentAttempts and returns the data updated in the database.
     * @param {UserAssessmentAttemptUpdateManyAndReturnArgs} args - Arguments to update many UserAssessmentAttempts.
     * @example
     * // Update many UserAssessmentAttempts
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAssessmentAttempts and only return the `id`
     * const userAssessmentAttemptWithIdOnly = await prisma.userAssessmentAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAssessmentAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAssessmentAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAssessmentAttempt.
     * @param {UserAssessmentAttemptUpsertArgs} args - Arguments to update or create a UserAssessmentAttempt.
     * @example
     * // Update or create a UserAssessmentAttempt
     * const userAssessmentAttempt = await prisma.userAssessmentAttempt.upsert({
     *   create: {
     *     // ... data to create a UserAssessmentAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAssessmentAttempt we want to update
     *   }
     * })
     */
    upsert<T extends UserAssessmentAttemptUpsertArgs>(args: SelectSubset<T, UserAssessmentAttemptUpsertArgs<ExtArgs>>): Prisma__UserAssessmentAttemptClient<$Result.GetResult<Prisma.$UserAssessmentAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAssessmentAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptCountArgs} args - Arguments to filter UserAssessmentAttempts to count.
     * @example
     * // Count the number of UserAssessmentAttempts
     * const count = await prisma.userAssessmentAttempt.count({
     *   where: {
     *     // ... the filter for the UserAssessmentAttempts we want to count
     *   }
     * })
    **/
    count<T extends UserAssessmentAttemptCountArgs>(
      args?: Subset<T, UserAssessmentAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAssessmentAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAssessmentAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAssessmentAttemptAggregateArgs>(args: Subset<T, UserAssessmentAttemptAggregateArgs>): Prisma.PrismaPromise<GetUserAssessmentAttemptAggregateType<T>>

    /**
     * Group by UserAssessmentAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAssessmentAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAssessmentAttemptGroupByArgs['orderBy'] }
        : { orderBy?: UserAssessmentAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAssessmentAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAssessmentAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAssessmentAttempt model
   */
  readonly fields: UserAssessmentAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAssessmentAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAssessmentAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assessment<T extends AssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentDefaultArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAssessmentAttempt model
   */
  interface UserAssessmentAttemptFieldRefs {
    readonly id: FieldRef<"UserAssessmentAttempt", 'Int'>
    readonly userId: FieldRef<"UserAssessmentAttempt", 'Int'>
    readonly assessmentId: FieldRef<"UserAssessmentAttempt", 'Int'>
    readonly score: FieldRef<"UserAssessmentAttempt", 'Int'>
    readonly passed: FieldRef<"UserAssessmentAttempt", 'Boolean'>
    readonly attemptDate: FieldRef<"UserAssessmentAttempt", 'DateTime'>
    readonly attemptNumber: FieldRef<"UserAssessmentAttempt", 'Int'>
    readonly answers: FieldRef<"UserAssessmentAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAssessmentAttempt findUnique
   */
  export type UserAssessmentAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessmentAttempt to fetch.
     */
    where: UserAssessmentAttemptWhereUniqueInput
  }

  /**
   * UserAssessmentAttempt findUniqueOrThrow
   */
  export type UserAssessmentAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessmentAttempt to fetch.
     */
    where: UserAssessmentAttemptWhereUniqueInput
  }

  /**
   * UserAssessmentAttempt findFirst
   */
  export type UserAssessmentAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessmentAttempt to fetch.
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessmentAttempts to fetch.
     */
    orderBy?: UserAssessmentAttemptOrderByWithRelationInput | UserAssessmentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAssessmentAttempts.
     */
    cursor?: UserAssessmentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessmentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessmentAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAssessmentAttempts.
     */
    distinct?: UserAssessmentAttemptScalarFieldEnum | UserAssessmentAttemptScalarFieldEnum[]
  }

  /**
   * UserAssessmentAttempt findFirstOrThrow
   */
  export type UserAssessmentAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessmentAttempt to fetch.
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessmentAttempts to fetch.
     */
    orderBy?: UserAssessmentAttemptOrderByWithRelationInput | UserAssessmentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAssessmentAttempts.
     */
    cursor?: UserAssessmentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessmentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessmentAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAssessmentAttempts.
     */
    distinct?: UserAssessmentAttemptScalarFieldEnum | UserAssessmentAttemptScalarFieldEnum[]
  }

  /**
   * UserAssessmentAttempt findMany
   */
  export type UserAssessmentAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessmentAttempts to fetch.
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessmentAttempts to fetch.
     */
    orderBy?: UserAssessmentAttemptOrderByWithRelationInput | UserAssessmentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAssessmentAttempts.
     */
    cursor?: UserAssessmentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessmentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessmentAttempts.
     */
    skip?: number
    distinct?: UserAssessmentAttemptScalarFieldEnum | UserAssessmentAttemptScalarFieldEnum[]
  }

  /**
   * UserAssessmentAttempt create
   */
  export type UserAssessmentAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAssessmentAttempt.
     */
    data: XOR<UserAssessmentAttemptCreateInput, UserAssessmentAttemptUncheckedCreateInput>
  }

  /**
   * UserAssessmentAttempt createMany
   */
  export type UserAssessmentAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAssessmentAttempts.
     */
    data: UserAssessmentAttemptCreateManyInput | UserAssessmentAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAssessmentAttempt createManyAndReturn
   */
  export type UserAssessmentAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many UserAssessmentAttempts.
     */
    data: UserAssessmentAttemptCreateManyInput | UserAssessmentAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAssessmentAttempt update
   */
  export type UserAssessmentAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAssessmentAttempt.
     */
    data: XOR<UserAssessmentAttemptUpdateInput, UserAssessmentAttemptUncheckedUpdateInput>
    /**
     * Choose, which UserAssessmentAttempt to update.
     */
    where: UserAssessmentAttemptWhereUniqueInput
  }

  /**
   * UserAssessmentAttempt updateMany
   */
  export type UserAssessmentAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAssessmentAttempts.
     */
    data: XOR<UserAssessmentAttemptUpdateManyMutationInput, UserAssessmentAttemptUncheckedUpdateManyInput>
    /**
     * Filter which UserAssessmentAttempts to update
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * Limit how many UserAssessmentAttempts to update.
     */
    limit?: number
  }

  /**
   * UserAssessmentAttempt updateManyAndReturn
   */
  export type UserAssessmentAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * The data used to update UserAssessmentAttempts.
     */
    data: XOR<UserAssessmentAttemptUpdateManyMutationInput, UserAssessmentAttemptUncheckedUpdateManyInput>
    /**
     * Filter which UserAssessmentAttempts to update
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * Limit how many UserAssessmentAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAssessmentAttempt upsert
   */
  export type UserAssessmentAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAssessmentAttempt to update in case it exists.
     */
    where: UserAssessmentAttemptWhereUniqueInput
    /**
     * In case the UserAssessmentAttempt found by the `where` argument doesn't exist, create a new UserAssessmentAttempt with this data.
     */
    create: XOR<UserAssessmentAttemptCreateInput, UserAssessmentAttemptUncheckedCreateInput>
    /**
     * In case the UserAssessmentAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAssessmentAttemptUpdateInput, UserAssessmentAttemptUncheckedUpdateInput>
  }

  /**
   * UserAssessmentAttempt delete
   */
  export type UserAssessmentAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
    /**
     * Filter which UserAssessmentAttempt to delete.
     */
    where: UserAssessmentAttemptWhereUniqueInput
  }

  /**
   * UserAssessmentAttempt deleteMany
   */
  export type UserAssessmentAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAssessmentAttempts to delete
     */
    where?: UserAssessmentAttemptWhereInput
    /**
     * Limit how many UserAssessmentAttempts to delete.
     */
    limit?: number
  }

  /**
   * UserAssessmentAttempt without action
   */
  export type UserAssessmentAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessmentAttempt
     */
    select?: UserAssessmentAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessmentAttempt
     */
    omit?: UserAssessmentAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentAttemptInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
    providerId: number | null
    targetId: number | null
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
    providerId: number | null
    targetId: number | null
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    providerId: number | null
    targetId: number | null
    targetType: $Enums.FeedbackTarget | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    providerId: number | null
    targetId: number | null
    targetType: $Enums.FeedbackTarget | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    providerId: number
    targetId: number
    targetType: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
    providerId?: true
    targetId?: true
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
    providerId?: true
    targetId?: true
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    providerId?: true
    targetId?: true
    targetType?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    providerId?: true
    targetId?: true
    targetType?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    providerId?: true
    targetId?: true
    targetType?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    providerId: number
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment: string | null
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    targetId?: boolean
    targetType?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    targetId?: boolean
    targetType?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    targetId?: boolean
    targetType?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    providerId?: boolean
    targetId?: boolean
    targetType?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "targetId" | "targetType" | "rating" | "comment" | "createdAt", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      providerId: number
      targetId: number
      targetType: $Enums.FeedbackTarget
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly providerId: FieldRef<"Feedback", 'Int'>
    readonly targetId: FieldRef<"Feedback", 'Int'>
    readonly targetType: FieldRef<"Feedback", 'FeedbackTarget'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly comment: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Subscriber
   */

  export type AggregateSubscriber = {
    _count: SubscriberCountAggregateOutputType | null
    _avg: SubscriberAvgAggregateOutputType | null
    _sum: SubscriberSumAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  export type SubscriberAvgAggregateOutputType = {
    id: number | null
  }

  export type SubscriberSumAggregateOutputType = {
    id: number | null
  }

  export type SubscriberMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriberMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriberCountAggregateOutputType = {
    id: number
    email: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriberAvgAggregateInputType = {
    id?: true
  }

  export type SubscriberSumAggregateInputType = {
    id?: true
  }

  export type SubscriberMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriberMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriberCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriber to aggregate.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribers
    **/
    _count?: true | SubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriberMaxAggregateInputType
  }

  export type GetSubscriberAggregateType<T extends SubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriber[P]>
      : GetScalarType<T[P], AggregateSubscriber[P]>
  }




  export type SubscriberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberWhereInput
    orderBy?: SubscriberOrderByWithAggregationInput | SubscriberOrderByWithAggregationInput[]
    by: SubscriberScalarFieldEnum[] | SubscriberScalarFieldEnum
    having?: SubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriberCountAggregateInputType | true
    _avg?: SubscriberAvgAggregateInputType
    _sum?: SubscriberSumAggregateInputType
    _min?: SubscriberMinAggregateInputType
    _max?: SubscriberMaxAggregateInputType
  }

  export type SubscriberGroupByOutputType = {
    id: number
    email: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriberCountAggregateOutputType | null
    _avg: SubscriberAvgAggregateOutputType | null
    _sum: SubscriberSumAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  type GetSubscriberGroupByPayload<T extends SubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
        }
      >
    >


  export type SubscriberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriber"]>

  export type $SubscriberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriber"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriber"]>
    composites: {}
  }

  type SubscriberGetPayload<S extends boolean | null | undefined | SubscriberDefaultArgs> = $Result.GetResult<Prisma.$SubscriberPayload, S>

  type SubscriberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriberCountAggregateInputType | true
    }

  export interface SubscriberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriber'], meta: { name: 'Subscriber' } }
    /**
     * Find zero or one Subscriber that matches the filter.
     * @param {SubscriberFindUniqueArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriberFindUniqueArgs>(args: SelectSubset<T, SubscriberFindUniqueArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriberFindUniqueOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriberFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriberFindFirstArgs>(args?: SelectSubset<T, SubscriberFindFirstArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriberFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribers
     * const subscribers = await prisma.subscriber.findMany()
     * 
     * // Get first 10 Subscribers
     * const subscribers = await prisma.subscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriberFindManyArgs>(args?: SelectSubset<T, SubscriberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriber.
     * @param {SubscriberCreateArgs} args - Arguments to create a Subscriber.
     * @example
     * // Create one Subscriber
     * const Subscriber = await prisma.subscriber.create({
     *   data: {
     *     // ... data to create a Subscriber
     *   }
     * })
     * 
     */
    create<T extends SubscriberCreateArgs>(args: SelectSubset<T, SubscriberCreateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscribers.
     * @param {SubscriberCreateManyArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriberCreateManyArgs>(args?: SelectSubset<T, SubscriberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscribers and returns the data saved in the database.
     * @param {SubscriberCreateManyAndReturnArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscribers and only return the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriberCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscriber.
     * @param {SubscriberDeleteArgs} args - Arguments to delete one Subscriber.
     * @example
     * // Delete one Subscriber
     * const Subscriber = await prisma.subscriber.delete({
     *   where: {
     *     // ... filter to delete one Subscriber
     *   }
     * })
     * 
     */
    delete<T extends SubscriberDeleteArgs>(args: SelectSubset<T, SubscriberDeleteArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriber.
     * @param {SubscriberUpdateArgs} args - Arguments to update one Subscriber.
     * @example
     * // Update one Subscriber
     * const subscriber = await prisma.subscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriberUpdateArgs>(args: SelectSubset<T, SubscriberUpdateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscribers.
     * @param {SubscriberDeleteManyArgs} args - Arguments to filter Subscribers to delete.
     * @example
     * // Delete a few Subscribers
     * const { count } = await prisma.subscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriberDeleteManyArgs>(args?: SelectSubset<T, SubscriberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriberUpdateManyArgs>(args: SelectSubset<T, SubscriberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers and returns the data updated in the database.
     * @param {SubscriberUpdateManyAndReturnArgs} args - Arguments to update many Subscribers.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscribers and only return the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriberUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscriber.
     * @param {SubscriberUpsertArgs} args - Arguments to update or create a Subscriber.
     * @example
     * // Update or create a Subscriber
     * const subscriber = await prisma.subscriber.upsert({
     *   create: {
     *     // ... data to create a Subscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriber we want to update
     *   }
     * })
     */
    upsert<T extends SubscriberUpsertArgs>(args: SelectSubset<T, SubscriberUpsertArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberCountArgs} args - Arguments to filter Subscribers to count.
     * @example
     * // Count the number of Subscribers
     * const count = await prisma.subscriber.count({
     *   where: {
     *     // ... the filter for the Subscribers we want to count
     *   }
     * })
    **/
    count<T extends SubscriberCountArgs>(
      args?: Subset<T, SubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriberAggregateArgs>(args: Subset<T, SubscriberAggregateArgs>): Prisma.PrismaPromise<GetSubscriberAggregateType<T>>

    /**
     * Group by Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriberGroupByArgs['orderBy'] }
        : { orderBy?: SubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriber model
   */
  readonly fields: SubscriberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriber model
   */
  interface SubscriberFieldRefs {
    readonly id: FieldRef<"Subscriber", 'Int'>
    readonly email: FieldRef<"Subscriber", 'String'>
    readonly name: FieldRef<"Subscriber", 'String'>
    readonly createdAt: FieldRef<"Subscriber", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscriber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscriber findUnique
   */
  export type SubscriberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findUniqueOrThrow
   */
  export type SubscriberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findFirst
   */
  export type SubscriberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findFirstOrThrow
   */
  export type SubscriberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findMany
   */
  export type SubscriberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter, which Subscribers to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber create
   */
  export type SubscriberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data needed to create a Subscriber.
     */
    data: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
  }

  /**
   * Subscriber createMany
   */
  export type SubscriberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriber createManyAndReturn
   */
  export type SubscriberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriber update
   */
  export type SubscriberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data needed to update a Subscriber.
     */
    data: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
    /**
     * Choose, which Subscriber to update.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber updateMany
   */
  export type SubscriberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscribers.
     */
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    /**
     * Filter which Subscribers to update
     */
    where?: SubscriberWhereInput
    /**
     * Limit how many Subscribers to update.
     */
    limit?: number
  }

  /**
   * Subscriber updateManyAndReturn
   */
  export type SubscriberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The data used to update Subscribers.
     */
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    /**
     * Filter which Subscribers to update
     */
    where?: SubscriberWhereInput
    /**
     * Limit how many Subscribers to update.
     */
    limit?: number
  }

  /**
   * Subscriber upsert
   */
  export type SubscriberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * The filter to search for the Subscriber to update in case it exists.
     */
    where: SubscriberWhereUniqueInput
    /**
     * In case the Subscriber found by the `where` argument doesn't exist, create a new Subscriber with this data.
     */
    create: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
    /**
     * In case the Subscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
  }

  /**
   * Subscriber delete
   */
  export type SubscriberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
    /**
     * Filter which Subscriber to delete.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber deleteMany
   */
  export type SubscriberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscribers to delete
     */
    where?: SubscriberWhereInput
    /**
     * Limit how many Subscribers to delete.
     */
    limit?: number
  }

  /**
   * Subscriber without action
   */
  export type SubscriberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriber
     */
    omit?: SubscriberOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    dateOfBirth: 'dateOfBirth',
    age: 'age',
    phone: 'phone',
    country: 'country',
    city: 'city',
    bio: 'bio',
    profileImage: 'profileImage',
    gender: 'gender',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    verificationToken: 'verificationToken',
    verificationExpires: 'verificationExpires',
    lastActive: 'lastActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FlashcardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    moduleId: 'moduleId',
    question: 'question',
    answer: 'answer',
    difficultyLevel: 'difficultyLevel',
    tags: 'tags',
    aiGenerated: 'aiGenerated',
    createdAt: 'createdAt',
    lastReviewed: 'lastReviewed',
    timesReviewed: 'timesReviewed',
    confidenceLevel: 'confidenceLevel',
    aiModel: 'aiModel',
    generationPrompt: 'generationPrompt',
    sourceContentSnippet: 'sourceContentSnippet'
  };

  export type FlashcardScalarFieldEnum = (typeof FlashcardScalarFieldEnum)[keyof typeof FlashcardScalarFieldEnum]


  export const FlashcardInteractionScalarFieldEnum: {
    id: 'id',
    flashcardId: 'flashcardId',
    userId: 'userId',
    correct: 'correct',
    responseTime: 'responseTime',
    interactionDate: 'interactionDate'
  };

  export type FlashcardInteractionScalarFieldEnum = (typeof FlashcardInteractionScalarFieldEnum)[keyof typeof FlashcardInteractionScalarFieldEnum]


  export const FlashcardCollectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    createdAt: 'createdAt',
    isPublic: 'isPublic'
  };

  export type FlashcardCollectionScalarFieldEnum = (typeof FlashcardCollectionScalarFieldEnum)[keyof typeof FlashcardCollectionScalarFieldEnum]


  export const FlashcardCollectionItemScalarFieldEnum: {
    id: 'id',
    collectionId: 'collectionId',
    flashcardId: 'flashcardId',
    addedAt: 'addedAt'
  };

  export type FlashcardCollectionItemScalarFieldEnum = (typeof FlashcardCollectionItemScalarFieldEnum)[keyof typeof FlashcardCollectionItemScalarFieldEnum]


  export const ChatbotSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type ChatbotSessionScalarFieldEnum = (typeof ChatbotSessionScalarFieldEnum)[keyof typeof ChatbotSessionScalarFieldEnum]


  export const ChatbotMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    content: 'content',
    role: 'role',
    timestamp: 'timestamp',
    referencedContent: 'referencedContent',
    courseId: 'courseId',
    moduleId: 'moduleId',
    model: 'model',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens'
  };

  export type ChatbotMessageScalarFieldEnum = (typeof ChatbotMessageScalarFieldEnum)[keyof typeof ChatbotMessageScalarFieldEnum]


  export const ChatbotFeedbackScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    rating: 'rating',
    feedback: 'feedback',
    createdAt: 'createdAt'
  };

  export type ChatbotFeedbackScalarFieldEnum = (typeof ChatbotFeedbackScalarFieldEnum)[keyof typeof ChatbotFeedbackScalarFieldEnum]


  export const ChatbotSessionAnalyticsScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    messageCount: 'messageCount',
    userMessageCount: 'userMessageCount',
    aiMessageCount: 'aiMessageCount',
    averageUserMessageLength: 'averageUserMessageLength',
    averageAiResponseLength: 'averageAiResponseLength',
    topicsDiscussed: 'topicsDiscussed'
  };

  export type ChatbotSessionAnalyticsScalarFieldEnum = (typeof ChatbotSessionAnalyticsScalarFieldEnum)[keyof typeof ChatbotSessionAnalyticsScalarFieldEnum]


  export const SavedAnswerScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isPublic: 'isPublic',
    userId: 'userId',
    courseId: 'courseId'
  };

  export type SavedAnswerScalarFieldEnum = (typeof SavedAnswerScalarFieldEnum)[keyof typeof SavedAnswerScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    icon: 'icon'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const UserSkillScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skillId: 'skillId',
    proficiencyLevel: 'proficiencyLevel',
    acquiredDate: 'acquiredDate'
  };

  export type UserSkillScalarFieldEnum = (typeof UserSkillScalarFieldEnum)[keyof typeof UserSkillScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    overview: 'overview',
    thumbnail: 'thumbnail',
    coverImage: 'coverImage',
    type: 'type',
    difficulty: 'difficulty',
    instructorId: 'instructorId',
    durationHours: 'durationHours',
    isFeatured: 'isFeatured',
    isPublished: 'isPublished',
    startDate: 'startDate',
    endDate: 'endDate',
    enrollmentLimit: 'enrollmentLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseTagsScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    name: 'name'
  };

  export type CourseTagsScalarFieldEnum = (typeof CourseTagsScalarFieldEnum)[keyof typeof CourseTagsScalarFieldEnum]


  export const LearningOutcomeScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    description: 'description',
    orderNumber: 'orderNumber'
  };

  export type LearningOutcomeScalarFieldEnum = (typeof LearningOutcomeScalarFieldEnum)[keyof typeof LearningOutcomeScalarFieldEnum]


  export const CourseRequirementScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    description: 'description',
    orderNumber: 'orderNumber'
  };

  export type CourseRequirementScalarFieldEnum = (typeof CourseRequirementScalarFieldEnum)[keyof typeof CourseRequirementScalarFieldEnum]


  export const CourseModuleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    orderNumber: 'orderNumber',
    isPublished: 'isPublished',
    estimatedHours: 'estimatedHours',
    unlockCondition: 'unlockCondition',
    thumbnail: 'thumbnail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseModuleScalarFieldEnum = (typeof CourseModuleScalarFieldEnum)[keyof typeof CourseModuleScalarFieldEnum]


  export const ContentUnitScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    title: 'title',
    description: 'description',
    contentType: 'contentType',
    orderNumber: 'orderNumber',
    estimatedMinutes: 'estimatedMinutes',
    isRequired: 'isRequired',
    textContent: 'textContent',
    videoUrl: 'videoUrl',
    audioUrl: 'audioUrl',
    fileUrl: 'fileUrl',
    externalUrl: 'externalUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentUnitScalarFieldEnum = (typeof ContentUnitScalarFieldEnum)[keyof typeof ContentUnitScalarFieldEnum]


  export const UnitAttachmentScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    fileType: 'fileType'
  };

  export type UnitAttachmentScalarFieldEnum = (typeof UnitAttachmentScalarFieldEnum)[keyof typeof UnitAttachmentScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    enrollmentDate: 'enrollmentDate',
    status: 'status',
    completionDate: 'completionDate',
    progressPercentage: 'progressPercentage',
    lastAccessedAt: 'lastAccessedAt',
    unenrollmentDate: 'unenrollmentDate',
    unenrollmentReason: 'unenrollmentReason'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const ModuleProgressScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    moduleId: 'moduleId',
    userId: 'userId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    progressPercentage: 'progressPercentage'
  };

  export type ModuleProgressScalarFieldEnum = (typeof ModuleProgressScalarFieldEnum)[keyof typeof ModuleProgressScalarFieldEnum]


  export const UnitProgressScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    unitId: 'unitId',
    userId: 'userId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    timeSpentMinutes: 'timeSpentMinutes',
    lastPosition: 'lastPosition'
  };

  export type UnitProgressScalarFieldEnum = (typeof UnitProgressScalarFieldEnum)[keyof typeof UnitProgressScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    title: 'title',
    description: 'description',
    timeLimit: 'timeLimit',
    passingScore: 'passingScore',
    allowRetakes: 'allowRetakes',
    maxAttempts: 'maxAttempts',
    randomizeQuestions: 'randomizeQuestions',
    showCorrectAnswers: 'showCorrectAnswers',
    orderNumber: 'orderNumber',
    isPublished: 'isPublished'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    questionText: 'questionText',
    questionType: 'questionType',
    points: 'points',
    orderNumber: 'orderNumber',
    options: 'options',
    correctAnswer: 'correctAnswer',
    explanation: 'explanation'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    quizId: 'quizId',
    userId: 'userId',
    startedAt: 'startedAt',
    submittedAt: 'submittedAt',
    score: 'score',
    percentage: 'percentage',
    passed: 'passed',
    attemptNumber: 'attemptNumber'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const QuestionAnswerScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    questionId: 'questionId',
    userAnswer: 'userAnswer',
    isCorrect: 'isCorrect',
    pointsAwarded: 'pointsAwarded'
  };

  export type QuestionAnswerScalarFieldEnum = (typeof QuestionAnswerScalarFieldEnum)[keyof typeof QuestionAnswerScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    title: 'title',
    description: 'description',
    instructions: 'instructions',
    exerciseType: 'exerciseType',
    orderNumber: 'orderNumber',
    dueDate: 'dueDate',
    allowLateSubmissions: 'allowLateSubmissions',
    maxScore: 'maxScore'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const ExerciseSubmissionScalarFieldEnum: {
    id: 'id',
    exerciseId: 'exerciseId',
    enrollmentId: 'enrollmentId',
    userId: 'userId',
    submittedAt: 'submittedAt',
    content: 'content',
    fileUrl: 'fileUrl',
    score: 'score',
    feedback: 'feedback',
    gradedAt: 'gradedAt',
    gradedBy: 'gradedBy'
  };

  export type ExerciseSubmissionScalarFieldEnum = (typeof ExerciseSubmissionScalarFieldEnum)[keyof typeof ExerciseSubmissionScalarFieldEnum]


  export const CourseReviewScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isPublished: 'isPublished'
  };

  export type CourseReviewScalarFieldEnum = (typeof CourseReviewScalarFieldEnum)[keyof typeof CourseReviewScalarFieldEnum]


  export const MentorshipProgramScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    maxMentees: 'maxMentees',
    isActive: 'isActive'
  };

  export type MentorshipProgramScalarFieldEnum = (typeof MentorshipProgramScalarFieldEnum)[keyof typeof MentorshipProgramScalarFieldEnum]


  export const MentorshipScalarFieldEnum: {
    id: 'id',
    mentorId: 'mentorId',
    menteeId: 'menteeId',
    programId: 'programId',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status'
  };

  export type MentorshipScalarFieldEnum = (typeof MentorshipScalarFieldEnum)[keyof typeof MentorshipScalarFieldEnum]


  export const MentorshipSessionScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    sessionDate: 'sessionDate',
    durationMinutes: 'durationMinutes',
    notes: 'notes',
    status: 'status',
    feedback: 'feedback'
  };

  export type MentorshipSessionScalarFieldEnum = (typeof MentorshipSessionScalarFieldEnum)[keyof typeof MentorshipSessionScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    eventDate: 'eventDate',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    virtualLink: 'virtualLink',
    isVirtual: 'isVirtual',
    maxParticipants: 'maxParticipants',
    thumbnail: 'thumbnail',
    registrationDeadline: 'registrationDeadline'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventRegistrationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    registrationDate: 'registrationDate',
    attendanceConfirmed: 'attendanceConfirmed'
  };

  export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    thumbnail: 'thumbnail',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    isPrivate: 'isPrivate'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const CommunityMemberScalarFieldEnum: {
    id: 'id',
    communityId: 'communityId',
    userId: 'userId',
    joinedDate: 'joinedDate',
    role: 'role'
  };

  export type CommunityMemberScalarFieldEnum = (typeof CommunityMemberScalarFieldEnum)[keyof typeof CommunityMemberScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    communityId: 'communityId',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    creatorId: 'creatorId',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    githubUrl: 'githubUrl',
    demoUrl: 'demoUrl',
    thumbnail: 'thumbnail'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinedDate: 'joinedDate'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const SponsorScalarFieldEnum: {
    id: 'id',
    organizationName: 'organizationName',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    website: 'website',
    logo: 'logo',
    description: 'description',
    partnershipStart: 'partnershipStart'
  };

  export type SponsorScalarFieldEnum = (typeof SponsorScalarFieldEnum)[keyof typeof SponsorScalarFieldEnum]


  export const SponsorshipScalarFieldEnum: {
    id: 'id',
    sponsorId: 'sponsorId',
    title: 'title',
    description: 'description',
    amount: 'amount',
    type: 'type',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type SponsorshipScalarFieldEnum = (typeof SponsorshipScalarFieldEnum)[keyof typeof SponsorshipScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    badgeImage: 'badgeImage',
    points: 'points',
    category: 'category'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    earnedDate: 'earnedDate'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    type: 'type',
    actionUrl: 'actionUrl'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    type: 'type',
    uploaderId: 'uploaderId',
    uploadDate: 'uploadDate',
    isApproved: 'isApproved'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const AssessmentScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    totalPoints: 'totalPoints',
    passingPoints: 'passingPoints',
    createdAt: 'createdAt'
  };

  export type AssessmentScalarFieldEnum = (typeof AssessmentScalarFieldEnum)[keyof typeof AssessmentScalarFieldEnum]


  export const AssessmentQuestionScalarFieldEnum: {
    id: 'id',
    assessmentId: 'assessmentId',
    question: 'question',
    questionType: 'questionType',
    points: 'points',
    orderNumber: 'orderNumber',
    options: 'options',
    correctAnswer: 'correctAnswer'
  };

  export type AssessmentQuestionScalarFieldEnum = (typeof AssessmentQuestionScalarFieldEnum)[keyof typeof AssessmentQuestionScalarFieldEnum]


  export const UserAssessmentAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assessmentId: 'assessmentId',
    score: 'score',
    passed: 'passed',
    attemptDate: 'attemptDate',
    attemptNumber: 'attemptNumber',
    answers: 'answers'
  };

  export type UserAssessmentAttemptScalarFieldEnum = (typeof UserAssessmentAttemptScalarFieldEnum)[keyof typeof UserAssessmentAttemptScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    targetId: 'targetId',
    targetType: 'targetType',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const SubscriberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriberScalarFieldEnum = (typeof SubscriberScalarFieldEnum)[keyof typeof SubscriberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MessageRole'
   */
  export type EnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole'>
    


  /**
   * Reference to a field of type 'MessageRole[]'
   */
  export type ListEnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole[]'>
    


  /**
   * Reference to a field of type 'CourseType'
   */
  export type EnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType'>
    


  /**
   * Reference to a field of type 'CourseType[]'
   */
  export type ListEnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType[]'>
    


  /**
   * Reference to a field of type 'DifficultyLevel'
   */
  export type EnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel'>
    


  /**
   * Reference to a field of type 'DifficultyLevel[]'
   */
  export type ListEnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'EnrollmentStatus'
   */
  export type EnumEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatus'>
    


  /**
   * Reference to a field of type 'EnrollmentStatus[]'
   */
  export type ListEnumEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ExerciseType'
   */
  export type EnumExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseType'>
    


  /**
   * Reference to a field of type 'ExerciseType[]'
   */
  export type ListEnumExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseType[]'>
    


  /**
   * Reference to a field of type 'StatusType'
   */
  export type EnumStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusType'>
    


  /**
   * Reference to a field of type 'StatusType[]'
   */
  export type ListEnumStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusType[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'CommunityRole'
   */
  export type EnumCommunityRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunityRole'>
    


  /**
   * Reference to a field of type 'CommunityRole[]'
   */
  export type ListEnumCommunityRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunityRole[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectRole'
   */
  export type EnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole'>
    


  /**
   * Reference to a field of type 'ProjectRole[]'
   */
  export type ListEnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'SponsorshipType'
   */
  export type EnumSponsorshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SponsorshipType'>
    


  /**
   * Reference to a field of type 'SponsorshipType[]'
   */
  export type ListEnumSponsorshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SponsorshipType[]'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementCategory[]'
   */
  export type ListEnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'FeedbackTarget'
   */
  export type EnumFeedbackTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackTarget'>
    


  /**
   * Reference to a field of type 'FeedbackTarget[]'
   */
  export type ListEnumFeedbackTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackTarget[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    age?: IntNullableFilter<"User"> | number | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActive?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reviews?: CourseReviewListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    userSkills?: UserSkillListRelationFilter
    menteeRelationships?: MentorshipListRelationFilter
    mentorRelationships?: MentorshipListRelationFilter
    instructedCourses?: CourseListRelationFilter
    eventRegistrations?: EventRegistrationListRelationFilter
    createdCommunities?: CommunityListRelationFilter
    communityMemberships?: CommunityMemberListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    createdProjects?: ProjectListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    achievements?: UserAchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    uploadedResources?: ResourceListRelationFilter
    assessmentAttempts?: UserAssessmentAttemptListRelationFilter
    providedFeedback?: FeedbackListRelationFilter
    userInteractions?: FlashcardInteractionListRelationFilter
    flashcards?: FlashcardListRelationFilter
    flashcardCollections?: FlashcardCollectionListRelationFilter
    chatbotSessions?: ChatbotSessionListRelationFilter
    chatbotFeedback?: ChatbotFeedbackListRelationFilter
    savedAnswers?: SavedAnswerListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationExpires?: SortOrderInput | SortOrder
    lastActive?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviews?: CourseReviewOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    userSkills?: UserSkillOrderByRelationAggregateInput
    menteeRelationships?: MentorshipOrderByRelationAggregateInput
    mentorRelationships?: MentorshipOrderByRelationAggregateInput
    instructedCourses?: CourseOrderByRelationAggregateInput
    eventRegistrations?: EventRegistrationOrderByRelationAggregateInput
    createdCommunities?: CommunityOrderByRelationAggregateInput
    communityMemberships?: CommunityMemberOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    createdProjects?: ProjectOrderByRelationAggregateInput
    projectMemberships?: ProjectMemberOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    uploadedResources?: ResourceOrderByRelationAggregateInput
    assessmentAttempts?: UserAssessmentAttemptOrderByRelationAggregateInput
    providedFeedback?: FeedbackOrderByRelationAggregateInput
    userInteractions?: FlashcardInteractionOrderByRelationAggregateInput
    flashcards?: FlashcardOrderByRelationAggregateInput
    flashcardCollections?: FlashcardCollectionOrderByRelationAggregateInput
    chatbotSessions?: ChatbotSessionOrderByRelationAggregateInput
    chatbotFeedback?: ChatbotFeedbackOrderByRelationAggregateInput
    savedAnswers?: SavedAnswerOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    verificationToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    age?: IntNullableFilter<"User"> | number | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    verificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActive?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reviews?: CourseReviewListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    userSkills?: UserSkillListRelationFilter
    menteeRelationships?: MentorshipListRelationFilter
    mentorRelationships?: MentorshipListRelationFilter
    instructedCourses?: CourseListRelationFilter
    eventRegistrations?: EventRegistrationListRelationFilter
    createdCommunities?: CommunityListRelationFilter
    communityMemberships?: CommunityMemberListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    createdProjects?: ProjectListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    achievements?: UserAchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    uploadedResources?: ResourceListRelationFilter
    assessmentAttempts?: UserAssessmentAttemptListRelationFilter
    providedFeedback?: FeedbackListRelationFilter
    userInteractions?: FlashcardInteractionListRelationFilter
    flashcards?: FlashcardListRelationFilter
    flashcardCollections?: FlashcardCollectionListRelationFilter
    chatbotSessions?: ChatbotSessionListRelationFilter
    chatbotFeedback?: ChatbotFeedbackListRelationFilter
    savedAnswers?: SavedAnswerListRelationFilter
  }, "id" | "email" | "verificationToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationExpires?: SortOrderInput | SortOrder
    lastActive?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastActive?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type FlashcardWhereInput = {
    AND?: FlashcardWhereInput | FlashcardWhereInput[]
    OR?: FlashcardWhereInput[]
    NOT?: FlashcardWhereInput | FlashcardWhereInput[]
    id?: IntFilter<"Flashcard"> | number
    userId?: IntFilter<"Flashcard"> | number
    courseId?: IntNullableFilter<"Flashcard"> | number | null
    moduleId?: IntNullableFilter<"Flashcard"> | number | null
    question?: StringFilter<"Flashcard"> | string
    answer?: StringFilter<"Flashcard"> | string
    difficultyLevel?: IntFilter<"Flashcard"> | number
    tags?: StringNullableFilter<"Flashcard"> | string | null
    aiGenerated?: BoolFilter<"Flashcard"> | boolean
    createdAt?: DateTimeFilter<"Flashcard"> | Date | string
    lastReviewed?: DateTimeNullableFilter<"Flashcard"> | Date | string | null
    timesReviewed?: IntFilter<"Flashcard"> | number
    confidenceLevel?: IntNullableFilter<"Flashcard"> | number | null
    aiModel?: StringNullableFilter<"Flashcard"> | string | null
    generationPrompt?: StringNullableFilter<"Flashcard"> | string | null
    sourceContentSnippet?: StringNullableFilter<"Flashcard"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<CourseModuleNullableScalarRelationFilter, CourseModuleWhereInput> | null
    userInteractions?: FlashcardInteractionListRelationFilter
    collections?: FlashcardCollectionItemListRelationFilter
  }

  export type FlashcardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    question?: SortOrder
    answer?: SortOrder
    difficultyLevel?: SortOrder
    tags?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    lastReviewed?: SortOrderInput | SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    generationPrompt?: SortOrderInput | SortOrder
    sourceContentSnippet?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    module?: CourseModuleOrderByWithRelationInput
    userInteractions?: FlashcardInteractionOrderByRelationAggregateInput
    collections?: FlashcardCollectionItemOrderByRelationAggregateInput
  }

  export type FlashcardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FlashcardWhereInput | FlashcardWhereInput[]
    OR?: FlashcardWhereInput[]
    NOT?: FlashcardWhereInput | FlashcardWhereInput[]
    userId?: IntFilter<"Flashcard"> | number
    courseId?: IntNullableFilter<"Flashcard"> | number | null
    moduleId?: IntNullableFilter<"Flashcard"> | number | null
    question?: StringFilter<"Flashcard"> | string
    answer?: StringFilter<"Flashcard"> | string
    difficultyLevel?: IntFilter<"Flashcard"> | number
    tags?: StringNullableFilter<"Flashcard"> | string | null
    aiGenerated?: BoolFilter<"Flashcard"> | boolean
    createdAt?: DateTimeFilter<"Flashcard"> | Date | string
    lastReviewed?: DateTimeNullableFilter<"Flashcard"> | Date | string | null
    timesReviewed?: IntFilter<"Flashcard"> | number
    confidenceLevel?: IntNullableFilter<"Flashcard"> | number | null
    aiModel?: StringNullableFilter<"Flashcard"> | string | null
    generationPrompt?: StringNullableFilter<"Flashcard"> | string | null
    sourceContentSnippet?: StringNullableFilter<"Flashcard"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<CourseModuleNullableScalarRelationFilter, CourseModuleWhereInput> | null
    userInteractions?: FlashcardInteractionListRelationFilter
    collections?: FlashcardCollectionItemListRelationFilter
  }, "id">

  export type FlashcardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    question?: SortOrder
    answer?: SortOrder
    difficultyLevel?: SortOrder
    tags?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    lastReviewed?: SortOrderInput | SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    generationPrompt?: SortOrderInput | SortOrder
    sourceContentSnippet?: SortOrderInput | SortOrder
    _count?: FlashcardCountOrderByAggregateInput
    _avg?: FlashcardAvgOrderByAggregateInput
    _max?: FlashcardMaxOrderByAggregateInput
    _min?: FlashcardMinOrderByAggregateInput
    _sum?: FlashcardSumOrderByAggregateInput
  }

  export type FlashcardScalarWhereWithAggregatesInput = {
    AND?: FlashcardScalarWhereWithAggregatesInput | FlashcardScalarWhereWithAggregatesInput[]
    OR?: FlashcardScalarWhereWithAggregatesInput[]
    NOT?: FlashcardScalarWhereWithAggregatesInput | FlashcardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Flashcard"> | number
    userId?: IntWithAggregatesFilter<"Flashcard"> | number
    courseId?: IntNullableWithAggregatesFilter<"Flashcard"> | number | null
    moduleId?: IntNullableWithAggregatesFilter<"Flashcard"> | number | null
    question?: StringWithAggregatesFilter<"Flashcard"> | string
    answer?: StringWithAggregatesFilter<"Flashcard"> | string
    difficultyLevel?: IntWithAggregatesFilter<"Flashcard"> | number
    tags?: StringNullableWithAggregatesFilter<"Flashcard"> | string | null
    aiGenerated?: BoolWithAggregatesFilter<"Flashcard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Flashcard"> | Date | string
    lastReviewed?: DateTimeNullableWithAggregatesFilter<"Flashcard"> | Date | string | null
    timesReviewed?: IntWithAggregatesFilter<"Flashcard"> | number
    confidenceLevel?: IntNullableWithAggregatesFilter<"Flashcard"> | number | null
    aiModel?: StringNullableWithAggregatesFilter<"Flashcard"> | string | null
    generationPrompt?: StringNullableWithAggregatesFilter<"Flashcard"> | string | null
    sourceContentSnippet?: StringNullableWithAggregatesFilter<"Flashcard"> | string | null
  }

  export type FlashcardInteractionWhereInput = {
    AND?: FlashcardInteractionWhereInput | FlashcardInteractionWhereInput[]
    OR?: FlashcardInteractionWhereInput[]
    NOT?: FlashcardInteractionWhereInput | FlashcardInteractionWhereInput[]
    id?: IntFilter<"FlashcardInteraction"> | number
    flashcardId?: IntFilter<"FlashcardInteraction"> | number
    userId?: IntFilter<"FlashcardInteraction"> | number
    correct?: BoolFilter<"FlashcardInteraction"> | boolean
    responseTime?: IntNullableFilter<"FlashcardInteraction"> | number | null
    interactionDate?: DateTimeFilter<"FlashcardInteraction"> | Date | string
    flashcard?: XOR<FlashcardScalarRelationFilter, FlashcardWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FlashcardInteractionOrderByWithRelationInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    correct?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    interactionDate?: SortOrder
    flashcard?: FlashcardOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FlashcardInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FlashcardInteractionWhereInput | FlashcardInteractionWhereInput[]
    OR?: FlashcardInteractionWhereInput[]
    NOT?: FlashcardInteractionWhereInput | FlashcardInteractionWhereInput[]
    flashcardId?: IntFilter<"FlashcardInteraction"> | number
    userId?: IntFilter<"FlashcardInteraction"> | number
    correct?: BoolFilter<"FlashcardInteraction"> | boolean
    responseTime?: IntNullableFilter<"FlashcardInteraction"> | number | null
    interactionDate?: DateTimeFilter<"FlashcardInteraction"> | Date | string
    flashcard?: XOR<FlashcardScalarRelationFilter, FlashcardWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FlashcardInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    correct?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    interactionDate?: SortOrder
    _count?: FlashcardInteractionCountOrderByAggregateInput
    _avg?: FlashcardInteractionAvgOrderByAggregateInput
    _max?: FlashcardInteractionMaxOrderByAggregateInput
    _min?: FlashcardInteractionMinOrderByAggregateInput
    _sum?: FlashcardInteractionSumOrderByAggregateInput
  }

  export type FlashcardInteractionScalarWhereWithAggregatesInput = {
    AND?: FlashcardInteractionScalarWhereWithAggregatesInput | FlashcardInteractionScalarWhereWithAggregatesInput[]
    OR?: FlashcardInteractionScalarWhereWithAggregatesInput[]
    NOT?: FlashcardInteractionScalarWhereWithAggregatesInput | FlashcardInteractionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FlashcardInteraction"> | number
    flashcardId?: IntWithAggregatesFilter<"FlashcardInteraction"> | number
    userId?: IntWithAggregatesFilter<"FlashcardInteraction"> | number
    correct?: BoolWithAggregatesFilter<"FlashcardInteraction"> | boolean
    responseTime?: IntNullableWithAggregatesFilter<"FlashcardInteraction"> | number | null
    interactionDate?: DateTimeWithAggregatesFilter<"FlashcardInteraction"> | Date | string
  }

  export type FlashcardCollectionWhereInput = {
    AND?: FlashcardCollectionWhereInput | FlashcardCollectionWhereInput[]
    OR?: FlashcardCollectionWhereInput[]
    NOT?: FlashcardCollectionWhereInput | FlashcardCollectionWhereInput[]
    id?: IntFilter<"FlashcardCollection"> | number
    name?: StringFilter<"FlashcardCollection"> | string
    description?: StringNullableFilter<"FlashcardCollection"> | string | null
    userId?: IntFilter<"FlashcardCollection"> | number
    createdAt?: DateTimeFilter<"FlashcardCollection"> | Date | string
    isPublic?: BoolFilter<"FlashcardCollection"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cards?: FlashcardCollectionItemListRelationFilter
  }

  export type FlashcardCollectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    isPublic?: SortOrder
    user?: UserOrderByWithRelationInput
    cards?: FlashcardCollectionItemOrderByRelationAggregateInput
  }

  export type FlashcardCollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FlashcardCollectionWhereInput | FlashcardCollectionWhereInput[]
    OR?: FlashcardCollectionWhereInput[]
    NOT?: FlashcardCollectionWhereInput | FlashcardCollectionWhereInput[]
    name?: StringFilter<"FlashcardCollection"> | string
    description?: StringNullableFilter<"FlashcardCollection"> | string | null
    userId?: IntFilter<"FlashcardCollection"> | number
    createdAt?: DateTimeFilter<"FlashcardCollection"> | Date | string
    isPublic?: BoolFilter<"FlashcardCollection"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cards?: FlashcardCollectionItemListRelationFilter
  }, "id">

  export type FlashcardCollectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    isPublic?: SortOrder
    _count?: FlashcardCollectionCountOrderByAggregateInput
    _avg?: FlashcardCollectionAvgOrderByAggregateInput
    _max?: FlashcardCollectionMaxOrderByAggregateInput
    _min?: FlashcardCollectionMinOrderByAggregateInput
    _sum?: FlashcardCollectionSumOrderByAggregateInput
  }

  export type FlashcardCollectionScalarWhereWithAggregatesInput = {
    AND?: FlashcardCollectionScalarWhereWithAggregatesInput | FlashcardCollectionScalarWhereWithAggregatesInput[]
    OR?: FlashcardCollectionScalarWhereWithAggregatesInput[]
    NOT?: FlashcardCollectionScalarWhereWithAggregatesInput | FlashcardCollectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FlashcardCollection"> | number
    name?: StringWithAggregatesFilter<"FlashcardCollection"> | string
    description?: StringNullableWithAggregatesFilter<"FlashcardCollection"> | string | null
    userId?: IntWithAggregatesFilter<"FlashcardCollection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FlashcardCollection"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"FlashcardCollection"> | boolean
  }

  export type FlashcardCollectionItemWhereInput = {
    AND?: FlashcardCollectionItemWhereInput | FlashcardCollectionItemWhereInput[]
    OR?: FlashcardCollectionItemWhereInput[]
    NOT?: FlashcardCollectionItemWhereInput | FlashcardCollectionItemWhereInput[]
    id?: IntFilter<"FlashcardCollectionItem"> | number
    collectionId?: IntFilter<"FlashcardCollectionItem"> | number
    flashcardId?: IntFilter<"FlashcardCollectionItem"> | number
    addedAt?: DateTimeFilter<"FlashcardCollectionItem"> | Date | string
    collection?: XOR<FlashcardCollectionScalarRelationFilter, FlashcardCollectionWhereInput>
    flashcard?: XOR<FlashcardScalarRelationFilter, FlashcardWhereInput>
  }

  export type FlashcardCollectionItemOrderByWithRelationInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
    addedAt?: SortOrder
    collection?: FlashcardCollectionOrderByWithRelationInput
    flashcard?: FlashcardOrderByWithRelationInput
  }

  export type FlashcardCollectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    collectionId_flashcardId?: FlashcardCollectionItemCollectionIdFlashcardIdCompoundUniqueInput
    AND?: FlashcardCollectionItemWhereInput | FlashcardCollectionItemWhereInput[]
    OR?: FlashcardCollectionItemWhereInput[]
    NOT?: FlashcardCollectionItemWhereInput | FlashcardCollectionItemWhereInput[]
    collectionId?: IntFilter<"FlashcardCollectionItem"> | number
    flashcardId?: IntFilter<"FlashcardCollectionItem"> | number
    addedAt?: DateTimeFilter<"FlashcardCollectionItem"> | Date | string
    collection?: XOR<FlashcardCollectionScalarRelationFilter, FlashcardCollectionWhereInput>
    flashcard?: XOR<FlashcardScalarRelationFilter, FlashcardWhereInput>
  }, "id" | "collectionId_flashcardId">

  export type FlashcardCollectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
    addedAt?: SortOrder
    _count?: FlashcardCollectionItemCountOrderByAggregateInput
    _avg?: FlashcardCollectionItemAvgOrderByAggregateInput
    _max?: FlashcardCollectionItemMaxOrderByAggregateInput
    _min?: FlashcardCollectionItemMinOrderByAggregateInput
    _sum?: FlashcardCollectionItemSumOrderByAggregateInput
  }

  export type FlashcardCollectionItemScalarWhereWithAggregatesInput = {
    AND?: FlashcardCollectionItemScalarWhereWithAggregatesInput | FlashcardCollectionItemScalarWhereWithAggregatesInput[]
    OR?: FlashcardCollectionItemScalarWhereWithAggregatesInput[]
    NOT?: FlashcardCollectionItemScalarWhereWithAggregatesInput | FlashcardCollectionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FlashcardCollectionItem"> | number
    collectionId?: IntWithAggregatesFilter<"FlashcardCollectionItem"> | number
    flashcardId?: IntWithAggregatesFilter<"FlashcardCollectionItem"> | number
    addedAt?: DateTimeWithAggregatesFilter<"FlashcardCollectionItem"> | Date | string
  }

  export type ChatbotSessionWhereInput = {
    AND?: ChatbotSessionWhereInput | ChatbotSessionWhereInput[]
    OR?: ChatbotSessionWhereInput[]
    NOT?: ChatbotSessionWhereInput | ChatbotSessionWhereInput[]
    id?: IntFilter<"ChatbotSession"> | number
    userId?: IntFilter<"ChatbotSession"> | number
    title?: StringNullableFilter<"ChatbotSession"> | string | null
    createdAt?: DateTimeFilter<"ChatbotSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatbotSession"> | Date | string
    isActive?: BoolFilter<"ChatbotSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatbotMessageListRelationFilter
    analytics?: XOR<ChatbotSessionAnalyticsNullableScalarRelationFilter, ChatbotSessionAnalyticsWhereInput> | null
  }

  export type ChatbotSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: ChatbotMessageOrderByRelationAggregateInput
    analytics?: ChatbotSessionAnalyticsOrderByWithRelationInput
  }

  export type ChatbotSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatbotSessionWhereInput | ChatbotSessionWhereInput[]
    OR?: ChatbotSessionWhereInput[]
    NOT?: ChatbotSessionWhereInput | ChatbotSessionWhereInput[]
    userId?: IntFilter<"ChatbotSession"> | number
    title?: StringNullableFilter<"ChatbotSession"> | string | null
    createdAt?: DateTimeFilter<"ChatbotSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatbotSession"> | Date | string
    isActive?: BoolFilter<"ChatbotSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatbotMessageListRelationFilter
    analytics?: XOR<ChatbotSessionAnalyticsNullableScalarRelationFilter, ChatbotSessionAnalyticsWhereInput> | null
  }, "id">

  export type ChatbotSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: ChatbotSessionCountOrderByAggregateInput
    _avg?: ChatbotSessionAvgOrderByAggregateInput
    _max?: ChatbotSessionMaxOrderByAggregateInput
    _min?: ChatbotSessionMinOrderByAggregateInput
    _sum?: ChatbotSessionSumOrderByAggregateInput
  }

  export type ChatbotSessionScalarWhereWithAggregatesInput = {
    AND?: ChatbotSessionScalarWhereWithAggregatesInput | ChatbotSessionScalarWhereWithAggregatesInput[]
    OR?: ChatbotSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatbotSessionScalarWhereWithAggregatesInput | ChatbotSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatbotSession"> | number
    userId?: IntWithAggregatesFilter<"ChatbotSession"> | number
    title?: StringNullableWithAggregatesFilter<"ChatbotSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatbotSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatbotSession"> | Date | string
    isActive?: BoolWithAggregatesFilter<"ChatbotSession"> | boolean
  }

  export type ChatbotMessageWhereInput = {
    AND?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    OR?: ChatbotMessageWhereInput[]
    NOT?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    id?: IntFilter<"ChatbotMessage"> | number
    sessionId?: IntFilter<"ChatbotMessage"> | number
    content?: StringFilter<"ChatbotMessage"> | string
    role?: EnumMessageRoleFilter<"ChatbotMessage"> | $Enums.MessageRole
    timestamp?: DateTimeFilter<"ChatbotMessage"> | Date | string
    referencedContent?: StringNullableFilter<"ChatbotMessage"> | string | null
    courseId?: IntNullableFilter<"ChatbotMessage"> | number | null
    moduleId?: IntNullableFilter<"ChatbotMessage"> | number | null
    model?: StringNullableFilter<"ChatbotMessage"> | string | null
    promptTokens?: IntNullableFilter<"ChatbotMessage"> | number | null
    completionTokens?: IntNullableFilter<"ChatbotMessage"> | number | null
    session?: XOR<ChatbotSessionScalarRelationFilter, ChatbotSessionWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<CourseModuleNullableScalarRelationFilter, CourseModuleWhereInput> | null
    feedback?: XOR<ChatbotFeedbackNullableScalarRelationFilter, ChatbotFeedbackWhereInput> | null
  }

  export type ChatbotMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    referencedContent?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    promptTokens?: SortOrderInput | SortOrder
    completionTokens?: SortOrderInput | SortOrder
    session?: ChatbotSessionOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    module?: CourseModuleOrderByWithRelationInput
    feedback?: ChatbotFeedbackOrderByWithRelationInput
  }

  export type ChatbotMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    OR?: ChatbotMessageWhereInput[]
    NOT?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    sessionId?: IntFilter<"ChatbotMessage"> | number
    content?: StringFilter<"ChatbotMessage"> | string
    role?: EnumMessageRoleFilter<"ChatbotMessage"> | $Enums.MessageRole
    timestamp?: DateTimeFilter<"ChatbotMessage"> | Date | string
    referencedContent?: StringNullableFilter<"ChatbotMessage"> | string | null
    courseId?: IntNullableFilter<"ChatbotMessage"> | number | null
    moduleId?: IntNullableFilter<"ChatbotMessage"> | number | null
    model?: StringNullableFilter<"ChatbotMessage"> | string | null
    promptTokens?: IntNullableFilter<"ChatbotMessage"> | number | null
    completionTokens?: IntNullableFilter<"ChatbotMessage"> | number | null
    session?: XOR<ChatbotSessionScalarRelationFilter, ChatbotSessionWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<CourseModuleNullableScalarRelationFilter, CourseModuleWhereInput> | null
    feedback?: XOR<ChatbotFeedbackNullableScalarRelationFilter, ChatbotFeedbackWhereInput> | null
  }, "id">

  export type ChatbotMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    referencedContent?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    promptTokens?: SortOrderInput | SortOrder
    completionTokens?: SortOrderInput | SortOrder
    _count?: ChatbotMessageCountOrderByAggregateInput
    _avg?: ChatbotMessageAvgOrderByAggregateInput
    _max?: ChatbotMessageMaxOrderByAggregateInput
    _min?: ChatbotMessageMinOrderByAggregateInput
    _sum?: ChatbotMessageSumOrderByAggregateInput
  }

  export type ChatbotMessageScalarWhereWithAggregatesInput = {
    AND?: ChatbotMessageScalarWhereWithAggregatesInput | ChatbotMessageScalarWhereWithAggregatesInput[]
    OR?: ChatbotMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatbotMessageScalarWhereWithAggregatesInput | ChatbotMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatbotMessage"> | number
    sessionId?: IntWithAggregatesFilter<"ChatbotMessage"> | number
    content?: StringWithAggregatesFilter<"ChatbotMessage"> | string
    role?: EnumMessageRoleWithAggregatesFilter<"ChatbotMessage"> | $Enums.MessageRole
    timestamp?: DateTimeWithAggregatesFilter<"ChatbotMessage"> | Date | string
    referencedContent?: StringNullableWithAggregatesFilter<"ChatbotMessage"> | string | null
    courseId?: IntNullableWithAggregatesFilter<"ChatbotMessage"> | number | null
    moduleId?: IntNullableWithAggregatesFilter<"ChatbotMessage"> | number | null
    model?: StringNullableWithAggregatesFilter<"ChatbotMessage"> | string | null
    promptTokens?: IntNullableWithAggregatesFilter<"ChatbotMessage"> | number | null
    completionTokens?: IntNullableWithAggregatesFilter<"ChatbotMessage"> | number | null
  }

  export type ChatbotFeedbackWhereInput = {
    AND?: ChatbotFeedbackWhereInput | ChatbotFeedbackWhereInput[]
    OR?: ChatbotFeedbackWhereInput[]
    NOT?: ChatbotFeedbackWhereInput | ChatbotFeedbackWhereInput[]
    id?: IntFilter<"ChatbotFeedback"> | number
    messageId?: IntFilter<"ChatbotFeedback"> | number
    userId?: IntFilter<"ChatbotFeedback"> | number
    rating?: IntNullableFilter<"ChatbotFeedback"> | number | null
    feedback?: StringNullableFilter<"ChatbotFeedback"> | string | null
    createdAt?: DateTimeFilter<"ChatbotFeedback"> | Date | string
    message?: XOR<ChatbotMessageScalarRelationFilter, ChatbotMessageWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatbotFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    message?: ChatbotMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatbotFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    messageId?: number
    AND?: ChatbotFeedbackWhereInput | ChatbotFeedbackWhereInput[]
    OR?: ChatbotFeedbackWhereInput[]
    NOT?: ChatbotFeedbackWhereInput | ChatbotFeedbackWhereInput[]
    userId?: IntFilter<"ChatbotFeedback"> | number
    rating?: IntNullableFilter<"ChatbotFeedback"> | number | null
    feedback?: StringNullableFilter<"ChatbotFeedback"> | string | null
    createdAt?: DateTimeFilter<"ChatbotFeedback"> | Date | string
    message?: XOR<ChatbotMessageScalarRelationFilter, ChatbotMessageWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "messageId">

  export type ChatbotFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatbotFeedbackCountOrderByAggregateInput
    _avg?: ChatbotFeedbackAvgOrderByAggregateInput
    _max?: ChatbotFeedbackMaxOrderByAggregateInput
    _min?: ChatbotFeedbackMinOrderByAggregateInput
    _sum?: ChatbotFeedbackSumOrderByAggregateInput
  }

  export type ChatbotFeedbackScalarWhereWithAggregatesInput = {
    AND?: ChatbotFeedbackScalarWhereWithAggregatesInput | ChatbotFeedbackScalarWhereWithAggregatesInput[]
    OR?: ChatbotFeedbackScalarWhereWithAggregatesInput[]
    NOT?: ChatbotFeedbackScalarWhereWithAggregatesInput | ChatbotFeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatbotFeedback"> | number
    messageId?: IntWithAggregatesFilter<"ChatbotFeedback"> | number
    userId?: IntWithAggregatesFilter<"ChatbotFeedback"> | number
    rating?: IntNullableWithAggregatesFilter<"ChatbotFeedback"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"ChatbotFeedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatbotFeedback"> | Date | string
  }

  export type ChatbotSessionAnalyticsWhereInput = {
    AND?: ChatbotSessionAnalyticsWhereInput | ChatbotSessionAnalyticsWhereInput[]
    OR?: ChatbotSessionAnalyticsWhereInput[]
    NOT?: ChatbotSessionAnalyticsWhereInput | ChatbotSessionAnalyticsWhereInput[]
    id?: IntFilter<"ChatbotSessionAnalytics"> | number
    sessionId?: IntFilter<"ChatbotSessionAnalytics"> | number
    messageCount?: IntFilter<"ChatbotSessionAnalytics"> | number
    userMessageCount?: IntFilter<"ChatbotSessionAnalytics"> | number
    aiMessageCount?: IntFilter<"ChatbotSessionAnalytics"> | number
    averageUserMessageLength?: IntNullableFilter<"ChatbotSessionAnalytics"> | number | null
    averageAiResponseLength?: IntNullableFilter<"ChatbotSessionAnalytics"> | number | null
    topicsDiscussed?: StringNullableFilter<"ChatbotSessionAnalytics"> | string | null
    session?: XOR<ChatbotSessionScalarRelationFilter, ChatbotSessionWhereInput>
  }

  export type ChatbotSessionAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrderInput | SortOrder
    averageAiResponseLength?: SortOrderInput | SortOrder
    topicsDiscussed?: SortOrderInput | SortOrder
    session?: ChatbotSessionOrderByWithRelationInput
  }

  export type ChatbotSessionAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId?: number
    AND?: ChatbotSessionAnalyticsWhereInput | ChatbotSessionAnalyticsWhereInput[]
    OR?: ChatbotSessionAnalyticsWhereInput[]
    NOT?: ChatbotSessionAnalyticsWhereInput | ChatbotSessionAnalyticsWhereInput[]
    messageCount?: IntFilter<"ChatbotSessionAnalytics"> | number
    userMessageCount?: IntFilter<"ChatbotSessionAnalytics"> | number
    aiMessageCount?: IntFilter<"ChatbotSessionAnalytics"> | number
    averageUserMessageLength?: IntNullableFilter<"ChatbotSessionAnalytics"> | number | null
    averageAiResponseLength?: IntNullableFilter<"ChatbotSessionAnalytics"> | number | null
    topicsDiscussed?: StringNullableFilter<"ChatbotSessionAnalytics"> | string | null
    session?: XOR<ChatbotSessionScalarRelationFilter, ChatbotSessionWhereInput>
  }, "id" | "sessionId">

  export type ChatbotSessionAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrderInput | SortOrder
    averageAiResponseLength?: SortOrderInput | SortOrder
    topicsDiscussed?: SortOrderInput | SortOrder
    _count?: ChatbotSessionAnalyticsCountOrderByAggregateInput
    _avg?: ChatbotSessionAnalyticsAvgOrderByAggregateInput
    _max?: ChatbotSessionAnalyticsMaxOrderByAggregateInput
    _min?: ChatbotSessionAnalyticsMinOrderByAggregateInput
    _sum?: ChatbotSessionAnalyticsSumOrderByAggregateInput
  }

  export type ChatbotSessionAnalyticsScalarWhereWithAggregatesInput = {
    AND?: ChatbotSessionAnalyticsScalarWhereWithAggregatesInput | ChatbotSessionAnalyticsScalarWhereWithAggregatesInput[]
    OR?: ChatbotSessionAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: ChatbotSessionAnalyticsScalarWhereWithAggregatesInput | ChatbotSessionAnalyticsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatbotSessionAnalytics"> | number
    sessionId?: IntWithAggregatesFilter<"ChatbotSessionAnalytics"> | number
    messageCount?: IntWithAggregatesFilter<"ChatbotSessionAnalytics"> | number
    userMessageCount?: IntWithAggregatesFilter<"ChatbotSessionAnalytics"> | number
    aiMessageCount?: IntWithAggregatesFilter<"ChatbotSessionAnalytics"> | number
    averageUserMessageLength?: IntNullableWithAggregatesFilter<"ChatbotSessionAnalytics"> | number | null
    averageAiResponseLength?: IntNullableWithAggregatesFilter<"ChatbotSessionAnalytics"> | number | null
    topicsDiscussed?: StringNullableWithAggregatesFilter<"ChatbotSessionAnalytics"> | string | null
  }

  export type SavedAnswerWhereInput = {
    AND?: SavedAnswerWhereInput | SavedAnswerWhereInput[]
    OR?: SavedAnswerWhereInput[]
    NOT?: SavedAnswerWhereInput | SavedAnswerWhereInput[]
    id?: IntFilter<"SavedAnswer"> | number
    question?: StringFilter<"SavedAnswer"> | string
    answer?: StringFilter<"SavedAnswer"> | string
    category?: StringNullableFilter<"SavedAnswer"> | string | null
    createdAt?: DateTimeFilter<"SavedAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"SavedAnswer"> | Date | string
    isPublic?: BoolFilter<"SavedAnswer"> | boolean
    userId?: IntNullableFilter<"SavedAnswer"> | number | null
    courseId?: IntNullableFilter<"SavedAnswer"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
  }

  export type SavedAnswerOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type SavedAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SavedAnswerWhereInput | SavedAnswerWhereInput[]
    OR?: SavedAnswerWhereInput[]
    NOT?: SavedAnswerWhereInput | SavedAnswerWhereInput[]
    question?: StringFilter<"SavedAnswer"> | string
    answer?: StringFilter<"SavedAnswer"> | string
    category?: StringNullableFilter<"SavedAnswer"> | string | null
    createdAt?: DateTimeFilter<"SavedAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"SavedAnswer"> | Date | string
    isPublic?: BoolFilter<"SavedAnswer"> | boolean
    userId?: IntNullableFilter<"SavedAnswer"> | number | null
    courseId?: IntNullableFilter<"SavedAnswer"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
  }, "id">

  export type SavedAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: SavedAnswerCountOrderByAggregateInput
    _avg?: SavedAnswerAvgOrderByAggregateInput
    _max?: SavedAnswerMaxOrderByAggregateInput
    _min?: SavedAnswerMinOrderByAggregateInput
    _sum?: SavedAnswerSumOrderByAggregateInput
  }

  export type SavedAnswerScalarWhereWithAggregatesInput = {
    AND?: SavedAnswerScalarWhereWithAggregatesInput | SavedAnswerScalarWhereWithAggregatesInput[]
    OR?: SavedAnswerScalarWhereWithAggregatesInput[]
    NOT?: SavedAnswerScalarWhereWithAggregatesInput | SavedAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SavedAnswer"> | number
    question?: StringWithAggregatesFilter<"SavedAnswer"> | string
    answer?: StringWithAggregatesFilter<"SavedAnswer"> | string
    category?: StringNullableWithAggregatesFilter<"SavedAnswer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SavedAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedAnswer"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"SavedAnswer"> | boolean
    userId?: IntNullableWithAggregatesFilter<"SavedAnswer"> | number | null
    courseId?: IntNullableWithAggregatesFilter<"SavedAnswer"> | number | null
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    category?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    userSkills?: UserSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    userSkills?: UserSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    name?: StringFilter<"Skill"> | string
    category?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    userSkills?: UserSkillListRelationFilter
  }, "id">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skill"> | number
    name?: StringWithAggregatesFilter<"Skill"> | string
    category?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Skill"> | string | null
  }

  export type UserSkillWhereInput = {
    AND?: UserSkillWhereInput | UserSkillWhereInput[]
    OR?: UserSkillWhereInput[]
    NOT?: UserSkillWhereInput | UserSkillWhereInput[]
    id?: IntFilter<"UserSkill"> | number
    userId?: IntFilter<"UserSkill"> | number
    skillId?: IntFilter<"UserSkill"> | number
    proficiencyLevel?: IntFilter<"UserSkill"> | number
    acquiredDate?: DateTimeNullableFilter<"UserSkill"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type UserSkillOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    acquiredDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type UserSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_skillId?: UserSkillUserIdSkillIdCompoundUniqueInput
    AND?: UserSkillWhereInput | UserSkillWhereInput[]
    OR?: UserSkillWhereInput[]
    NOT?: UserSkillWhereInput | UserSkillWhereInput[]
    userId?: IntFilter<"UserSkill"> | number
    skillId?: IntFilter<"UserSkill"> | number
    proficiencyLevel?: IntFilter<"UserSkill"> | number
    acquiredDate?: DateTimeNullableFilter<"UserSkill"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "userId_skillId">

  export type UserSkillOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    acquiredDate?: SortOrderInput | SortOrder
    _count?: UserSkillCountOrderByAggregateInput
    _avg?: UserSkillAvgOrderByAggregateInput
    _max?: UserSkillMaxOrderByAggregateInput
    _min?: UserSkillMinOrderByAggregateInput
    _sum?: UserSkillSumOrderByAggregateInput
  }

  export type UserSkillScalarWhereWithAggregatesInput = {
    AND?: UserSkillScalarWhereWithAggregatesInput | UserSkillScalarWhereWithAggregatesInput[]
    OR?: UserSkillScalarWhereWithAggregatesInput[]
    NOT?: UserSkillScalarWhereWithAggregatesInput | UserSkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSkill"> | number
    userId?: IntWithAggregatesFilter<"UserSkill"> | number
    skillId?: IntWithAggregatesFilter<"UserSkill"> | number
    proficiencyLevel?: IntWithAggregatesFilter<"UserSkill"> | number
    acquiredDate?: DateTimeNullableWithAggregatesFilter<"UserSkill"> | Date | string | null
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    overview?: StringNullableFilter<"Course"> | string | null
    thumbnail?: StringNullableFilter<"Course"> | string | null
    coverImage?: StringNullableFilter<"Course"> | string | null
    type?: EnumCourseTypeFilter<"Course"> | $Enums.CourseType
    difficulty?: EnumDifficultyLevelNullableFilter<"Course"> | $Enums.DifficultyLevel | null
    instructorId?: IntNullableFilter<"Course"> | number | null
    durationHours?: IntNullableFilter<"Course"> | number | null
    isFeatured?: BoolFilter<"Course"> | boolean
    isPublished?: BoolFilter<"Course"> | boolean
    startDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    enrollmentLimit?: IntNullableFilter<"Course"> | number | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    instructor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    modules?: CourseModuleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    learningOutcomes?: LearningOutcomeListRelationFilter
    requirements?: CourseRequirementListRelationFilter
    assessments?: AssessmentListRelationFilter
    flashcards?: FlashcardListRelationFilter
    chatbotMessages?: ChatbotMessageListRelationFilter
    savedAnswers?: SavedAnswerListRelationFilter
    tags?: CourseTagsListRelationFilter
    reviews?: CourseReviewListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    overview?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    type?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    instructorId?: SortOrderInput | SortOrder
    durationHours?: SortOrderInput | SortOrder
    isFeatured?: SortOrder
    isPublished?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    enrollmentLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instructor?: UserOrderByWithRelationInput
    modules?: CourseModuleOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    learningOutcomes?: LearningOutcomeOrderByRelationAggregateInput
    requirements?: CourseRequirementOrderByRelationAggregateInput
    assessments?: AssessmentOrderByRelationAggregateInput
    flashcards?: FlashcardOrderByRelationAggregateInput
    chatbotMessages?: ChatbotMessageOrderByRelationAggregateInput
    savedAnswers?: SavedAnswerOrderByRelationAggregateInput
    tags?: CourseTagsOrderByRelationAggregateInput
    reviews?: CourseReviewOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    overview?: StringNullableFilter<"Course"> | string | null
    thumbnail?: StringNullableFilter<"Course"> | string | null
    coverImage?: StringNullableFilter<"Course"> | string | null
    type?: EnumCourseTypeFilter<"Course"> | $Enums.CourseType
    difficulty?: EnumDifficultyLevelNullableFilter<"Course"> | $Enums.DifficultyLevel | null
    instructorId?: IntNullableFilter<"Course"> | number | null
    durationHours?: IntNullableFilter<"Course"> | number | null
    isFeatured?: BoolFilter<"Course"> | boolean
    isPublished?: BoolFilter<"Course"> | boolean
    startDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    enrollmentLimit?: IntNullableFilter<"Course"> | number | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    instructor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    modules?: CourseModuleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    learningOutcomes?: LearningOutcomeListRelationFilter
    requirements?: CourseRequirementListRelationFilter
    assessments?: AssessmentListRelationFilter
    flashcards?: FlashcardListRelationFilter
    chatbotMessages?: ChatbotMessageListRelationFilter
    savedAnswers?: SavedAnswerListRelationFilter
    tags?: CourseTagsListRelationFilter
    reviews?: CourseReviewListRelationFilter
  }, "id" | "slug">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    overview?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    type?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    instructorId?: SortOrderInput | SortOrder
    durationHours?: SortOrderInput | SortOrder
    isFeatured?: SortOrder
    isPublished?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    enrollmentLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    title?: StringWithAggregatesFilter<"Course"> | string
    slug?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    overview?: StringNullableWithAggregatesFilter<"Course"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"Course"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Course"> | string | null
    type?: EnumCourseTypeWithAggregatesFilter<"Course"> | $Enums.CourseType
    difficulty?: EnumDifficultyLevelNullableWithAggregatesFilter<"Course"> | $Enums.DifficultyLevel | null
    instructorId?: IntNullableWithAggregatesFilter<"Course"> | number | null
    durationHours?: IntNullableWithAggregatesFilter<"Course"> | number | null
    isFeatured?: BoolWithAggregatesFilter<"Course"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Course"> | boolean
    startDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    enrollmentLimit?: IntNullableWithAggregatesFilter<"Course"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseTagsWhereInput = {
    AND?: CourseTagsWhereInput | CourseTagsWhereInput[]
    OR?: CourseTagsWhereInput[]
    NOT?: CourseTagsWhereInput | CourseTagsWhereInput[]
    id?: IntFilter<"CourseTags"> | number
    courseId?: IntFilter<"CourseTags"> | number
    name?: StringFilter<"CourseTags"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseTagsOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type CourseTagsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    courseId_name?: CourseTagsCourseIdNameCompoundUniqueInput
    AND?: CourseTagsWhereInput | CourseTagsWhereInput[]
    OR?: CourseTagsWhereInput[]
    NOT?: CourseTagsWhereInput | CourseTagsWhereInput[]
    courseId?: IntFilter<"CourseTags"> | number
    name?: StringFilter<"CourseTags"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "courseId_name">

  export type CourseTagsOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    _count?: CourseTagsCountOrderByAggregateInput
    _avg?: CourseTagsAvgOrderByAggregateInput
    _max?: CourseTagsMaxOrderByAggregateInput
    _min?: CourseTagsMinOrderByAggregateInput
    _sum?: CourseTagsSumOrderByAggregateInput
  }

  export type CourseTagsScalarWhereWithAggregatesInput = {
    AND?: CourseTagsScalarWhereWithAggregatesInput | CourseTagsScalarWhereWithAggregatesInput[]
    OR?: CourseTagsScalarWhereWithAggregatesInput[]
    NOT?: CourseTagsScalarWhereWithAggregatesInput | CourseTagsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseTags"> | number
    courseId?: IntWithAggregatesFilter<"CourseTags"> | number
    name?: StringWithAggregatesFilter<"CourseTags"> | string
  }

  export type LearningOutcomeWhereInput = {
    AND?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    OR?: LearningOutcomeWhereInput[]
    NOT?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    id?: IntFilter<"LearningOutcome"> | number
    courseId?: IntFilter<"LearningOutcome"> | number
    description?: StringFilter<"LearningOutcome"> | string
    orderNumber?: IntFilter<"LearningOutcome"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type LearningOutcomeOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type LearningOutcomeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    OR?: LearningOutcomeWhereInput[]
    NOT?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    courseId?: IntFilter<"LearningOutcome"> | number
    description?: StringFilter<"LearningOutcome"> | string
    orderNumber?: IntFilter<"LearningOutcome"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type LearningOutcomeOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    _count?: LearningOutcomeCountOrderByAggregateInput
    _avg?: LearningOutcomeAvgOrderByAggregateInput
    _max?: LearningOutcomeMaxOrderByAggregateInput
    _min?: LearningOutcomeMinOrderByAggregateInput
    _sum?: LearningOutcomeSumOrderByAggregateInput
  }

  export type LearningOutcomeScalarWhereWithAggregatesInput = {
    AND?: LearningOutcomeScalarWhereWithAggregatesInput | LearningOutcomeScalarWhereWithAggregatesInput[]
    OR?: LearningOutcomeScalarWhereWithAggregatesInput[]
    NOT?: LearningOutcomeScalarWhereWithAggregatesInput | LearningOutcomeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LearningOutcome"> | number
    courseId?: IntWithAggregatesFilter<"LearningOutcome"> | number
    description?: StringWithAggregatesFilter<"LearningOutcome"> | string
    orderNumber?: IntWithAggregatesFilter<"LearningOutcome"> | number
  }

  export type CourseRequirementWhereInput = {
    AND?: CourseRequirementWhereInput | CourseRequirementWhereInput[]
    OR?: CourseRequirementWhereInput[]
    NOT?: CourseRequirementWhereInput | CourseRequirementWhereInput[]
    id?: IntFilter<"CourseRequirement"> | number
    courseId?: IntFilter<"CourseRequirement"> | number
    description?: StringFilter<"CourseRequirement"> | string
    orderNumber?: IntFilter<"CourseRequirement"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseRequirementOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type CourseRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseRequirementWhereInput | CourseRequirementWhereInput[]
    OR?: CourseRequirementWhereInput[]
    NOT?: CourseRequirementWhereInput | CourseRequirementWhereInput[]
    courseId?: IntFilter<"CourseRequirement"> | number
    description?: StringFilter<"CourseRequirement"> | string
    orderNumber?: IntFilter<"CourseRequirement"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type CourseRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    _count?: CourseRequirementCountOrderByAggregateInput
    _avg?: CourseRequirementAvgOrderByAggregateInput
    _max?: CourseRequirementMaxOrderByAggregateInput
    _min?: CourseRequirementMinOrderByAggregateInput
    _sum?: CourseRequirementSumOrderByAggregateInput
  }

  export type CourseRequirementScalarWhereWithAggregatesInput = {
    AND?: CourseRequirementScalarWhereWithAggregatesInput | CourseRequirementScalarWhereWithAggregatesInput[]
    OR?: CourseRequirementScalarWhereWithAggregatesInput[]
    NOT?: CourseRequirementScalarWhereWithAggregatesInput | CourseRequirementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseRequirement"> | number
    courseId?: IntWithAggregatesFilter<"CourseRequirement"> | number
    description?: StringWithAggregatesFilter<"CourseRequirement"> | string
    orderNumber?: IntWithAggregatesFilter<"CourseRequirement"> | number
  }

  export type CourseModuleWhereInput = {
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    id?: IntFilter<"CourseModule"> | number
    courseId?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    description?: StringFilter<"CourseModule"> | string
    orderNumber?: IntFilter<"CourseModule"> | number
    isPublished?: BoolFilter<"CourseModule"> | boolean
    estimatedHours?: IntNullableFilter<"CourseModule"> | number | null
    unlockCondition?: StringNullableFilter<"CourseModule"> | string | null
    thumbnail?: StringNullableFilter<"CourseModule"> | string | null
    createdAt?: DateTimeFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeFilter<"CourseModule"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    units?: ContentUnitListRelationFilter
    quizzes?: QuizListRelationFilter
    exercises?: ExerciseListRelationFilter
    userProgress?: ModuleProgressListRelationFilter
    flashcards?: FlashcardListRelationFilter
    chatbotMessages?: ChatbotMessageListRelationFilter
  }

  export type CourseModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    unlockCondition?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    units?: ContentUnitOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    userProgress?: ModuleProgressOrderByRelationAggregateInput
    flashcards?: FlashcardOrderByRelationAggregateInput
    chatbotMessages?: ChatbotMessageOrderByRelationAggregateInput
  }

  export type CourseModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    courseId_orderNumber?: CourseModuleCourseIdOrderNumberCompoundUniqueInput
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    courseId?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    description?: StringFilter<"CourseModule"> | string
    orderNumber?: IntFilter<"CourseModule"> | number
    isPublished?: BoolFilter<"CourseModule"> | boolean
    estimatedHours?: IntNullableFilter<"CourseModule"> | number | null
    unlockCondition?: StringNullableFilter<"CourseModule"> | string | null
    thumbnail?: StringNullableFilter<"CourseModule"> | string | null
    createdAt?: DateTimeFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeFilter<"CourseModule"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    units?: ContentUnitListRelationFilter
    quizzes?: QuizListRelationFilter
    exercises?: ExerciseListRelationFilter
    userProgress?: ModuleProgressListRelationFilter
    flashcards?: FlashcardListRelationFilter
    chatbotMessages?: ChatbotMessageListRelationFilter
  }, "id" | "courseId_orderNumber">

  export type CourseModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    unlockCondition?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseModuleCountOrderByAggregateInput
    _avg?: CourseModuleAvgOrderByAggregateInput
    _max?: CourseModuleMaxOrderByAggregateInput
    _min?: CourseModuleMinOrderByAggregateInput
    _sum?: CourseModuleSumOrderByAggregateInput
  }

  export type CourseModuleScalarWhereWithAggregatesInput = {
    AND?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    OR?: CourseModuleScalarWhereWithAggregatesInput[]
    NOT?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseModule"> | number
    courseId?: IntWithAggregatesFilter<"CourseModule"> | number
    title?: StringWithAggregatesFilter<"CourseModule"> | string
    description?: StringWithAggregatesFilter<"CourseModule"> | string
    orderNumber?: IntWithAggregatesFilter<"CourseModule"> | number
    isPublished?: BoolWithAggregatesFilter<"CourseModule"> | boolean
    estimatedHours?: IntNullableWithAggregatesFilter<"CourseModule"> | number | null
    unlockCondition?: StringNullableWithAggregatesFilter<"CourseModule"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"CourseModule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseModule"> | Date | string
  }

  export type ContentUnitWhereInput = {
    AND?: ContentUnitWhereInput | ContentUnitWhereInput[]
    OR?: ContentUnitWhereInput[]
    NOT?: ContentUnitWhereInput | ContentUnitWhereInput[]
    id?: IntFilter<"ContentUnit"> | number
    moduleId?: IntFilter<"ContentUnit"> | number
    title?: StringFilter<"ContentUnit"> | string
    description?: StringNullableFilter<"ContentUnit"> | string | null
    contentType?: EnumContentTypeFilter<"ContentUnit"> | $Enums.ContentType
    orderNumber?: IntFilter<"ContentUnit"> | number
    estimatedMinutes?: IntNullableFilter<"ContentUnit"> | number | null
    isRequired?: BoolFilter<"ContentUnit"> | boolean
    textContent?: StringNullableFilter<"ContentUnit"> | string | null
    videoUrl?: StringNullableFilter<"ContentUnit"> | string | null
    audioUrl?: StringNullableFilter<"ContentUnit"> | string | null
    fileUrl?: StringNullableFilter<"ContentUnit"> | string | null
    externalUrl?: StringNullableFilter<"ContentUnit"> | string | null
    createdAt?: DateTimeFilter<"ContentUnit"> | Date | string
    updatedAt?: DateTimeFilter<"ContentUnit"> | Date | string
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    progress?: UnitProgressListRelationFilter
    attachments?: UnitAttachmentListRelationFilter
  }

  export type ContentUnitOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentType?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    textContent?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: CourseModuleOrderByWithRelationInput
    progress?: UnitProgressOrderByRelationAggregateInput
    attachments?: UnitAttachmentOrderByRelationAggregateInput
  }

  export type ContentUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    moduleId_orderNumber?: ContentUnitModuleIdOrderNumberCompoundUniqueInput
    AND?: ContentUnitWhereInput | ContentUnitWhereInput[]
    OR?: ContentUnitWhereInput[]
    NOT?: ContentUnitWhereInput | ContentUnitWhereInput[]
    moduleId?: IntFilter<"ContentUnit"> | number
    title?: StringFilter<"ContentUnit"> | string
    description?: StringNullableFilter<"ContentUnit"> | string | null
    contentType?: EnumContentTypeFilter<"ContentUnit"> | $Enums.ContentType
    orderNumber?: IntFilter<"ContentUnit"> | number
    estimatedMinutes?: IntNullableFilter<"ContentUnit"> | number | null
    isRequired?: BoolFilter<"ContentUnit"> | boolean
    textContent?: StringNullableFilter<"ContentUnit"> | string | null
    videoUrl?: StringNullableFilter<"ContentUnit"> | string | null
    audioUrl?: StringNullableFilter<"ContentUnit"> | string | null
    fileUrl?: StringNullableFilter<"ContentUnit"> | string | null
    externalUrl?: StringNullableFilter<"ContentUnit"> | string | null
    createdAt?: DateTimeFilter<"ContentUnit"> | Date | string
    updatedAt?: DateTimeFilter<"ContentUnit"> | Date | string
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    progress?: UnitProgressListRelationFilter
    attachments?: UnitAttachmentListRelationFilter
  }, "id" | "moduleId_orderNumber">

  export type ContentUnitOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentType?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    textContent?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentUnitCountOrderByAggregateInput
    _avg?: ContentUnitAvgOrderByAggregateInput
    _max?: ContentUnitMaxOrderByAggregateInput
    _min?: ContentUnitMinOrderByAggregateInput
    _sum?: ContentUnitSumOrderByAggregateInput
  }

  export type ContentUnitScalarWhereWithAggregatesInput = {
    AND?: ContentUnitScalarWhereWithAggregatesInput | ContentUnitScalarWhereWithAggregatesInput[]
    OR?: ContentUnitScalarWhereWithAggregatesInput[]
    NOT?: ContentUnitScalarWhereWithAggregatesInput | ContentUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentUnit"> | number
    moduleId?: IntWithAggregatesFilter<"ContentUnit"> | number
    title?: StringWithAggregatesFilter<"ContentUnit"> | string
    description?: StringNullableWithAggregatesFilter<"ContentUnit"> | string | null
    contentType?: EnumContentTypeWithAggregatesFilter<"ContentUnit"> | $Enums.ContentType
    orderNumber?: IntWithAggregatesFilter<"ContentUnit"> | number
    estimatedMinutes?: IntNullableWithAggregatesFilter<"ContentUnit"> | number | null
    isRequired?: BoolWithAggregatesFilter<"ContentUnit"> | boolean
    textContent?: StringNullableWithAggregatesFilter<"ContentUnit"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"ContentUnit"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"ContentUnit"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"ContentUnit"> | string | null
    externalUrl?: StringNullableWithAggregatesFilter<"ContentUnit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentUnit"> | Date | string
  }

  export type UnitAttachmentWhereInput = {
    AND?: UnitAttachmentWhereInput | UnitAttachmentWhereInput[]
    OR?: UnitAttachmentWhereInput[]
    NOT?: UnitAttachmentWhereInput | UnitAttachmentWhereInput[]
    id?: IntFilter<"UnitAttachment"> | number
    unitId?: IntFilter<"UnitAttachment"> | number
    title?: StringFilter<"UnitAttachment"> | string
    description?: StringNullableFilter<"UnitAttachment"> | string | null
    fileUrl?: StringFilter<"UnitAttachment"> | string
    fileType?: StringFilter<"UnitAttachment"> | string
    unit?: XOR<ContentUnitScalarRelationFilter, ContentUnitWhereInput>
  }

  export type UnitAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    unit?: ContentUnitOrderByWithRelationInput
  }

  export type UnitAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitAttachmentWhereInput | UnitAttachmentWhereInput[]
    OR?: UnitAttachmentWhereInput[]
    NOT?: UnitAttachmentWhereInput | UnitAttachmentWhereInput[]
    unitId?: IntFilter<"UnitAttachment"> | number
    title?: StringFilter<"UnitAttachment"> | string
    description?: StringNullableFilter<"UnitAttachment"> | string | null
    fileUrl?: StringFilter<"UnitAttachment"> | string
    fileType?: StringFilter<"UnitAttachment"> | string
    unit?: XOR<ContentUnitScalarRelationFilter, ContentUnitWhereInput>
  }, "id">

  export type UnitAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    _count?: UnitAttachmentCountOrderByAggregateInput
    _avg?: UnitAttachmentAvgOrderByAggregateInput
    _max?: UnitAttachmentMaxOrderByAggregateInput
    _min?: UnitAttachmentMinOrderByAggregateInput
    _sum?: UnitAttachmentSumOrderByAggregateInput
  }

  export type UnitAttachmentScalarWhereWithAggregatesInput = {
    AND?: UnitAttachmentScalarWhereWithAggregatesInput | UnitAttachmentScalarWhereWithAggregatesInput[]
    OR?: UnitAttachmentScalarWhereWithAggregatesInput[]
    NOT?: UnitAttachmentScalarWhereWithAggregatesInput | UnitAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitAttachment"> | number
    unitId?: IntWithAggregatesFilter<"UnitAttachment"> | number
    title?: StringWithAggregatesFilter<"UnitAttachment"> | string
    description?: StringNullableWithAggregatesFilter<"UnitAttachment"> | string | null
    fileUrl?: StringWithAggregatesFilter<"UnitAttachment"> | string
    fileType?: StringWithAggregatesFilter<"UnitAttachment"> | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: IntFilter<"Enrollment"> | number
    userId?: IntFilter<"Enrollment"> | number
    courseId?: IntFilter<"Enrollment"> | number
    enrollmentDate?: DateTimeFilter<"Enrollment"> | Date | string
    status?: EnumEnrollmentStatusFilter<"Enrollment"> | $Enums.EnrollmentStatus
    completionDate?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    progressPercentage?: IntFilter<"Enrollment"> | number
    lastAccessedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    unenrollmentDate?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    unenrollmentReason?: StringNullableFilter<"Enrollment"> | string | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    moduleProgress?: ModuleProgressListRelationFilter
    unitProgress?: UnitProgressListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    exerciseSubmissions?: ExerciseSubmissionListRelationFilter
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    unenrollmentDate?: SortOrderInput | SortOrder
    unenrollmentReason?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    moduleProgress?: ModuleProgressOrderByRelationAggregateInput
    unitProgress?: UnitProgressOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    exerciseSubmissions?: ExerciseSubmissionOrderByRelationAggregateInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_courseId?: EnrollmentUserIdCourseIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    userId?: IntFilter<"Enrollment"> | number
    courseId?: IntFilter<"Enrollment"> | number
    enrollmentDate?: DateTimeFilter<"Enrollment"> | Date | string
    status?: EnumEnrollmentStatusFilter<"Enrollment"> | $Enums.EnrollmentStatus
    completionDate?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    progressPercentage?: IntFilter<"Enrollment"> | number
    lastAccessedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    unenrollmentDate?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    unenrollmentReason?: StringNullableFilter<"Enrollment"> | string | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    moduleProgress?: ModuleProgressListRelationFilter
    unitProgress?: UnitProgressListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    exerciseSubmissions?: ExerciseSubmissionListRelationFilter
  }, "id" | "userId_courseId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    unenrollmentDate?: SortOrderInput | SortOrder
    unenrollmentReason?: SortOrderInput | SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enrollment"> | number
    userId?: IntWithAggregatesFilter<"Enrollment"> | number
    courseId?: IntWithAggregatesFilter<"Enrollment"> | number
    enrollmentDate?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    status?: EnumEnrollmentStatusWithAggregatesFilter<"Enrollment"> | $Enums.EnrollmentStatus
    completionDate?: DateTimeNullableWithAggregatesFilter<"Enrollment"> | Date | string | null
    progressPercentage?: IntWithAggregatesFilter<"Enrollment"> | number
    lastAccessedAt?: DateTimeNullableWithAggregatesFilter<"Enrollment"> | Date | string | null
    unenrollmentDate?: DateTimeNullableWithAggregatesFilter<"Enrollment"> | Date | string | null
    unenrollmentReason?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
  }

  export type ModuleProgressWhereInput = {
    AND?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    OR?: ModuleProgressWhereInput[]
    NOT?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    id?: IntFilter<"ModuleProgress"> | number
    enrollmentId?: IntFilter<"ModuleProgress"> | number
    moduleId?: IntFilter<"ModuleProgress"> | number
    userId?: IntFilter<"ModuleProgress"> | number
    startedAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    progressPercentage?: IntFilter<"ModuleProgress"> | number
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
  }

  export type ModuleProgressOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    enrollment?: EnrollmentOrderByWithRelationInput
    module?: CourseModuleOrderByWithRelationInput
  }

  export type ModuleProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enrollmentId_moduleId?: ModuleProgressEnrollmentIdModuleIdCompoundUniqueInput
    AND?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    OR?: ModuleProgressWhereInput[]
    NOT?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    enrollmentId?: IntFilter<"ModuleProgress"> | number
    moduleId?: IntFilter<"ModuleProgress"> | number
    userId?: IntFilter<"ModuleProgress"> | number
    startedAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    progressPercentage?: IntFilter<"ModuleProgress"> | number
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
  }, "id" | "enrollmentId_moduleId">

  export type ModuleProgressOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    _count?: ModuleProgressCountOrderByAggregateInput
    _avg?: ModuleProgressAvgOrderByAggregateInput
    _max?: ModuleProgressMaxOrderByAggregateInput
    _min?: ModuleProgressMinOrderByAggregateInput
    _sum?: ModuleProgressSumOrderByAggregateInput
  }

  export type ModuleProgressScalarWhereWithAggregatesInput = {
    AND?: ModuleProgressScalarWhereWithAggregatesInput | ModuleProgressScalarWhereWithAggregatesInput[]
    OR?: ModuleProgressScalarWhereWithAggregatesInput[]
    NOT?: ModuleProgressScalarWhereWithAggregatesInput | ModuleProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModuleProgress"> | number
    enrollmentId?: IntWithAggregatesFilter<"ModuleProgress"> | number
    moduleId?: IntWithAggregatesFilter<"ModuleProgress"> | number
    userId?: IntWithAggregatesFilter<"ModuleProgress"> | number
    startedAt?: DateTimeWithAggregatesFilter<"ModuleProgress"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ModuleProgress"> | Date | string | null
    progressPercentage?: IntWithAggregatesFilter<"ModuleProgress"> | number
  }

  export type UnitProgressWhereInput = {
    AND?: UnitProgressWhereInput | UnitProgressWhereInput[]
    OR?: UnitProgressWhereInput[]
    NOT?: UnitProgressWhereInput | UnitProgressWhereInput[]
    id?: IntFilter<"UnitProgress"> | number
    enrollmentId?: IntFilter<"UnitProgress"> | number
    unitId?: IntFilter<"UnitProgress"> | number
    userId?: IntFilter<"UnitProgress"> | number
    startedAt?: DateTimeFilter<"UnitProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"UnitProgress"> | Date | string | null
    timeSpentMinutes?: IntFilter<"UnitProgress"> | number
    lastPosition?: StringNullableFilter<"UnitProgress"> | string | null
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
    unit?: XOR<ContentUnitScalarRelationFilter, ContentUnitWhereInput>
  }

  export type UnitProgressOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    timeSpentMinutes?: SortOrder
    lastPosition?: SortOrderInput | SortOrder
    enrollment?: EnrollmentOrderByWithRelationInput
    unit?: ContentUnitOrderByWithRelationInput
  }

  export type UnitProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enrollmentId_unitId?: UnitProgressEnrollmentIdUnitIdCompoundUniqueInput
    AND?: UnitProgressWhereInput | UnitProgressWhereInput[]
    OR?: UnitProgressWhereInput[]
    NOT?: UnitProgressWhereInput | UnitProgressWhereInput[]
    enrollmentId?: IntFilter<"UnitProgress"> | number
    unitId?: IntFilter<"UnitProgress"> | number
    userId?: IntFilter<"UnitProgress"> | number
    startedAt?: DateTimeFilter<"UnitProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"UnitProgress"> | Date | string | null
    timeSpentMinutes?: IntFilter<"UnitProgress"> | number
    lastPosition?: StringNullableFilter<"UnitProgress"> | string | null
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
    unit?: XOR<ContentUnitScalarRelationFilter, ContentUnitWhereInput>
  }, "id" | "enrollmentId_unitId">

  export type UnitProgressOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    timeSpentMinutes?: SortOrder
    lastPosition?: SortOrderInput | SortOrder
    _count?: UnitProgressCountOrderByAggregateInput
    _avg?: UnitProgressAvgOrderByAggregateInput
    _max?: UnitProgressMaxOrderByAggregateInput
    _min?: UnitProgressMinOrderByAggregateInput
    _sum?: UnitProgressSumOrderByAggregateInput
  }

  export type UnitProgressScalarWhereWithAggregatesInput = {
    AND?: UnitProgressScalarWhereWithAggregatesInput | UnitProgressScalarWhereWithAggregatesInput[]
    OR?: UnitProgressScalarWhereWithAggregatesInput[]
    NOT?: UnitProgressScalarWhereWithAggregatesInput | UnitProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitProgress"> | number
    enrollmentId?: IntWithAggregatesFilter<"UnitProgress"> | number
    unitId?: IntWithAggregatesFilter<"UnitProgress"> | number
    userId?: IntWithAggregatesFilter<"UnitProgress"> | number
    startedAt?: DateTimeWithAggregatesFilter<"UnitProgress"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UnitProgress"> | Date | string | null
    timeSpentMinutes?: IntWithAggregatesFilter<"UnitProgress"> | number
    lastPosition?: StringNullableWithAggregatesFilter<"UnitProgress"> | string | null
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: IntFilter<"Quiz"> | number
    moduleId?: IntFilter<"Quiz"> | number
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    passingScore?: IntFilter<"Quiz"> | number
    allowRetakes?: BoolFilter<"Quiz"> | boolean
    maxAttempts?: IntNullableFilter<"Quiz"> | number | null
    randomizeQuestions?: BoolFilter<"Quiz"> | boolean
    showCorrectAnswers?: BoolFilter<"Quiz"> | boolean
    orderNumber?: IntFilter<"Quiz"> | number
    isPublished?: BoolFilter<"Quiz"> | boolean
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    questions?: QuizQuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrder
    allowRetakes?: SortOrder
    maxAttempts?: SortOrderInput | SortOrder
    randomizeQuestions?: SortOrder
    showCorrectAnswers?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    module?: CourseModuleOrderByWithRelationInput
    questions?: QuizQuestionOrderByRelationAggregateInput
    attempts?: QuizAttemptOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    moduleId?: IntFilter<"Quiz"> | number
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    passingScore?: IntFilter<"Quiz"> | number
    allowRetakes?: BoolFilter<"Quiz"> | boolean
    maxAttempts?: IntNullableFilter<"Quiz"> | number | null
    randomizeQuestions?: BoolFilter<"Quiz"> | boolean
    showCorrectAnswers?: BoolFilter<"Quiz"> | boolean
    orderNumber?: IntFilter<"Quiz"> | number
    isPublished?: BoolFilter<"Quiz"> | boolean
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    questions?: QuizQuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrder
    allowRetakes?: SortOrder
    maxAttempts?: SortOrderInput | SortOrder
    randomizeQuestions?: SortOrder
    showCorrectAnswers?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quiz"> | number
    moduleId?: IntWithAggregatesFilter<"Quiz"> | number
    title?: StringWithAggregatesFilter<"Quiz"> | string
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    timeLimit?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    passingScore?: IntWithAggregatesFilter<"Quiz"> | number
    allowRetakes?: BoolWithAggregatesFilter<"Quiz"> | boolean
    maxAttempts?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    randomizeQuestions?: BoolWithAggregatesFilter<"Quiz"> | boolean
    showCorrectAnswers?: BoolWithAggregatesFilter<"Quiz"> | boolean
    orderNumber?: IntWithAggregatesFilter<"Quiz"> | number
    isPublished?: BoolWithAggregatesFilter<"Quiz"> | boolean
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: IntFilter<"QuizQuestion"> | number
    quizId?: IntFilter<"QuizQuestion"> | number
    questionText?: StringFilter<"QuizQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"QuizQuestion"> | $Enums.QuestionType
    points?: IntFilter<"QuizQuestion"> | number
    orderNumber?: IntFilter<"QuizQuestion"> | number
    options?: StringNullableFilter<"QuizQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"QuizQuestion"> | string | null
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    answers?: QuestionAnswerListRelationFilter
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrderInput | SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
    answers?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    quizId?: IntFilter<"QuizQuestion"> | number
    questionText?: StringFilter<"QuizQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"QuizQuestion"> | $Enums.QuestionType
    points?: IntFilter<"QuizQuestion"> | number
    orderNumber?: IntFilter<"QuizQuestion"> | number
    options?: StringNullableFilter<"QuizQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"QuizQuestion"> | string | null
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    answers?: QuestionAnswerListRelationFilter
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrderInput | SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizQuestion"> | number
    quizId?: IntWithAggregatesFilter<"QuizQuestion"> | number
    questionText?: StringWithAggregatesFilter<"QuizQuestion"> | string
    questionType?: EnumQuestionTypeWithAggregatesFilter<"QuizQuestion"> | $Enums.QuestionType
    points?: IntWithAggregatesFilter<"QuizQuestion"> | number
    orderNumber?: IntWithAggregatesFilter<"QuizQuestion"> | number
    options?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    correctAnswer?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    explanation?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    enrollmentId?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    userId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    score?: IntNullableFilter<"QuizAttempt"> | number | null
    percentage?: FloatNullableFilter<"QuizAttempt"> | number | null
    passed?: BoolNullableFilter<"QuizAttempt"> | boolean | null
    attemptNumber?: IntFilter<"QuizAttempt"> | number
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    answers?: QuestionAnswerListRelationFilter
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    attemptNumber?: SortOrder
    enrollment?: EnrollmentOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    answers?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    enrollmentId?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    userId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    score?: IntNullableFilter<"QuizAttempt"> | number | null
    percentage?: FloatNullableFilter<"QuizAttempt"> | number | null
    passed?: BoolNullableFilter<"QuizAttempt"> | boolean | null
    attemptNumber?: IntFilter<"QuizAttempt"> | number
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    answers?: QuestionAnswerListRelationFilter
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    attemptNumber?: SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizAttempt"> | number
    enrollmentId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    quizId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    userId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"QuizAttempt"> | Date | string | null
    score?: IntNullableWithAggregatesFilter<"QuizAttempt"> | number | null
    percentage?: FloatNullableWithAggregatesFilter<"QuizAttempt"> | number | null
    passed?: BoolNullableWithAggregatesFilter<"QuizAttempt"> | boolean | null
    attemptNumber?: IntWithAggregatesFilter<"QuizAttempt"> | number
  }

  export type QuestionAnswerWhereInput = {
    AND?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    OR?: QuestionAnswerWhereInput[]
    NOT?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    id?: IntFilter<"QuestionAnswer"> | number
    attemptId?: IntFilter<"QuestionAnswer"> | number
    questionId?: IntFilter<"QuestionAnswer"> | number
    userAnswer?: StringNullableFilter<"QuestionAnswer"> | string | null
    isCorrect?: BoolNullableFilter<"QuestionAnswer"> | boolean | null
    pointsAwarded?: IntNullableFilter<"QuestionAnswer"> | number | null
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }

  export type QuestionAnswerOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userAnswer?: SortOrderInput | SortOrder
    isCorrect?: SortOrderInput | SortOrder
    pointsAwarded?: SortOrderInput | SortOrder
    attempt?: QuizAttemptOrderByWithRelationInput
    question?: QuizQuestionOrderByWithRelationInput
  }

  export type QuestionAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    attemptId_questionId?: QuestionAnswerAttemptIdQuestionIdCompoundUniqueInput
    AND?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    OR?: QuestionAnswerWhereInput[]
    NOT?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    attemptId?: IntFilter<"QuestionAnswer"> | number
    questionId?: IntFilter<"QuestionAnswer"> | number
    userAnswer?: StringNullableFilter<"QuestionAnswer"> | string | null
    isCorrect?: BoolNullableFilter<"QuestionAnswer"> | boolean | null
    pointsAwarded?: IntNullableFilter<"QuestionAnswer"> | number | null
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }, "id" | "attemptId_questionId">

  export type QuestionAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userAnswer?: SortOrderInput | SortOrder
    isCorrect?: SortOrderInput | SortOrder
    pointsAwarded?: SortOrderInput | SortOrder
    _count?: QuestionAnswerCountOrderByAggregateInput
    _avg?: QuestionAnswerAvgOrderByAggregateInput
    _max?: QuestionAnswerMaxOrderByAggregateInput
    _min?: QuestionAnswerMinOrderByAggregateInput
    _sum?: QuestionAnswerSumOrderByAggregateInput
  }

  export type QuestionAnswerScalarWhereWithAggregatesInput = {
    AND?: QuestionAnswerScalarWhereWithAggregatesInput | QuestionAnswerScalarWhereWithAggregatesInput[]
    OR?: QuestionAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuestionAnswerScalarWhereWithAggregatesInput | QuestionAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionAnswer"> | number
    attemptId?: IntWithAggregatesFilter<"QuestionAnswer"> | number
    questionId?: IntWithAggregatesFilter<"QuestionAnswer"> | number
    userAnswer?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    isCorrect?: BoolNullableWithAggregatesFilter<"QuestionAnswer"> | boolean | null
    pointsAwarded?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: IntFilter<"Exercise"> | number
    moduleId?: IntFilter<"Exercise"> | number
    title?: StringFilter<"Exercise"> | string
    description?: StringFilter<"Exercise"> | string
    instructions?: StringFilter<"Exercise"> | string
    exerciseType?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    orderNumber?: IntFilter<"Exercise"> | number
    dueDate?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    allowLateSubmissions?: BoolFilter<"Exercise"> | boolean
    maxScore?: IntFilter<"Exercise"> | number
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    submissions?: ExerciseSubmissionListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    exerciseType?: SortOrder
    orderNumber?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    allowLateSubmissions?: SortOrder
    maxScore?: SortOrder
    module?: CourseModuleOrderByWithRelationInput
    submissions?: ExerciseSubmissionOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    moduleId?: IntFilter<"Exercise"> | number
    title?: StringFilter<"Exercise"> | string
    description?: StringFilter<"Exercise"> | string
    instructions?: StringFilter<"Exercise"> | string
    exerciseType?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    orderNumber?: IntFilter<"Exercise"> | number
    dueDate?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    allowLateSubmissions?: BoolFilter<"Exercise"> | boolean
    maxScore?: IntFilter<"Exercise"> | number
    module?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    submissions?: ExerciseSubmissionListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    exerciseType?: SortOrder
    orderNumber?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    allowLateSubmissions?: SortOrder
    maxScore?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exercise"> | number
    moduleId?: IntWithAggregatesFilter<"Exercise"> | number
    title?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringWithAggregatesFilter<"Exercise"> | string
    instructions?: StringWithAggregatesFilter<"Exercise"> | string
    exerciseType?: EnumExerciseTypeWithAggregatesFilter<"Exercise"> | $Enums.ExerciseType
    orderNumber?: IntWithAggregatesFilter<"Exercise"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"Exercise"> | Date | string | null
    allowLateSubmissions?: BoolWithAggregatesFilter<"Exercise"> | boolean
    maxScore?: IntWithAggregatesFilter<"Exercise"> | number
  }

  export type ExerciseSubmissionWhereInput = {
    AND?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    OR?: ExerciseSubmissionWhereInput[]
    NOT?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    id?: IntFilter<"ExerciseSubmission"> | number
    exerciseId?: IntFilter<"ExerciseSubmission"> | number
    enrollmentId?: IntFilter<"ExerciseSubmission"> | number
    userId?: IntFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeFilter<"ExerciseSubmission"> | Date | string
    content?: StringNullableFilter<"ExerciseSubmission"> | string | null
    fileUrl?: StringNullableFilter<"ExerciseSubmission"> | string | null
    score?: IntNullableFilter<"ExerciseSubmission"> | number | null
    feedback?: StringNullableFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"ExerciseSubmission"> | Date | string | null
    gradedBy?: IntNullableFilter<"ExerciseSubmission"> | number | null
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
  }

  export type ExerciseSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    submittedAt?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    gradedBy?: SortOrderInput | SortOrder
    exercise?: ExerciseOrderByWithRelationInput
    enrollment?: EnrollmentOrderByWithRelationInput
  }

  export type ExerciseSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    OR?: ExerciseSubmissionWhereInput[]
    NOT?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    exerciseId?: IntFilter<"ExerciseSubmission"> | number
    enrollmentId?: IntFilter<"ExerciseSubmission"> | number
    userId?: IntFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeFilter<"ExerciseSubmission"> | Date | string
    content?: StringNullableFilter<"ExerciseSubmission"> | string | null
    fileUrl?: StringNullableFilter<"ExerciseSubmission"> | string | null
    score?: IntNullableFilter<"ExerciseSubmission"> | number | null
    feedback?: StringNullableFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"ExerciseSubmission"> | Date | string | null
    gradedBy?: IntNullableFilter<"ExerciseSubmission"> | number | null
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
  }, "id">

  export type ExerciseSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    submittedAt?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    gradedBy?: SortOrderInput | SortOrder
    _count?: ExerciseSubmissionCountOrderByAggregateInput
    _avg?: ExerciseSubmissionAvgOrderByAggregateInput
    _max?: ExerciseSubmissionMaxOrderByAggregateInput
    _min?: ExerciseSubmissionMinOrderByAggregateInput
    _sum?: ExerciseSubmissionSumOrderByAggregateInput
  }

  export type ExerciseSubmissionScalarWhereWithAggregatesInput = {
    AND?: ExerciseSubmissionScalarWhereWithAggregatesInput | ExerciseSubmissionScalarWhereWithAggregatesInput[]
    OR?: ExerciseSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ExerciseSubmissionScalarWhereWithAggregatesInput | ExerciseSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    exerciseId?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    enrollmentId?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    userId?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeWithAggregatesFilter<"ExerciseSubmission"> | Date | string
    content?: StringNullableWithAggregatesFilter<"ExerciseSubmission"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"ExerciseSubmission"> | string | null
    score?: IntNullableWithAggregatesFilter<"ExerciseSubmission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableWithAggregatesFilter<"ExerciseSubmission"> | Date | string | null
    gradedBy?: IntNullableWithAggregatesFilter<"ExerciseSubmission"> | number | null
  }

  export type CourseReviewWhereInput = {
    AND?: CourseReviewWhereInput | CourseReviewWhereInput[]
    OR?: CourseReviewWhereInput[]
    NOT?: CourseReviewWhereInput | CourseReviewWhereInput[]
    id?: IntFilter<"CourseReview"> | number
    courseId?: IntFilter<"CourseReview"> | number
    userId?: IntFilter<"CourseReview"> | number
    rating?: IntFilter<"CourseReview"> | number
    comment?: StringNullableFilter<"CourseReview"> | string | null
    createdAt?: DateTimeFilter<"CourseReview"> | Date | string
    updatedAt?: DateTimeFilter<"CourseReview"> | Date | string
    isPublished?: BoolFilter<"CourseReview"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseReviewOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublished?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_courseId?: CourseReviewUserIdCourseIdCompoundUniqueInput
    AND?: CourseReviewWhereInput | CourseReviewWhereInput[]
    OR?: CourseReviewWhereInput[]
    NOT?: CourseReviewWhereInput | CourseReviewWhereInput[]
    courseId?: IntFilter<"CourseReview"> | number
    userId?: IntFilter<"CourseReview"> | number
    rating?: IntFilter<"CourseReview"> | number
    comment?: StringNullableFilter<"CourseReview"> | string | null
    createdAt?: DateTimeFilter<"CourseReview"> | Date | string
    updatedAt?: DateTimeFilter<"CourseReview"> | Date | string
    isPublished?: BoolFilter<"CourseReview"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type CourseReviewOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublished?: SortOrder
    _count?: CourseReviewCountOrderByAggregateInput
    _avg?: CourseReviewAvgOrderByAggregateInput
    _max?: CourseReviewMaxOrderByAggregateInput
    _min?: CourseReviewMinOrderByAggregateInput
    _sum?: CourseReviewSumOrderByAggregateInput
  }

  export type CourseReviewScalarWhereWithAggregatesInput = {
    AND?: CourseReviewScalarWhereWithAggregatesInput | CourseReviewScalarWhereWithAggregatesInput[]
    OR?: CourseReviewScalarWhereWithAggregatesInput[]
    NOT?: CourseReviewScalarWhereWithAggregatesInput | CourseReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseReview"> | number
    courseId?: IntWithAggregatesFilter<"CourseReview"> | number
    userId?: IntWithAggregatesFilter<"CourseReview"> | number
    rating?: IntWithAggregatesFilter<"CourseReview"> | number
    comment?: StringNullableWithAggregatesFilter<"CourseReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseReview"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"CourseReview"> | boolean
  }

  export type MentorshipProgramWhereInput = {
    AND?: MentorshipProgramWhereInput | MentorshipProgramWhereInput[]
    OR?: MentorshipProgramWhereInput[]
    NOT?: MentorshipProgramWhereInput | MentorshipProgramWhereInput[]
    id?: IntFilter<"MentorshipProgram"> | number
    title?: StringFilter<"MentorshipProgram"> | string
    description?: StringFilter<"MentorshipProgram"> | string
    startDate?: DateTimeFilter<"MentorshipProgram"> | Date | string
    endDate?: DateTimeNullableFilter<"MentorshipProgram"> | Date | string | null
    maxMentees?: IntFilter<"MentorshipProgram"> | number
    isActive?: BoolFilter<"MentorshipProgram"> | boolean
    relationships?: MentorshipListRelationFilter
  }

  export type MentorshipProgramOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    maxMentees?: SortOrder
    isActive?: SortOrder
    relationships?: MentorshipOrderByRelationAggregateInput
  }

  export type MentorshipProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MentorshipProgramWhereInput | MentorshipProgramWhereInput[]
    OR?: MentorshipProgramWhereInput[]
    NOT?: MentorshipProgramWhereInput | MentorshipProgramWhereInput[]
    title?: StringFilter<"MentorshipProgram"> | string
    description?: StringFilter<"MentorshipProgram"> | string
    startDate?: DateTimeFilter<"MentorshipProgram"> | Date | string
    endDate?: DateTimeNullableFilter<"MentorshipProgram"> | Date | string | null
    maxMentees?: IntFilter<"MentorshipProgram"> | number
    isActive?: BoolFilter<"MentorshipProgram"> | boolean
    relationships?: MentorshipListRelationFilter
  }, "id">

  export type MentorshipProgramOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    maxMentees?: SortOrder
    isActive?: SortOrder
    _count?: MentorshipProgramCountOrderByAggregateInput
    _avg?: MentorshipProgramAvgOrderByAggregateInput
    _max?: MentorshipProgramMaxOrderByAggregateInput
    _min?: MentorshipProgramMinOrderByAggregateInput
    _sum?: MentorshipProgramSumOrderByAggregateInput
  }

  export type MentorshipProgramScalarWhereWithAggregatesInput = {
    AND?: MentorshipProgramScalarWhereWithAggregatesInput | MentorshipProgramScalarWhereWithAggregatesInput[]
    OR?: MentorshipProgramScalarWhereWithAggregatesInput[]
    NOT?: MentorshipProgramScalarWhereWithAggregatesInput | MentorshipProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MentorshipProgram"> | number
    title?: StringWithAggregatesFilter<"MentorshipProgram"> | string
    description?: StringWithAggregatesFilter<"MentorshipProgram"> | string
    startDate?: DateTimeWithAggregatesFilter<"MentorshipProgram"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"MentorshipProgram"> | Date | string | null
    maxMentees?: IntWithAggregatesFilter<"MentorshipProgram"> | number
    isActive?: BoolWithAggregatesFilter<"MentorshipProgram"> | boolean
  }

  export type MentorshipWhereInput = {
    AND?: MentorshipWhereInput | MentorshipWhereInput[]
    OR?: MentorshipWhereInput[]
    NOT?: MentorshipWhereInput | MentorshipWhereInput[]
    id?: IntFilter<"Mentorship"> | number
    mentorId?: IntFilter<"Mentorship"> | number
    menteeId?: IntFilter<"Mentorship"> | number
    programId?: IntNullableFilter<"Mentorship"> | number | null
    startDate?: DateTimeFilter<"Mentorship"> | Date | string
    endDate?: DateTimeNullableFilter<"Mentorship"> | Date | string | null
    status?: EnumStatusTypeFilter<"Mentorship"> | $Enums.StatusType
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
    mentor?: XOR<UserScalarRelationFilter, UserWhereInput>
    program?: XOR<MentorshipProgramNullableScalarRelationFilter, MentorshipProgramWhereInput> | null
    sessions?: MentorshipSessionListRelationFilter
  }

  export type MentorshipOrderByWithRelationInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    mentee?: UserOrderByWithRelationInput
    mentor?: UserOrderByWithRelationInput
    program?: MentorshipProgramOrderByWithRelationInput
    sessions?: MentorshipSessionOrderByRelationAggregateInput
  }

  export type MentorshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MentorshipWhereInput | MentorshipWhereInput[]
    OR?: MentorshipWhereInput[]
    NOT?: MentorshipWhereInput | MentorshipWhereInput[]
    mentorId?: IntFilter<"Mentorship"> | number
    menteeId?: IntFilter<"Mentorship"> | number
    programId?: IntNullableFilter<"Mentorship"> | number | null
    startDate?: DateTimeFilter<"Mentorship"> | Date | string
    endDate?: DateTimeNullableFilter<"Mentorship"> | Date | string | null
    status?: EnumStatusTypeFilter<"Mentorship"> | $Enums.StatusType
    mentee?: XOR<UserScalarRelationFilter, UserWhereInput>
    mentor?: XOR<UserScalarRelationFilter, UserWhereInput>
    program?: XOR<MentorshipProgramNullableScalarRelationFilter, MentorshipProgramWhereInput> | null
    sessions?: MentorshipSessionListRelationFilter
  }, "id">

  export type MentorshipOrderByWithAggregationInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: MentorshipCountOrderByAggregateInput
    _avg?: MentorshipAvgOrderByAggregateInput
    _max?: MentorshipMaxOrderByAggregateInput
    _min?: MentorshipMinOrderByAggregateInput
    _sum?: MentorshipSumOrderByAggregateInput
  }

  export type MentorshipScalarWhereWithAggregatesInput = {
    AND?: MentorshipScalarWhereWithAggregatesInput | MentorshipScalarWhereWithAggregatesInput[]
    OR?: MentorshipScalarWhereWithAggregatesInput[]
    NOT?: MentorshipScalarWhereWithAggregatesInput | MentorshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mentorship"> | number
    mentorId?: IntWithAggregatesFilter<"Mentorship"> | number
    menteeId?: IntWithAggregatesFilter<"Mentorship"> | number
    programId?: IntNullableWithAggregatesFilter<"Mentorship"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Mentorship"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Mentorship"> | Date | string | null
    status?: EnumStatusTypeWithAggregatesFilter<"Mentorship"> | $Enums.StatusType
  }

  export type MentorshipSessionWhereInput = {
    AND?: MentorshipSessionWhereInput | MentorshipSessionWhereInput[]
    OR?: MentorshipSessionWhereInput[]
    NOT?: MentorshipSessionWhereInput | MentorshipSessionWhereInput[]
    id?: IntFilter<"MentorshipSession"> | number
    relationshipId?: IntFilter<"MentorshipSession"> | number
    sessionDate?: DateTimeFilter<"MentorshipSession"> | Date | string
    durationMinutes?: IntFilter<"MentorshipSession"> | number
    notes?: StringNullableFilter<"MentorshipSession"> | string | null
    status?: EnumSessionStatusFilter<"MentorshipSession"> | $Enums.SessionStatus
    feedback?: StringNullableFilter<"MentorshipSession"> | string | null
    relationship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
  }

  export type MentorshipSessionOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    relationship?: MentorshipOrderByWithRelationInput
  }

  export type MentorshipSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MentorshipSessionWhereInput | MentorshipSessionWhereInput[]
    OR?: MentorshipSessionWhereInput[]
    NOT?: MentorshipSessionWhereInput | MentorshipSessionWhereInput[]
    relationshipId?: IntFilter<"MentorshipSession"> | number
    sessionDate?: DateTimeFilter<"MentorshipSession"> | Date | string
    durationMinutes?: IntFilter<"MentorshipSession"> | number
    notes?: StringNullableFilter<"MentorshipSession"> | string | null
    status?: EnumSessionStatusFilter<"MentorshipSession"> | $Enums.SessionStatus
    feedback?: StringNullableFilter<"MentorshipSession"> | string | null
    relationship?: XOR<MentorshipScalarRelationFilter, MentorshipWhereInput>
  }, "id">

  export type MentorshipSessionOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    _count?: MentorshipSessionCountOrderByAggregateInput
    _avg?: MentorshipSessionAvgOrderByAggregateInput
    _max?: MentorshipSessionMaxOrderByAggregateInput
    _min?: MentorshipSessionMinOrderByAggregateInput
    _sum?: MentorshipSessionSumOrderByAggregateInput
  }

  export type MentorshipSessionScalarWhereWithAggregatesInput = {
    AND?: MentorshipSessionScalarWhereWithAggregatesInput | MentorshipSessionScalarWhereWithAggregatesInput[]
    OR?: MentorshipSessionScalarWhereWithAggregatesInput[]
    NOT?: MentorshipSessionScalarWhereWithAggregatesInput | MentorshipSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MentorshipSession"> | number
    relationshipId?: IntWithAggregatesFilter<"MentorshipSession"> | number
    sessionDate?: DateTimeWithAggregatesFilter<"MentorshipSession"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"MentorshipSession"> | number
    notes?: StringNullableWithAggregatesFilter<"MentorshipSession"> | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"MentorshipSession"> | $Enums.SessionStatus
    feedback?: StringNullableWithAggregatesFilter<"MentorshipSession"> | string | null
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: IntFilter<"Event"> | number
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    eventDate?: DateTimeFilter<"Event"> | Date | string
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    location?: StringNullableFilter<"Event"> | string | null
    virtualLink?: StringNullableFilter<"Event"> | string | null
    isVirtual?: BoolFilter<"Event"> | boolean
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    thumbnail?: StringNullableFilter<"Event"> | string | null
    registrationDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    registrations?: EventRegistrationListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    virtualLink?: SortOrderInput | SortOrder
    isVirtual?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    registrationDeadline?: SortOrderInput | SortOrder
    registrations?: EventRegistrationOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    eventDate?: DateTimeFilter<"Event"> | Date | string
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    location?: StringNullableFilter<"Event"> | string | null
    virtualLink?: StringNullableFilter<"Event"> | string | null
    isVirtual?: BoolFilter<"Event"> | boolean
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    thumbnail?: StringNullableFilter<"Event"> | string | null
    registrationDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    registrations?: EventRegistrationListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    virtualLink?: SortOrderInput | SortOrder
    isVirtual?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    registrationDeadline?: SortOrderInput | SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Event"> | number
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    eventDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    virtualLink?: StringNullableWithAggregatesFilter<"Event"> | string | null
    isVirtual?: BoolWithAggregatesFilter<"Event"> | boolean
    maxParticipants?: IntNullableWithAggregatesFilter<"Event"> | number | null
    thumbnail?: StringNullableWithAggregatesFilter<"Event"> | string | null
    registrationDeadline?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
  }

  export type EventRegistrationWhereInput = {
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    id?: IntFilter<"EventRegistration"> | number
    eventId?: IntFilter<"EventRegistration"> | number
    userId?: IntFilter<"EventRegistration"> | number
    registrationDate?: DateTimeFilter<"EventRegistration"> | Date | string
    attendanceConfirmed?: BoolFilter<"EventRegistration"> | boolean
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EventRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    attendanceConfirmed?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    eventId_userId?: EventRegistrationEventIdUserIdCompoundUniqueInput
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    eventId?: IntFilter<"EventRegistration"> | number
    userId?: IntFilter<"EventRegistration"> | number
    registrationDate?: DateTimeFilter<"EventRegistration"> | Date | string
    attendanceConfirmed?: BoolFilter<"EventRegistration"> | boolean
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type EventRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    attendanceConfirmed?: SortOrder
    _count?: EventRegistrationCountOrderByAggregateInput
    _avg?: EventRegistrationAvgOrderByAggregateInput
    _max?: EventRegistrationMaxOrderByAggregateInput
    _min?: EventRegistrationMinOrderByAggregateInput
    _sum?: EventRegistrationSumOrderByAggregateInput
  }

  export type EventRegistrationScalarWhereWithAggregatesInput = {
    AND?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    OR?: EventRegistrationScalarWhereWithAggregatesInput[]
    NOT?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EventRegistration"> | number
    eventId?: IntWithAggregatesFilter<"EventRegistration"> | number
    userId?: IntWithAggregatesFilter<"EventRegistration"> | number
    registrationDate?: DateTimeWithAggregatesFilter<"EventRegistration"> | Date | string
    attendanceConfirmed?: BoolWithAggregatesFilter<"EventRegistration"> | boolean
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: IntFilter<"Community"> | number
    name?: StringFilter<"Community"> | string
    description?: StringFilter<"Community"> | string
    thumbnail?: StringNullableFilter<"Community"> | string | null
    creatorId?: IntFilter<"Community"> | number
    createdAt?: DateTimeFilter<"Community"> | Date | string
    isPrivate?: BoolFilter<"Community"> | boolean
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: CommunityMemberListRelationFilter
    posts?: PostListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    isPrivate?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: CommunityMemberOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    name?: StringFilter<"Community"> | string
    description?: StringFilter<"Community"> | string
    thumbnail?: StringNullableFilter<"Community"> | string | null
    creatorId?: IntFilter<"Community"> | number
    createdAt?: DateTimeFilter<"Community"> | Date | string
    isPrivate?: BoolFilter<"Community"> | boolean
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: CommunityMemberListRelationFilter
    posts?: PostListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    isPrivate?: SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Community"> | number
    name?: StringWithAggregatesFilter<"Community"> | string
    description?: StringWithAggregatesFilter<"Community"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Community"> | string | null
    creatorId?: IntWithAggregatesFilter<"Community"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
    isPrivate?: BoolWithAggregatesFilter<"Community"> | boolean
  }

  export type CommunityMemberWhereInput = {
    AND?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    OR?: CommunityMemberWhereInput[]
    NOT?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    id?: IntFilter<"CommunityMember"> | number
    communityId?: IntFilter<"CommunityMember"> | number
    userId?: IntFilter<"CommunityMember"> | number
    joinedDate?: DateTimeFilter<"CommunityMember"> | Date | string
    role?: EnumCommunityRoleFilter<"CommunityMember"> | $Enums.CommunityRole
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommunityMemberOrderByWithRelationInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
    joinedDate?: SortOrder
    role?: SortOrder
    community?: CommunityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommunityMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    communityId_userId?: CommunityMemberCommunityIdUserIdCompoundUniqueInput
    AND?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    OR?: CommunityMemberWhereInput[]
    NOT?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    communityId?: IntFilter<"CommunityMember"> | number
    userId?: IntFilter<"CommunityMember"> | number
    joinedDate?: DateTimeFilter<"CommunityMember"> | Date | string
    role?: EnumCommunityRoleFilter<"CommunityMember"> | $Enums.CommunityRole
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "communityId_userId">

  export type CommunityMemberOrderByWithAggregationInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
    joinedDate?: SortOrder
    role?: SortOrder
    _count?: CommunityMemberCountOrderByAggregateInput
    _avg?: CommunityMemberAvgOrderByAggregateInput
    _max?: CommunityMemberMaxOrderByAggregateInput
    _min?: CommunityMemberMinOrderByAggregateInput
    _sum?: CommunityMemberSumOrderByAggregateInput
  }

  export type CommunityMemberScalarWhereWithAggregatesInput = {
    AND?: CommunityMemberScalarWhereWithAggregatesInput | CommunityMemberScalarWhereWithAggregatesInput[]
    OR?: CommunityMemberScalarWhereWithAggregatesInput[]
    NOT?: CommunityMemberScalarWhereWithAggregatesInput | CommunityMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityMember"> | number
    communityId?: IntWithAggregatesFilter<"CommunityMember"> | number
    userId?: IntWithAggregatesFilter<"CommunityMember"> | number
    joinedDate?: DateTimeWithAggregatesFilter<"CommunityMember"> | Date | string
    role?: EnumCommunityRoleWithAggregatesFilter<"CommunityMember"> | $Enums.CommunityRole
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    authorId?: IntFilter<"Post"> | number
    communityId?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    comments?: CommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: IntFilter<"Post"> | number
    communityId?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    comments?: CommentListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    authorId?: IntWithAggregatesFilter<"Post"> | number
    communityId?: IntWithAggregatesFilter<"Post"> | number
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    postId?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    creatorId?: IntFilter<"Project"> | number
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    githubUrl?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    thumbnail?: StringNullableFilter<"Project"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    creatorId?: IntFilter<"Project"> | number
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    githubUrl?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    thumbnail?: StringNullableFilter<"Project"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    creatorId?: IntWithAggregatesFilter<"Project"> | number
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    githubUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    demoUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedDate?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedDate?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedDate?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedDate?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _avg?: ProjectMemberAvgOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
    _sum?: ProjectMemberSumOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectMember"> | number
    projectId?: IntWithAggregatesFilter<"ProjectMember"> | number
    userId?: IntWithAggregatesFilter<"ProjectMember"> | number
    role?: EnumProjectRoleWithAggregatesFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedDate?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type SponsorWhereInput = {
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    id?: IntFilter<"Sponsor"> | number
    organizationName?: StringFilter<"Sponsor"> | string
    contactPerson?: StringFilter<"Sponsor"> | string
    email?: StringFilter<"Sponsor"> | string
    phone?: StringNullableFilter<"Sponsor"> | string | null
    website?: StringNullableFilter<"Sponsor"> | string | null
    logo?: StringNullableFilter<"Sponsor"> | string | null
    description?: StringFilter<"Sponsor"> | string
    partnershipStart?: DateTimeFilter<"Sponsor"> | Date | string
    sponsorships?: SponsorshipListRelationFilter
  }

  export type SponsorOrderByWithRelationInput = {
    id?: SortOrder
    organizationName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrder
    partnershipStart?: SortOrder
    sponsorships?: SponsorshipOrderByRelationAggregateInput
  }

  export type SponsorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    organizationName?: StringFilter<"Sponsor"> | string
    contactPerson?: StringFilter<"Sponsor"> | string
    email?: StringFilter<"Sponsor"> | string
    phone?: StringNullableFilter<"Sponsor"> | string | null
    website?: StringNullableFilter<"Sponsor"> | string | null
    logo?: StringNullableFilter<"Sponsor"> | string | null
    description?: StringFilter<"Sponsor"> | string
    partnershipStart?: DateTimeFilter<"Sponsor"> | Date | string
    sponsorships?: SponsorshipListRelationFilter
  }, "id">

  export type SponsorOrderByWithAggregationInput = {
    id?: SortOrder
    organizationName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrder
    partnershipStart?: SortOrder
    _count?: SponsorCountOrderByAggregateInput
    _avg?: SponsorAvgOrderByAggregateInput
    _max?: SponsorMaxOrderByAggregateInput
    _min?: SponsorMinOrderByAggregateInput
    _sum?: SponsorSumOrderByAggregateInput
  }

  export type SponsorScalarWhereWithAggregatesInput = {
    AND?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    OR?: SponsorScalarWhereWithAggregatesInput[]
    NOT?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sponsor"> | number
    organizationName?: StringWithAggregatesFilter<"Sponsor"> | string
    contactPerson?: StringWithAggregatesFilter<"Sponsor"> | string
    email?: StringWithAggregatesFilter<"Sponsor"> | string
    phone?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    website?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    description?: StringWithAggregatesFilter<"Sponsor"> | string
    partnershipStart?: DateTimeWithAggregatesFilter<"Sponsor"> | Date | string
  }

  export type SponsorshipWhereInput = {
    AND?: SponsorshipWhereInput | SponsorshipWhereInput[]
    OR?: SponsorshipWhereInput[]
    NOT?: SponsorshipWhereInput | SponsorshipWhereInput[]
    id?: IntFilter<"Sponsorship"> | number
    sponsorId?: IntFilter<"Sponsorship"> | number
    title?: StringFilter<"Sponsorship"> | string
    description?: StringFilter<"Sponsorship"> | string
    amount?: DecimalFilter<"Sponsorship"> | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFilter<"Sponsorship"> | $Enums.SponsorshipType
    startDate?: DateTimeFilter<"Sponsorship"> | Date | string
    endDate?: DateTimeNullableFilter<"Sponsorship"> | Date | string | null
    sponsor?: XOR<SponsorScalarRelationFilter, SponsorWhereInput>
  }

  export type SponsorshipOrderByWithRelationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    sponsor?: SponsorOrderByWithRelationInput
  }

  export type SponsorshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SponsorshipWhereInput | SponsorshipWhereInput[]
    OR?: SponsorshipWhereInput[]
    NOT?: SponsorshipWhereInput | SponsorshipWhereInput[]
    sponsorId?: IntFilter<"Sponsorship"> | number
    title?: StringFilter<"Sponsorship"> | string
    description?: StringFilter<"Sponsorship"> | string
    amount?: DecimalFilter<"Sponsorship"> | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFilter<"Sponsorship"> | $Enums.SponsorshipType
    startDate?: DateTimeFilter<"Sponsorship"> | Date | string
    endDate?: DateTimeNullableFilter<"Sponsorship"> | Date | string | null
    sponsor?: XOR<SponsorScalarRelationFilter, SponsorWhereInput>
  }, "id">

  export type SponsorshipOrderByWithAggregationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: SponsorshipCountOrderByAggregateInput
    _avg?: SponsorshipAvgOrderByAggregateInput
    _max?: SponsorshipMaxOrderByAggregateInput
    _min?: SponsorshipMinOrderByAggregateInput
    _sum?: SponsorshipSumOrderByAggregateInput
  }

  export type SponsorshipScalarWhereWithAggregatesInput = {
    AND?: SponsorshipScalarWhereWithAggregatesInput | SponsorshipScalarWhereWithAggregatesInput[]
    OR?: SponsorshipScalarWhereWithAggregatesInput[]
    NOT?: SponsorshipScalarWhereWithAggregatesInput | SponsorshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sponsorship"> | number
    sponsorId?: IntWithAggregatesFilter<"Sponsorship"> | number
    title?: StringWithAggregatesFilter<"Sponsorship"> | string
    description?: StringWithAggregatesFilter<"Sponsorship"> | string
    amount?: DecimalWithAggregatesFilter<"Sponsorship"> | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeWithAggregatesFilter<"Sponsorship"> | $Enums.SponsorshipType
    startDate?: DateTimeWithAggregatesFilter<"Sponsorship"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Sponsorship"> | Date | string | null
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: IntFilter<"Achievement"> | number
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    badgeImage?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeImage?: SortOrder
    points?: SortOrder
    category?: SortOrder
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    badgeImage?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    userAchievements?: UserAchievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeImage?: SortOrder
    points?: SortOrder
    category?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Achievement"> | number
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    badgeImage?: StringWithAggregatesFilter<"Achievement"> | string
    points?: IntWithAggregatesFilter<"Achievement"> | number
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: IntFilter<"UserAchievement"> | number
    userId?: IntFilter<"UserAchievement"> | number
    achievementId?: IntFilter<"UserAchievement"> | number
    earnedDate?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: IntFilter<"UserAchievement"> | number
    achievementId?: IntFilter<"UserAchievement"> | number
    earnedDate?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAchievement"> | number
    userId?: IntWithAggregatesFilter<"UserAchievement"> | number
    achievementId?: IntWithAggregatesFilter<"UserAchievement"> | number
    earnedDate?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    title?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    fileUrl?: StringFilter<"Resource"> | string
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    uploaderId?: IntFilter<"Resource"> | number
    uploadDate?: DateTimeFilter<"Resource"> | Date | string
    isApproved?: BoolFilter<"Resource"> | boolean
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploaderId?: SortOrder
    uploadDate?: SortOrder
    isApproved?: SortOrder
    uploader?: UserOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    fileUrl?: StringFilter<"Resource"> | string
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    uploaderId?: IntFilter<"Resource"> | number
    uploadDate?: DateTimeFilter<"Resource"> | Date | string
    isApproved?: BoolFilter<"Resource"> | boolean
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploaderId?: SortOrder
    uploadDate?: SortOrder
    isApproved?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringWithAggregatesFilter<"Resource"> | string
    fileUrl?: StringWithAggregatesFilter<"Resource"> | string
    type?: EnumResourceTypeWithAggregatesFilter<"Resource"> | $Enums.ResourceType
    uploaderId?: IntWithAggregatesFilter<"Resource"> | number
    uploadDate?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    isApproved?: BoolWithAggregatesFilter<"Resource"> | boolean
  }

  export type AssessmentWhereInput = {
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    id?: IntFilter<"Assessment"> | number
    courseId?: IntFilter<"Assessment"> | number
    title?: StringFilter<"Assessment"> | string
    description?: StringFilter<"Assessment"> | string
    totalPoints?: IntFilter<"Assessment"> | number
    passingPoints?: IntFilter<"Assessment"> | number
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    questions?: AssessmentQuestionListRelationFilter
    attempts?: UserAssessmentAttemptListRelationFilter
  }

  export type AssessmentOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
    createdAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    questions?: AssessmentQuestionOrderByRelationAggregateInput
    attempts?: UserAssessmentAttemptOrderByRelationAggregateInput
  }

  export type AssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    courseId?: IntFilter<"Assessment"> | number
    title?: StringFilter<"Assessment"> | string
    description?: StringFilter<"Assessment"> | string
    totalPoints?: IntFilter<"Assessment"> | number
    passingPoints?: IntFilter<"Assessment"> | number
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    questions?: AssessmentQuestionListRelationFilter
    attempts?: UserAssessmentAttemptListRelationFilter
  }, "id">

  export type AssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
    createdAt?: SortOrder
    _count?: AssessmentCountOrderByAggregateInput
    _avg?: AssessmentAvgOrderByAggregateInput
    _max?: AssessmentMaxOrderByAggregateInput
    _min?: AssessmentMinOrderByAggregateInput
    _sum?: AssessmentSumOrderByAggregateInput
  }

  export type AssessmentScalarWhereWithAggregatesInput = {
    AND?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    OR?: AssessmentScalarWhereWithAggregatesInput[]
    NOT?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assessment"> | number
    courseId?: IntWithAggregatesFilter<"Assessment"> | number
    title?: StringWithAggregatesFilter<"Assessment"> | string
    description?: StringWithAggregatesFilter<"Assessment"> | string
    totalPoints?: IntWithAggregatesFilter<"Assessment"> | number
    passingPoints?: IntWithAggregatesFilter<"Assessment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
  }

  export type AssessmentQuestionWhereInput = {
    AND?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    OR?: AssessmentQuestionWhereInput[]
    NOT?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    id?: IntFilter<"AssessmentQuestion"> | number
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    question?: StringFilter<"AssessmentQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"AssessmentQuestion"> | $Enums.QuestionType
    points?: IntFilter<"AssessmentQuestion"> | number
    orderNumber?: IntFilter<"AssessmentQuestion"> | number
    options?: StringNullableFilter<"AssessmentQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"AssessmentQuestion"> | string | null
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }

  export type AssessmentQuestionOrderByWithRelationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrderInput | SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    assessment?: AssessmentOrderByWithRelationInput
  }

  export type AssessmentQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    OR?: AssessmentQuestionWhereInput[]
    NOT?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    question?: StringFilter<"AssessmentQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"AssessmentQuestion"> | $Enums.QuestionType
    points?: IntFilter<"AssessmentQuestion"> | number
    orderNumber?: IntFilter<"AssessmentQuestion"> | number
    options?: StringNullableFilter<"AssessmentQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"AssessmentQuestion"> | string | null
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }, "id">

  export type AssessmentQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrderInput | SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    _count?: AssessmentQuestionCountOrderByAggregateInput
    _avg?: AssessmentQuestionAvgOrderByAggregateInput
    _max?: AssessmentQuestionMaxOrderByAggregateInput
    _min?: AssessmentQuestionMinOrderByAggregateInput
    _sum?: AssessmentQuestionSumOrderByAggregateInput
  }

  export type AssessmentQuestionScalarWhereWithAggregatesInput = {
    AND?: AssessmentQuestionScalarWhereWithAggregatesInput | AssessmentQuestionScalarWhereWithAggregatesInput[]
    OR?: AssessmentQuestionScalarWhereWithAggregatesInput[]
    NOT?: AssessmentQuestionScalarWhereWithAggregatesInput | AssessmentQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    assessmentId?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    question?: StringWithAggregatesFilter<"AssessmentQuestion"> | string
    questionType?: EnumQuestionTypeWithAggregatesFilter<"AssessmentQuestion"> | $Enums.QuestionType
    points?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    orderNumber?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    options?: StringNullableWithAggregatesFilter<"AssessmentQuestion"> | string | null
    correctAnswer?: StringNullableWithAggregatesFilter<"AssessmentQuestion"> | string | null
  }

  export type UserAssessmentAttemptWhereInput = {
    AND?: UserAssessmentAttemptWhereInput | UserAssessmentAttemptWhereInput[]
    OR?: UserAssessmentAttemptWhereInput[]
    NOT?: UserAssessmentAttemptWhereInput | UserAssessmentAttemptWhereInput[]
    id?: IntFilter<"UserAssessmentAttempt"> | number
    userId?: IntFilter<"UserAssessmentAttempt"> | number
    assessmentId?: IntFilter<"UserAssessmentAttempt"> | number
    score?: IntFilter<"UserAssessmentAttempt"> | number
    passed?: BoolFilter<"UserAssessmentAttempt"> | boolean
    attemptDate?: DateTimeFilter<"UserAssessmentAttempt"> | Date | string
    attemptNumber?: IntFilter<"UserAssessmentAttempt"> | number
    answers?: StringNullableFilter<"UserAssessmentAttempt"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }

  export type UserAssessmentAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    attemptDate?: SortOrder
    attemptNumber?: SortOrder
    answers?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    assessment?: AssessmentOrderByWithRelationInput
  }

  export type UserAssessmentAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAssessmentAttemptWhereInput | UserAssessmentAttemptWhereInput[]
    OR?: UserAssessmentAttemptWhereInput[]
    NOT?: UserAssessmentAttemptWhereInput | UserAssessmentAttemptWhereInput[]
    userId?: IntFilter<"UserAssessmentAttempt"> | number
    assessmentId?: IntFilter<"UserAssessmentAttempt"> | number
    score?: IntFilter<"UserAssessmentAttempt"> | number
    passed?: BoolFilter<"UserAssessmentAttempt"> | boolean
    attemptDate?: DateTimeFilter<"UserAssessmentAttempt"> | Date | string
    attemptNumber?: IntFilter<"UserAssessmentAttempt"> | number
    answers?: StringNullableFilter<"UserAssessmentAttempt"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }, "id">

  export type UserAssessmentAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    attemptDate?: SortOrder
    attemptNumber?: SortOrder
    answers?: SortOrderInput | SortOrder
    _count?: UserAssessmentAttemptCountOrderByAggregateInput
    _avg?: UserAssessmentAttemptAvgOrderByAggregateInput
    _max?: UserAssessmentAttemptMaxOrderByAggregateInput
    _min?: UserAssessmentAttemptMinOrderByAggregateInput
    _sum?: UserAssessmentAttemptSumOrderByAggregateInput
  }

  export type UserAssessmentAttemptScalarWhereWithAggregatesInput = {
    AND?: UserAssessmentAttemptScalarWhereWithAggregatesInput | UserAssessmentAttemptScalarWhereWithAggregatesInput[]
    OR?: UserAssessmentAttemptScalarWhereWithAggregatesInput[]
    NOT?: UserAssessmentAttemptScalarWhereWithAggregatesInput | UserAssessmentAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAssessmentAttempt"> | number
    userId?: IntWithAggregatesFilter<"UserAssessmentAttempt"> | number
    assessmentId?: IntWithAggregatesFilter<"UserAssessmentAttempt"> | number
    score?: IntWithAggregatesFilter<"UserAssessmentAttempt"> | number
    passed?: BoolWithAggregatesFilter<"UserAssessmentAttempt"> | boolean
    attemptDate?: DateTimeWithAggregatesFilter<"UserAssessmentAttempt"> | Date | string
    attemptNumber?: IntWithAggregatesFilter<"UserAssessmentAttempt"> | number
    answers?: StringNullableWithAggregatesFilter<"UserAssessmentAttempt"> | string | null
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    providerId?: IntFilter<"Feedback"> | number
    targetId?: IntFilter<"Feedback"> | number
    targetType?: EnumFeedbackTargetFilter<"Feedback"> | $Enums.FeedbackTarget
    rating?: IntFilter<"Feedback"> | number
    comment?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    provider?: UserOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    providerId?: IntFilter<"Feedback"> | number
    targetId?: IntFilter<"Feedback"> | number
    targetType?: EnumFeedbackTargetFilter<"Feedback"> | $Enums.FeedbackTarget
    rating?: IntFilter<"Feedback"> | number
    comment?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    providerId?: IntWithAggregatesFilter<"Feedback"> | number
    targetId?: IntWithAggregatesFilter<"Feedback"> | number
    targetType?: EnumFeedbackTargetWithAggregatesFilter<"Feedback"> | $Enums.FeedbackTarget
    rating?: IntWithAggregatesFilter<"Feedback"> | number
    comment?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type SubscriberWhereInput = {
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    id?: IntFilter<"Subscriber"> | number
    email?: StringFilter<"Subscriber"> | string
    name?: StringNullableFilter<"Subscriber"> | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
  }

  export type SubscriberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    name?: StringNullableFilter<"Subscriber"> | string | null
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriber"> | Date | string
  }, "id" | "email">

  export type SubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriberCountOrderByAggregateInput
    _avg?: SubscriberAvgOrderByAggregateInput
    _max?: SubscriberMaxOrderByAggregateInput
    _min?: SubscriberMinOrderByAggregateInput
    _sum?: SubscriberSumOrderByAggregateInput
  }

  export type SubscriberScalarWhereWithAggregatesInput = {
    AND?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    OR?: SubscriberScalarWhereWithAggregatesInput[]
    NOT?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscriber"> | number
    email?: StringWithAggregatesFilter<"Subscriber"> | string
    name?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCreateInput = {
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    user: UserCreateNestedOneWithoutFlashcardsInput
    course?: CourseCreateNestedOneWithoutFlashcardsInput
    module?: CourseModuleCreateNestedOneWithoutFlashcardsInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUncheckedCreateInput = {
    id?: number
    userId: number
    courseId?: number | null
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFlashcardsNestedInput
    course?: CourseUpdateOneWithoutFlashcardsNestedInput
    module?: CourseModuleUpdateOneWithoutFlashcardsNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardCreateManyInput = {
    id?: number
    userId: number
    courseId?: number | null
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
  }

  export type FlashcardUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlashcardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlashcardInteractionCreateInput = {
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
    flashcard: FlashcardCreateNestedOneWithoutUserInteractionsInput
    user: UserCreateNestedOneWithoutUserInteractionsInput
  }

  export type FlashcardInteractionUncheckedCreateInput = {
    id?: number
    flashcardId: number
    userId: number
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
  }

  export type FlashcardInteractionUpdateInput = {
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    flashcard?: FlashcardUpdateOneRequiredWithoutUserInteractionsNestedInput
    user?: UserUpdateOneRequiredWithoutUserInteractionsNestedInput
  }

  export type FlashcardInteractionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardInteractionCreateManyInput = {
    id?: number
    flashcardId: number
    userId: number
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
  }

  export type FlashcardInteractionUpdateManyMutationInput = {
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardInteractionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    isPublic?: boolean
    user: UserCreateNestedOneWithoutFlashcardCollectionsInput
    cards?: FlashcardCollectionItemCreateNestedManyWithoutCollectionInput
  }

  export type FlashcardCollectionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    userId: number
    createdAt?: Date | string
    isPublic?: boolean
    cards?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type FlashcardCollectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutFlashcardCollectionsNestedInput
    cards?: FlashcardCollectionItemUpdateManyWithoutCollectionNestedInput
  }

  export type FlashcardCollectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    cards?: FlashcardCollectionItemUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type FlashcardCollectionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    userId: number
    createdAt?: Date | string
    isPublic?: boolean
  }

  export type FlashcardCollectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlashcardCollectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlashcardCollectionItemCreateInput = {
    addedAt?: Date | string
    collection: FlashcardCollectionCreateNestedOneWithoutCardsInput
    flashcard: FlashcardCreateNestedOneWithoutCollectionsInput
  }

  export type FlashcardCollectionItemUncheckedCreateInput = {
    id?: number
    collectionId: number
    flashcardId: number
    addedAt?: Date | string
  }

  export type FlashcardCollectionItemUpdateInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: FlashcardCollectionUpdateOneRequiredWithoutCardsNestedInput
    flashcard?: FlashcardUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type FlashcardCollectionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    collectionId?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionItemCreateManyInput = {
    id?: number
    collectionId: number
    flashcardId: number
    addedAt?: Date | string
  }

  export type FlashcardCollectionItemUpdateManyMutationInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    collectionId?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotSessionCreateInput = {
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutChatbotSessionsInput
    messages?: ChatbotMessageCreateNestedManyWithoutSessionInput
    analytics?: ChatbotSessionAnalyticsCreateNestedOneWithoutSessionInput
  }

  export type ChatbotSessionUncheckedCreateInput = {
    id?: number
    userId: number
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ChatbotMessageUncheckedCreateNestedManyWithoutSessionInput
    analytics?: ChatbotSessionAnalyticsUncheckedCreateNestedOneWithoutSessionInput
  }

  export type ChatbotSessionUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutChatbotSessionsNestedInput
    messages?: ChatbotMessageUpdateManyWithoutSessionNestedInput
    analytics?: ChatbotSessionAnalyticsUpdateOneWithoutSessionNestedInput
  }

  export type ChatbotSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatbotMessageUncheckedUpdateManyWithoutSessionNestedInput
    analytics?: ChatbotSessionAnalyticsUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type ChatbotSessionCreateManyInput = {
    id?: number
    userId: number
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type ChatbotSessionUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatbotSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatbotMessageCreateInput = {
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    session: ChatbotSessionCreateNestedOneWithoutMessagesInput
    course?: CourseCreateNestedOneWithoutChatbotMessagesInput
    module?: CourseModuleCreateNestedOneWithoutChatbotMessagesInput
    feedback?: ChatbotFeedbackCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageUncheckedCreateInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    feedback?: ChatbotFeedbackUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    session?: ChatbotSessionUpdateOneRequiredWithoutMessagesNestedInput
    course?: CourseUpdateOneWithoutChatbotMessagesNestedInput
    module?: CourseModuleUpdateOneWithoutChatbotMessagesNestedInput
    feedback?: ChatbotFeedbackUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: ChatbotFeedbackUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageCreateManyInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
  }

  export type ChatbotMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChatbotMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChatbotFeedbackCreateInput = {
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    message: ChatbotMessageCreateNestedOneWithoutFeedbackInput
    user: UserCreateNestedOneWithoutChatbotFeedbackInput
  }

  export type ChatbotFeedbackUncheckedCreateInput = {
    id?: number
    messageId: number
    userId: number
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
  }

  export type ChatbotFeedbackUpdateInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: ChatbotMessageUpdateOneRequiredWithoutFeedbackNestedInput
    user?: UserUpdateOneRequiredWithoutChatbotFeedbackNestedInput
  }

  export type ChatbotFeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotFeedbackCreateManyInput = {
    id?: number
    messageId: number
    userId: number
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
  }

  export type ChatbotFeedbackUpdateManyMutationInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotFeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotSessionAnalyticsCreateInput = {
    messageCount?: number
    userMessageCount?: number
    aiMessageCount?: number
    averageUserMessageLength?: number | null
    averageAiResponseLength?: number | null
    topicsDiscussed?: string | null
    session: ChatbotSessionCreateNestedOneWithoutAnalyticsInput
  }

  export type ChatbotSessionAnalyticsUncheckedCreateInput = {
    id?: number
    sessionId: number
    messageCount?: number
    userMessageCount?: number
    aiMessageCount?: number
    averageUserMessageLength?: number | null
    averageAiResponseLength?: number | null
    topicsDiscussed?: string | null
  }

  export type ChatbotSessionAnalyticsUpdateInput = {
    messageCount?: IntFieldUpdateOperationsInput | number
    userMessageCount?: IntFieldUpdateOperationsInput | number
    aiMessageCount?: IntFieldUpdateOperationsInput | number
    averageUserMessageLength?: NullableIntFieldUpdateOperationsInput | number | null
    averageAiResponseLength?: NullableIntFieldUpdateOperationsInput | number | null
    topicsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
    session?: ChatbotSessionUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type ChatbotSessionAnalyticsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    messageCount?: IntFieldUpdateOperationsInput | number
    userMessageCount?: IntFieldUpdateOperationsInput | number
    aiMessageCount?: IntFieldUpdateOperationsInput | number
    averageUserMessageLength?: NullableIntFieldUpdateOperationsInput | number | null
    averageAiResponseLength?: NullableIntFieldUpdateOperationsInput | number | null
    topicsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatbotSessionAnalyticsCreateManyInput = {
    id?: number
    sessionId: number
    messageCount?: number
    userMessageCount?: number
    aiMessageCount?: number
    averageUserMessageLength?: number | null
    averageAiResponseLength?: number | null
    topicsDiscussed?: string | null
  }

  export type ChatbotSessionAnalyticsUpdateManyMutationInput = {
    messageCount?: IntFieldUpdateOperationsInput | number
    userMessageCount?: IntFieldUpdateOperationsInput | number
    aiMessageCount?: IntFieldUpdateOperationsInput | number
    averageUserMessageLength?: NullableIntFieldUpdateOperationsInput | number | null
    averageAiResponseLength?: NullableIntFieldUpdateOperationsInput | number | null
    topicsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatbotSessionAnalyticsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    messageCount?: IntFieldUpdateOperationsInput | number
    userMessageCount?: IntFieldUpdateOperationsInput | number
    aiMessageCount?: IntFieldUpdateOperationsInput | number
    averageUserMessageLength?: NullableIntFieldUpdateOperationsInput | number | null
    averageAiResponseLength?: NullableIntFieldUpdateOperationsInput | number | null
    topicsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedAnswerCreateInput = {
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    user?: UserCreateNestedOneWithoutSavedAnswersInput
    course?: CourseCreateNestedOneWithoutSavedAnswersInput
  }

  export type SavedAnswerUncheckedCreateInput = {
    id?: number
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    userId?: number | null
    courseId?: number | null
  }

  export type SavedAnswerUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutSavedAnswersNestedInput
    course?: CourseUpdateOneWithoutSavedAnswersNestedInput
  }

  export type SavedAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SavedAnswerCreateManyInput = {
    id?: number
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    userId?: number | null
    courseId?: number | null
  }

  export type SavedAnswerUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SavedAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SkillCreateInput = {
    name: string
    category: string
    description?: string | null
    icon?: string | null
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    icon?: string | null
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    icon?: string | null
  }

  export type SkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSkillCreateInput = {
    proficiencyLevel: number
    acquiredDate?: Date | string | null
    user: UserCreateNestedOneWithoutUserSkillsInput
    skill: SkillCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillUncheckedCreateInput = {
    id?: number
    userId: number
    skillId: number
    proficiencyLevel: number
    acquiredDate?: Date | string | null
  }

  export type UserSkillUpdateInput = {
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSkillCreateManyInput = {
    id?: number
    userId: number
    skillId: number
    proficiencyLevel: number
    acquiredDate?: Date | string | null
  }

  export type UserSkillUpdateManyMutationInput = {
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseCreateInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTagsCreateInput = {
    name: string
    course: CourseCreateNestedOneWithoutTagsInput
  }

  export type CourseTagsUncheckedCreateInput = {
    id?: number
    courseId: number
    name: string
  }

  export type CourseTagsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutTagsNestedInput
  }

  export type CourseTagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagsCreateManyInput = {
    id?: number
    courseId: number
    name: string
  }

  export type CourseTagsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LearningOutcomeCreateInput = {
    description: string
    orderNumber: number
    course: CourseCreateNestedOneWithoutLearningOutcomesInput
  }

  export type LearningOutcomeUncheckedCreateInput = {
    id?: number
    courseId: number
    description: string
    orderNumber: number
  }

  export type LearningOutcomeUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutLearningOutcomesNestedInput
  }

  export type LearningOutcomeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type LearningOutcomeCreateManyInput = {
    id?: number
    courseId: number
    description: string
    orderNumber: number
  }

  export type LearningOutcomeUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type LearningOutcomeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseRequirementCreateInput = {
    description: string
    orderNumber: number
    course: CourseCreateNestedOneWithoutRequirementsInput
  }

  export type CourseRequirementUncheckedCreateInput = {
    id?: number
    courseId: number
    description: string
    orderNumber: number
  }

  export type CourseRequirementUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type CourseRequirementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseRequirementCreateManyInput = {
    id?: number
    courseId: number
    description: string
    orderNumber: number
  }

  export type CourseRequirementUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseRequirementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseModuleCreateInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleCreateManyInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseModuleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUnitCreateInput = {
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    module: CourseModuleCreateNestedOneWithoutUnitsInput
    progress?: UnitProgressCreateNestedManyWithoutUnitInput
    attachments?: UnitAttachmentCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitUncheckedCreateInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UnitProgressUncheckedCreateNestedManyWithoutUnitInput
    attachments?: UnitAttachmentUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: CourseModuleUpdateOneRequiredWithoutUnitsNestedInput
    progress?: UnitProgressUpdateManyWithoutUnitNestedInput
    attachments?: UnitAttachmentUpdateManyWithoutUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UnitProgressUncheckedUpdateManyWithoutUnitNestedInput
    attachments?: UnitAttachmentUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ContentUnitCreateManyInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUnitUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAttachmentCreateInput = {
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    unit: ContentUnitCreateNestedOneWithoutAttachmentsInput
  }

  export type UnitAttachmentUncheckedCreateInput = {
    id?: number
    unitId: number
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
  }

  export type UnitAttachmentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    unit?: ContentUnitUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type UnitAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type UnitAttachmentCreateManyInput = {
    id?: number
    unitId: number
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
  }

  export type UnitAttachmentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type UnitAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentCreateInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentsInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUpdateInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
  }

  export type EnrollmentUpdateManyMutationInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuleProgressCreateInput = {
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
    enrollment: EnrollmentCreateNestedOneWithoutModuleProgressInput
    module: CourseModuleCreateNestedOneWithoutUserProgressInput
  }

  export type ModuleProgressUncheckedCreateInput = {
    id?: number
    enrollmentId: number
    moduleId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
  }

  export type ModuleProgressUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    enrollment?: EnrollmentUpdateOneRequiredWithoutModuleProgressNestedInput
    module?: CourseModuleUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type ModuleProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleProgressCreateManyInput = {
    id?: number
    enrollmentId: number
    moduleId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
  }

  export type ModuleProgressUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type UnitProgressCreateInput = {
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
    enrollment: EnrollmentCreateNestedOneWithoutUnitProgressInput
    unit: ContentUnitCreateNestedOneWithoutProgressInput
  }

  export type UnitProgressUncheckedCreateInput = {
    id?: number
    enrollmentId: number
    unitId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
  }

  export type UnitProgressUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: EnrollmentUpdateOneRequiredWithoutUnitProgressNestedInput
    unit?: ContentUnitUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UnitProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitProgressCreateManyInput = {
    id?: number
    enrollmentId: number
    unitId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
  }

  export type UnitProgressUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizCreateInput = {
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    module: CourseModuleCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    module?: CourseModuleUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
  }

  export type QuizUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuizQuestionCreateInput = {
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    answers?: QuestionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: number
    quizId: number
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
    answers?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUpdateInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: QuestionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: number
    quizId: number
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
  }

  export type QuizQuestionUpdateManyMutationInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizAttemptCreateInput = {
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    enrollment: EnrollmentCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    answers?: QuestionAnswerCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: number
    enrollmentId: number
    quizId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    answers?: QuestionAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    enrollment?: EnrollmentUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    answers?: QuestionAnswerUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: QuestionAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptCreateManyInput = {
    id?: number
    enrollmentId: number
    quizId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
  }

  export type QuizAttemptUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionAnswerCreateInput = {
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
    attempt: QuizAttemptCreateNestedOneWithoutAnswersInput
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuestionAnswerUncheckedCreateInput = {
    id?: number
    attemptId: number
    questionId: number
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
  }

  export type QuestionAnswerUpdateInput = {
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuestionAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAnswerCreateManyInput = {
    id?: number
    attemptId: number
    questionId: number
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
  }

  export type QuestionAnswerUpdateManyMutationInput = {
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseCreateInput = {
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
    module: CourseModuleCreateNestedOneWithoutExercisesInput
    submissions?: ExerciseSubmissionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: number
    moduleId: number
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
    submissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
    module?: CourseModuleUpdateOneRequiredWithoutExercisesNestedInput
    submissions?: ExerciseSubmissionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
    submissions?: ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: number
    moduleId: number
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
  }

  export type ExerciseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type ExerciseSubmissionCreateInput = {
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
    exercise: ExerciseCreateNestedOneWithoutSubmissionsInput
    enrollment: EnrollmentCreateNestedOneWithoutExerciseSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateInput = {
    id?: number
    exerciseId: number
    enrollmentId: number
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
  }

  export type ExerciseSubmissionUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
    exercise?: ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput
    enrollment?: EnrollmentUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseSubmissionCreateManyInput = {
    id?: number
    exerciseId: number
    enrollmentId: number
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
  }

  export type ExerciseSubmissionUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseReviewCreateInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    user: UserCreateNestedOneWithoutReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
  }

  export type CourseReviewUncheckedCreateInput = {
    id?: number
    courseId: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
  }

  export type CourseReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type CourseReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseReviewCreateManyInput = {
    id?: number
    courseId: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
  }

  export type CourseReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorshipProgramCreateInput = {
    title: string
    description: string
    startDate: Date | string
    endDate?: Date | string | null
    maxMentees: number
    isActive?: boolean
    relationships?: MentorshipCreateNestedManyWithoutProgramInput
  }

  export type MentorshipProgramUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate?: Date | string | null
    maxMentees: number
    isActive?: boolean
    relationships?: MentorshipUncheckedCreateNestedManyWithoutProgramInput
  }

  export type MentorshipProgramUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    relationships?: MentorshipUpdateManyWithoutProgramNestedInput
  }

  export type MentorshipProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    relationships?: MentorshipUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type MentorshipProgramCreateManyInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate?: Date | string | null
    maxMentees: number
    isActive?: boolean
  }

  export type MentorshipProgramUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorshipProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorshipCreateInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    mentee: UserCreateNestedOneWithoutMenteeRelationshipsInput
    mentor: UserCreateNestedOneWithoutMentorRelationshipsInput
    program?: MentorshipProgramCreateNestedOneWithoutRelationshipsInput
    sessions?: MentorshipSessionCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipUncheckedCreateInput = {
    id?: number
    mentorId: number
    menteeId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    sessions?: MentorshipSessionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    mentee?: UserUpdateOneRequiredWithoutMenteeRelationshipsNestedInput
    mentor?: UserUpdateOneRequiredWithoutMentorRelationshipsNestedInput
    program?: MentorshipProgramUpdateOneWithoutRelationshipsNestedInput
    sessions?: MentorshipSessionUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    sessions?: MentorshipSessionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipCreateManyInput = {
    id?: number
    mentorId: number
    menteeId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
  }

  export type MentorshipUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type MentorshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type MentorshipSessionCreateInput = {
    sessionDate: Date | string
    durationMinutes: number
    notes?: string | null
    status: $Enums.SessionStatus
    feedback?: string | null
    relationship: MentorshipCreateNestedOneWithoutSessionsInput
  }

  export type MentorshipSessionUncheckedCreateInput = {
    id?: number
    relationshipId: number
    sessionDate: Date | string
    durationMinutes: number
    notes?: string | null
    status: $Enums.SessionStatus
    feedback?: string | null
  }

  export type MentorshipSessionUpdateInput = {
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: MentorshipUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type MentorshipSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationshipId?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorshipSessionCreateManyInput = {
    id?: number
    relationshipId: number
    sessionDate: Date | string
    durationMinutes: number
    notes?: string | null
    status: $Enums.SessionStatus
    feedback?: string | null
  }

  export type MentorshipSessionUpdateManyMutationInput = {
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorshipSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationshipId?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventCreateInput = {
    title: string
    description: string
    eventDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    virtualLink?: string | null
    isVirtual?: boolean
    maxParticipants?: number | null
    thumbnail?: string | null
    registrationDeadline?: Date | string | null
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    eventDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    virtualLink?: string | null
    isVirtual?: boolean
    maxParticipants?: number | null
    thumbnail?: string | null
    registrationDeadline?: Date | string | null
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: number
    title: string
    description: string
    eventDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    virtualLink?: string | null
    isVirtual?: boolean
    maxParticipants?: number | null
    thumbnail?: string | null
    registrationDeadline?: Date | string | null
  }

  export type EventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationCreateInput = {
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
    event: EventCreateNestedOneWithoutRegistrationsInput
    user: UserCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateInput = {
    id?: number
    eventId: number
    userId: number
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
  }

  export type EventRegistrationUpdateInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventRegistrationCreateManyInput = {
    id?: number
    eventId: number
    userId: number
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
  }

  export type EventRegistrationUpdateManyMutationInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventRegistrationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityCreateInput = {
    name: string
    description: string
    thumbnail?: string | null
    createdAt?: Date | string
    isPrivate?: boolean
    creator: UserCreateNestedOneWithoutCreatedCommunitiesInput
    members?: CommunityMemberCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    thumbnail?: string | null
    creatorId: number
    createdAt?: Date | string
    isPrivate?: boolean
    members?: CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    creator?: UserUpdateOneRequiredWithoutCreatedCommunitiesNestedInput
    members?: CommunityMemberUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    members?: CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: number
    name: string
    description: string
    thumbnail?: string | null
    creatorId: number
    createdAt?: Date | string
    isPrivate?: boolean
  }

  export type CommunityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityMemberCreateInput = {
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
    community: CommunityCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutCommunityMembershipsInput
  }

  export type CommunityMemberUncheckedCreateInput = {
    id?: number
    communityId: number
    userId: number
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
  }

  export type CommunityMemberUpdateInput = {
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
    community?: CommunityUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutCommunityMembershipsNestedInput
  }

  export type CommunityMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type CommunityMemberCreateManyInput = {
    id?: number
    communityId: number
    userId: number
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
  }

  export type CommunityMemberUpdateManyMutationInput = {
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type CommunityMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type PostCreateInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    community: CommunityCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    authorId: number
    communityId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    authorId: number
    communityId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    content: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: number
    postId: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    title: string
    description: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    creatorId: number
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creatorId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    title: string
    description: string
    creatorId: number
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creatorId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectMemberCreateInput = {
    role: $Enums.ProjectRole
    joinedDate?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    role: $Enums.ProjectRole
    joinedDate?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    role: $Enums.ProjectRole
    joinedDate?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorCreateInput = {
    organizationName: string
    contactPerson: string
    email: string
    phone?: string | null
    website?: string | null
    logo?: string | null
    description: string
    partnershipStart?: Date | string
    sponsorships?: SponsorshipCreateNestedManyWithoutSponsorInput
  }

  export type SponsorUncheckedCreateInput = {
    id?: number
    organizationName: string
    contactPerson: string
    email: string
    phone?: string | null
    website?: string | null
    logo?: string | null
    description: string
    partnershipStart?: Date | string
    sponsorships?: SponsorshipUncheckedCreateNestedManyWithoutSponsorInput
  }

  export type SponsorUpdateInput = {
    organizationName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    partnershipStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsorships?: SponsorshipUpdateManyWithoutSponsorNestedInput
  }

  export type SponsorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    partnershipStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsorships?: SponsorshipUncheckedUpdateManyWithoutSponsorNestedInput
  }

  export type SponsorCreateManyInput = {
    id?: number
    organizationName: string
    contactPerson: string
    email: string
    phone?: string | null
    website?: string | null
    logo?: string | null
    description: string
    partnershipStart?: Date | string
  }

  export type SponsorUpdateManyMutationInput = {
    organizationName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    partnershipStart?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    partnershipStart?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorshipCreateInput = {
    title: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    type: $Enums.SponsorshipType
    startDate: Date | string
    endDate?: Date | string | null
    sponsor: SponsorCreateNestedOneWithoutSponsorshipsInput
  }

  export type SponsorshipUncheckedCreateInput = {
    id?: number
    sponsorId: number
    title: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    type: $Enums.SponsorshipType
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type SponsorshipUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsor?: SponsorUpdateOneRequiredWithoutSponsorshipsNestedInput
  }

  export type SponsorshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sponsorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorshipCreateManyInput = {
    id?: number
    sponsorId: number
    title: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    type: $Enums.SponsorshipType
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type SponsorshipUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sponsorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AchievementCreateInput = {
    title: string
    description: string
    badgeImage: string
    points: number
    category: $Enums.AchievementCategory
    userAchievements?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    badgeImage: string
    points: number
    category: $Enums.AchievementCategory
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeImage?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    userAchievements?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeImage?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: number
    title: string
    description: string
    badgeImage: string
    points: number
    category: $Enums.AchievementCategory
  }

  export type AchievementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeImage?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeImage?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type UserAchievementCreateInput = {
    earnedDate?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: number
    userId: number
    achievementId: number
    earnedDate?: Date | string
  }

  export type UserAchievementUpdateInput = {
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    achievementId?: IntFieldUpdateOperationsInput | number
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: number
    userId: number
    achievementId: number
    earnedDate?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    achievementId?: IntFieldUpdateOperationsInput | number
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    type: $Enums.NotificationType
    actionUrl?: string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    type: $Enums.NotificationType
    actionUrl?: string | null
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    type: $Enums.NotificationType
    actionUrl?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResourceCreateInput = {
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploadDate?: Date | string
    isApproved?: boolean
    uploader: UserCreateNestedOneWithoutUploadedResourcesInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploaderId: number
    uploadDate?: Date | string
    isApproved?: boolean
  }

  export type ResourceUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    uploader?: UserUpdateOneRequiredWithoutUploadedResourcesNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploaderId?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResourceCreateManyInput = {
    id?: number
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploaderId: number
    uploadDate?: Date | string
    isApproved?: boolean
  }

  export type ResourceUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploaderId?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssessmentCreateInput = {
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutAssessmentsInput
    questions?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    attempts?: UserAssessmentAttemptCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    questions?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    attempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutAssessmentsNestedInput
    questions?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    attempts?: UserAssessmentAttemptUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    attempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentCreateManyInput = {
    id?: number
    courseId: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
  }

  export type AssessmentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentQuestionCreateInput = {
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    assessment: AssessmentCreateNestedOneWithoutQuestionsInput
  }

  export type AssessmentQuestionUncheckedCreateInput = {
    id?: number
    assessmentId: number
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
  }

  export type AssessmentQuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: AssessmentUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type AssessmentQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentQuestionCreateManyInput = {
    id?: number
    assessmentId: number
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
  }

  export type AssessmentQuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAssessmentAttemptCreateInput = {
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
    user: UserCreateNestedOneWithoutAssessmentAttemptsInput
    assessment: AssessmentCreateNestedOneWithoutAttemptsInput
  }

  export type UserAssessmentAttemptUncheckedCreateInput = {
    id?: number
    userId: number
    assessmentId: number
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
  }

  export type UserAssessmentAttemptUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAssessmentAttemptsNestedInput
    assessment?: AssessmentUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type UserAssessmentAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAssessmentAttemptCreateManyInput = {
    id?: number
    userId: number
    assessmentId: number
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
  }

  export type UserAssessmentAttemptUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAssessmentAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateInput = {
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment?: string | null
    createdAt?: Date | string
    provider: UserCreateNestedOneWithoutProvidedFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    providerId: number
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutProvidedFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    providerId?: IntFieldUpdateOperationsInput | number
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: number
    providerId: number
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    providerId?: IntFieldUpdateOperationsInput | number
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberCreateInput = {
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriberUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CourseReviewListRelationFilter = {
    every?: CourseReviewWhereInput
    some?: CourseReviewWhereInput
    none?: CourseReviewWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type UserSkillListRelationFilter = {
    every?: UserSkillWhereInput
    some?: UserSkillWhereInput
    none?: UserSkillWhereInput
  }

  export type MentorshipListRelationFilter = {
    every?: MentorshipWhereInput
    some?: MentorshipWhereInput
    none?: MentorshipWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type EventRegistrationListRelationFilter = {
    every?: EventRegistrationWhereInput
    some?: EventRegistrationWhereInput
    none?: EventRegistrationWhereInput
  }

  export type CommunityListRelationFilter = {
    every?: CommunityWhereInput
    some?: CommunityWhereInput
    none?: CommunityWhereInput
  }

  export type CommunityMemberListRelationFilter = {
    every?: CommunityMemberWhereInput
    some?: CommunityMemberWhereInput
    none?: CommunityMemberWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type UserAssessmentAttemptListRelationFilter = {
    every?: UserAssessmentAttemptWhereInput
    some?: UserAssessmentAttemptWhereInput
    none?: UserAssessmentAttemptWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type FlashcardInteractionListRelationFilter = {
    every?: FlashcardInteractionWhereInput
    some?: FlashcardInteractionWhereInput
    none?: FlashcardInteractionWhereInput
  }

  export type FlashcardListRelationFilter = {
    every?: FlashcardWhereInput
    some?: FlashcardWhereInput
    none?: FlashcardWhereInput
  }

  export type FlashcardCollectionListRelationFilter = {
    every?: FlashcardCollectionWhereInput
    some?: FlashcardCollectionWhereInput
    none?: FlashcardCollectionWhereInput
  }

  export type ChatbotSessionListRelationFilter = {
    every?: ChatbotSessionWhereInput
    some?: ChatbotSessionWhereInput
    none?: ChatbotSessionWhereInput
  }

  export type ChatbotFeedbackListRelationFilter = {
    every?: ChatbotFeedbackWhereInput
    some?: ChatbotFeedbackWhereInput
    none?: ChatbotFeedbackWhereInput
  }

  export type SavedAnswerListRelationFilter = {
    every?: SavedAnswerWhereInput
    some?: SavedAnswerWhereInput
    none?: SavedAnswerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAssessmentAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlashcardInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlashcardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlashcardCollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatbotSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatbotFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    gender?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationExpires?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    gender?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationExpires?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    gender?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationExpires?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type CourseModuleNullableScalarRelationFilter = {
    is?: CourseModuleWhereInput | null
    isNot?: CourseModuleWhereInput | null
  }

  export type FlashcardCollectionItemListRelationFilter = {
    every?: FlashcardCollectionItemWhereInput
    some?: FlashcardCollectionItemWhereInput
    none?: FlashcardCollectionItemWhereInput
  }

  export type FlashcardCollectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlashcardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    difficultyLevel?: SortOrder
    tags?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    lastReviewed?: SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrder
    aiModel?: SortOrder
    generationPrompt?: SortOrder
    sourceContentSnippet?: SortOrder
  }

  export type FlashcardAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    difficultyLevel?: SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type FlashcardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    difficultyLevel?: SortOrder
    tags?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    lastReviewed?: SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrder
    aiModel?: SortOrder
    generationPrompt?: SortOrder
    sourceContentSnippet?: SortOrder
  }

  export type FlashcardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    difficultyLevel?: SortOrder
    tags?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    lastReviewed?: SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrder
    aiModel?: SortOrder
    generationPrompt?: SortOrder
    sourceContentSnippet?: SortOrder
  }

  export type FlashcardSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    difficultyLevel?: SortOrder
    timesReviewed?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type FlashcardScalarRelationFilter = {
    is?: FlashcardWhereInput
    isNot?: FlashcardWhereInput
  }

  export type FlashcardInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    correct?: SortOrder
    responseTime?: SortOrder
    interactionDate?: SortOrder
  }

  export type FlashcardInteractionAvgOrderByAggregateInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    responseTime?: SortOrder
  }

  export type FlashcardInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    correct?: SortOrder
    responseTime?: SortOrder
    interactionDate?: SortOrder
  }

  export type FlashcardInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    correct?: SortOrder
    responseTime?: SortOrder
    interactionDate?: SortOrder
  }

  export type FlashcardInteractionSumOrderByAggregateInput = {
    id?: SortOrder
    flashcardId?: SortOrder
    userId?: SortOrder
    responseTime?: SortOrder
  }

  export type FlashcardCollectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    isPublic?: SortOrder
  }

  export type FlashcardCollectionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FlashcardCollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    isPublic?: SortOrder
  }

  export type FlashcardCollectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    isPublic?: SortOrder
  }

  export type FlashcardCollectionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FlashcardCollectionScalarRelationFilter = {
    is?: FlashcardCollectionWhereInput
    isNot?: FlashcardCollectionWhereInput
  }

  export type FlashcardCollectionItemCollectionIdFlashcardIdCompoundUniqueInput = {
    collectionId: number
    flashcardId: number
  }

  export type FlashcardCollectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
    addedAt?: SortOrder
  }

  export type FlashcardCollectionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
  }

  export type FlashcardCollectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
    addedAt?: SortOrder
  }

  export type FlashcardCollectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
    addedAt?: SortOrder
  }

  export type FlashcardCollectionItemSumOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    flashcardId?: SortOrder
  }

  export type ChatbotMessageListRelationFilter = {
    every?: ChatbotMessageWhereInput
    some?: ChatbotMessageWhereInput
    none?: ChatbotMessageWhereInput
  }

  export type ChatbotSessionAnalyticsNullableScalarRelationFilter = {
    is?: ChatbotSessionAnalyticsWhereInput | null
    isNot?: ChatbotSessionAnalyticsWhereInput | null
  }

  export type ChatbotMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatbotSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ChatbotSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ChatbotSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ChatbotSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ChatbotSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type ChatbotSessionScalarRelationFilter = {
    is?: ChatbotSessionWhereInput
    isNot?: ChatbotSessionWhereInput
  }

  export type ChatbotFeedbackNullableScalarRelationFilter = {
    is?: ChatbotFeedbackWhereInput | null
    isNot?: ChatbotFeedbackWhereInput | null
  }

  export type ChatbotMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    referencedContent?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
  }

  export type ChatbotMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
  }

  export type ChatbotMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    referencedContent?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
  }

  export type ChatbotMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    referencedContent?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
  }

  export type ChatbotMessageSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
  }

  export type EnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type ChatbotMessageScalarRelationFilter = {
    is?: ChatbotMessageWhereInput
    isNot?: ChatbotMessageWhereInput
  }

  export type ChatbotFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatbotFeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type ChatbotFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatbotFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatbotFeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type ChatbotSessionAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrder
    averageAiResponseLength?: SortOrder
    topicsDiscussed?: SortOrder
  }

  export type ChatbotSessionAnalyticsAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrder
    averageAiResponseLength?: SortOrder
  }

  export type ChatbotSessionAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrder
    averageAiResponseLength?: SortOrder
    topicsDiscussed?: SortOrder
  }

  export type ChatbotSessionAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrder
    averageAiResponseLength?: SortOrder
    topicsDiscussed?: SortOrder
  }

  export type ChatbotSessionAnalyticsSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageCount?: SortOrder
    userMessageCount?: SortOrder
    aiMessageCount?: SortOrder
    averageUserMessageLength?: SortOrder
    averageAiResponseLength?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SavedAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type SavedAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type SavedAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type SavedAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type SavedAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    icon?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    icon?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    icon?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type UserSkillUserIdSkillIdCompoundUniqueInput = {
    userId: number
    skillId: number
  }

  export type UserSkillCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    acquiredDate?: SortOrder
  }

  export type UserSkillAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
  }

  export type UserSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    acquiredDate?: SortOrder
  }

  export type UserSkillMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    acquiredDate?: SortOrder
  }

  export type UserSkillSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
  }

  export type EnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type EnumDifficultyLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDifficultyLevelNullableFilter<$PrismaModel> | $Enums.DifficultyLevel | null
  }

  export type CourseModuleListRelationFilter = {
    every?: CourseModuleWhereInput
    some?: CourseModuleWhereInput
    none?: CourseModuleWhereInput
  }

  export type LearningOutcomeListRelationFilter = {
    every?: LearningOutcomeWhereInput
    some?: LearningOutcomeWhereInput
    none?: LearningOutcomeWhereInput
  }

  export type CourseRequirementListRelationFilter = {
    every?: CourseRequirementWhereInput
    some?: CourseRequirementWhereInput
    none?: CourseRequirementWhereInput
  }

  export type AssessmentListRelationFilter = {
    every?: AssessmentWhereInput
    some?: AssessmentWhereInput
    none?: AssessmentWhereInput
  }

  export type CourseTagsListRelationFilter = {
    every?: CourseTagsWhereInput
    some?: CourseTagsWhereInput
    none?: CourseTagsWhereInput
  }

  export type CourseModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningOutcomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    overview?: SortOrder
    thumbnail?: SortOrder
    coverImage?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    instructorId?: SortOrder
    durationHours?: SortOrder
    isFeatured?: SortOrder
    isPublished?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    durationHours?: SortOrder
    enrollmentLimit?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    overview?: SortOrder
    thumbnail?: SortOrder
    coverImage?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    instructorId?: SortOrder
    durationHours?: SortOrder
    isFeatured?: SortOrder
    isPublished?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    overview?: SortOrder
    thumbnail?: SortOrder
    coverImage?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    instructorId?: SortOrder
    durationHours?: SortOrder
    isFeatured?: SortOrder
    isPublished?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    durationHours?: SortOrder
    enrollmentLimit?: SortOrder
  }

  export type EnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type EnumDifficultyLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDifficultyLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelNullableFilter<$PrismaModel>
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseTagsCourseIdNameCompoundUniqueInput = {
    courseId: number
    name: string
  }

  export type CourseTagsCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
  }

  export type CourseTagsAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type CourseTagsMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
  }

  export type CourseTagsMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
  }

  export type CourseTagsSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type LearningOutcomeCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
  }

  export type LearningOutcomeAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    orderNumber?: SortOrder
  }

  export type LearningOutcomeMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
  }

  export type LearningOutcomeMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
  }

  export type LearningOutcomeSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    orderNumber?: SortOrder
  }

  export type CourseRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
  }

  export type CourseRequirementAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    orderNumber?: SortOrder
  }

  export type CourseRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
  }

  export type CourseRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
  }

  export type CourseRequirementSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    orderNumber?: SortOrder
  }

  export type ContentUnitListRelationFilter = {
    every?: ContentUnitWhereInput
    some?: ContentUnitWhereInput
    none?: ContentUnitWhereInput
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type ModuleProgressListRelationFilter = {
    every?: ModuleProgressWhereInput
    some?: ModuleProgressWhereInput
    none?: ModuleProgressWhereInput
  }

  export type ContentUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseModuleCourseIdOrderNumberCompoundUniqueInput = {
    courseId: number
    orderNumber: number
  }

  export type CourseModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    estimatedHours?: SortOrder
    unlockCondition?: SortOrder
    thumbnail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseModuleAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    orderNumber?: SortOrder
    estimatedHours?: SortOrder
  }

  export type CourseModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    estimatedHours?: SortOrder
    unlockCondition?: SortOrder
    thumbnail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
    estimatedHours?: SortOrder
    unlockCondition?: SortOrder
    thumbnail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseModuleSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    orderNumber?: SortOrder
    estimatedHours?: SortOrder
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type CourseModuleScalarRelationFilter = {
    is?: CourseModuleWhereInput
    isNot?: CourseModuleWhereInput
  }

  export type UnitProgressListRelationFilter = {
    every?: UnitProgressWhereInput
    some?: UnitProgressWhereInput
    none?: UnitProgressWhereInput
  }

  export type UnitAttachmentListRelationFilter = {
    every?: UnitAttachmentWhereInput
    some?: UnitAttachmentWhereInput
    none?: UnitAttachmentWhereInput
  }

  export type UnitProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentUnitModuleIdOrderNumberCompoundUniqueInput = {
    moduleId: number
    orderNumber: number
  }

  export type ContentUnitCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrder
    isRequired?: SortOrder
    textContent?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fileUrl?: SortOrder
    externalUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentUnitAvgOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrder
  }

  export type ContentUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrder
    isRequired?: SortOrder
    textContent?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fileUrl?: SortOrder
    externalUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentUnitMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrder
    isRequired?: SortOrder
    textContent?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fileUrl?: SortOrder
    externalUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentUnitSumOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    orderNumber?: SortOrder
    estimatedMinutes?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type ContentUnitScalarRelationFilter = {
    is?: ContentUnitWhereInput
    isNot?: ContentUnitWhereInput
  }

  export type UnitAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
  }

  export type UnitAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
  }

  export type UnitAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
  }

  export type UnitAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
  }

  export type UnitAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
  }

  export type EnumEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusFilter<$PrismaModel> | $Enums.EnrollmentStatus
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type ExerciseSubmissionListRelationFilter = {
    every?: ExerciseSubmissionWhereInput
    some?: ExerciseSubmissionWhereInput
    none?: ExerciseSubmissionWhereInput
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentUserIdCourseIdCompoundUniqueInput = {
    userId: number
    courseId: number
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    completionDate?: SortOrder
    progressPercentage?: SortOrder
    lastAccessedAt?: SortOrder
    unenrollmentDate?: SortOrder
    unenrollmentReason?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progressPercentage?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    completionDate?: SortOrder
    progressPercentage?: SortOrder
    lastAccessedAt?: SortOrder
    unenrollmentDate?: SortOrder
    unenrollmentReason?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    completionDate?: SortOrder
    progressPercentage?: SortOrder
    lastAccessedAt?: SortOrder
    unenrollmentDate?: SortOrder
    unenrollmentReason?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progressPercentage?: SortOrder
  }

  export type EnumEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
  }

  export type EnrollmentScalarRelationFilter = {
    is?: EnrollmentWhereInput
    isNot?: EnrollmentWhereInput
  }

  export type ModuleProgressEnrollmentIdModuleIdCompoundUniqueInput = {
    enrollmentId: number
    moduleId: number
  }

  export type ModuleProgressCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    progressPercentage?: SortOrder
  }

  export type ModuleProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    progressPercentage?: SortOrder
  }

  export type ModuleProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    progressPercentage?: SortOrder
  }

  export type ModuleProgressMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    progressPercentage?: SortOrder
  }

  export type ModuleProgressSumOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    moduleId?: SortOrder
    userId?: SortOrder
    progressPercentage?: SortOrder
  }

  export type UnitProgressEnrollmentIdUnitIdCompoundUniqueInput = {
    enrollmentId: number
    unitId: number
  }

  export type UnitProgressCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpentMinutes?: SortOrder
    lastPosition?: SortOrder
  }

  export type UnitProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type UnitProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpentMinutes?: SortOrder
    lastPosition?: SortOrder
  }

  export type UnitProgressMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpentMinutes?: SortOrder
    lastPosition?: SortOrder
  }

  export type UnitProgressSumOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitId?: SortOrder
    userId?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    allowRetakes?: SortOrder
    maxAttempts?: SortOrder
    randomizeQuestions?: SortOrder
    showCorrectAnswers?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    maxAttempts?: SortOrder
    orderNumber?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    allowRetakes?: SortOrder
    maxAttempts?: SortOrder
    randomizeQuestions?: SortOrder
    showCorrectAnswers?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    allowRetakes?: SortOrder
    maxAttempts?: SortOrder
    randomizeQuestions?: SortOrder
    showCorrectAnswers?: SortOrder
    orderNumber?: SortOrder
    isPublished?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    maxAttempts?: SortOrder
    orderNumber?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuestionAnswerListRelationFilter = {
    every?: QuestionAnswerWhereInput
    some?: QuestionAnswerWhereInput
    none?: QuestionAnswerWhereInput
  }

  export type QuestionAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    percentage?: SortOrder
    passed?: SortOrder
    attemptNumber?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    percentage?: SortOrder
    attemptNumber?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    percentage?: SortOrder
    passed?: SortOrder
    attemptNumber?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    percentage?: SortOrder
    passed?: SortOrder
    attemptNumber?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    percentage?: SortOrder
    attemptNumber?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type QuizAttemptScalarRelationFilter = {
    is?: QuizAttemptWhereInput
    isNot?: QuizAttemptWhereInput
  }

  export type QuizQuestionScalarRelationFilter = {
    is?: QuizQuestionWhereInput
    isNot?: QuizQuestionWhereInput
  }

  export type QuestionAnswerAttemptIdQuestionIdCompoundUniqueInput = {
    attemptId: number
    questionId: number
  }

  export type QuestionAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userAnswer?: SortOrder
    isCorrect?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type QuestionAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type QuestionAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userAnswer?: SortOrder
    isCorrect?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type QuestionAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userAnswer?: SortOrder
    isCorrect?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type QuestionAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    pointsAwarded?: SortOrder
  }

  export type EnumExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeFilter<$PrismaModel> | $Enums.ExerciseType
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    exerciseType?: SortOrder
    orderNumber?: SortOrder
    dueDate?: SortOrder
    allowLateSubmissions?: SortOrder
    maxScore?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    orderNumber?: SortOrder
    maxScore?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    exerciseType?: SortOrder
    orderNumber?: SortOrder
    dueDate?: SortOrder
    allowLateSubmissions?: SortOrder
    maxScore?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    exerciseType?: SortOrder
    orderNumber?: SortOrder
    dueDate?: SortOrder
    allowLateSubmissions?: SortOrder
    maxScore?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    orderNumber?: SortOrder
    maxScore?: SortOrder
  }

  export type EnumExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeFilter<$PrismaModel>
  }

  export type ExerciseScalarRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type ExerciseSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    submittedAt?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    gradedAt?: SortOrder
    gradedBy?: SortOrder
  }

  export type ExerciseSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    gradedBy?: SortOrder
  }

  export type ExerciseSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    submittedAt?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    gradedAt?: SortOrder
    gradedBy?: SortOrder
  }

  export type ExerciseSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    submittedAt?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    gradedAt?: SortOrder
    gradedBy?: SortOrder
  }

  export type ExerciseSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    enrollmentId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    gradedBy?: SortOrder
  }

  export type CourseReviewUserIdCourseIdCompoundUniqueInput = {
    userId: number
    courseId: number
  }

  export type CourseReviewCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type CourseReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type CourseReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type CourseReviewMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type CourseReviewSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type MentorshipProgramCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    isActive?: SortOrder
  }

  export type MentorshipProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    maxMentees?: SortOrder
  }

  export type MentorshipProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    isActive?: SortOrder
  }

  export type MentorshipProgramMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxMentees?: SortOrder
    isActive?: SortOrder
  }

  export type MentorshipProgramSumOrderByAggregateInput = {
    id?: SortOrder
    maxMentees?: SortOrder
  }

  export type EnumStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeFilter<$PrismaModel> | $Enums.StatusType
  }

  export type MentorshipProgramNullableScalarRelationFilter = {
    is?: MentorshipProgramWhereInput | null
    isNot?: MentorshipProgramWhereInput | null
  }

  export type MentorshipSessionListRelationFilter = {
    every?: MentorshipSessionWhereInput
    some?: MentorshipSessionWhereInput
    none?: MentorshipSessionWhereInput
  }

  export type MentorshipSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorshipCountOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type MentorshipAvgOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrder
  }

  export type MentorshipMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type MentorshipMinOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type MentorshipSumOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    menteeId?: SortOrder
    programId?: SortOrder
  }

  export type EnumStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStatusTypeFilter<$PrismaModel>
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type MentorshipScalarRelationFilter = {
    is?: MentorshipWhereInput
    isNot?: MentorshipWhereInput
  }

  export type MentorshipSessionCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
  }

  export type MentorshipSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    durationMinutes?: SortOrder
  }

  export type MentorshipSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
  }

  export type MentorshipSessionMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
  }

  export type MentorshipSessionSumOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    durationMinutes?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    virtualLink?: SortOrder
    isVirtual?: SortOrder
    maxParticipants?: SortOrder
    thumbnail?: SortOrder
    registrationDeadline?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
    maxParticipants?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    virtualLink?: SortOrder
    isVirtual?: SortOrder
    maxParticipants?: SortOrder
    thumbnail?: SortOrder
    registrationDeadline?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    virtualLink?: SortOrder
    isVirtual?: SortOrder
    maxParticipants?: SortOrder
    thumbnail?: SortOrder
    registrationDeadline?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
    maxParticipants?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventRegistrationEventIdUserIdCompoundUniqueInput = {
    eventId: number
    userId: number
  }

  export type EventRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    attendanceConfirmed?: SortOrder
  }

  export type EventRegistrationAvgOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
  }

  export type EventRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    attendanceConfirmed?: SortOrder
  }

  export type EventRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registrationDate?: SortOrder
    attendanceConfirmed?: SortOrder
  }

  export type EventRegistrationSumOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    isPrivate?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    isPrivate?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    isPrivate?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type EnumCommunityRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunityRole | EnumCommunityRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunityRoleFilter<$PrismaModel> | $Enums.CommunityRole
  }

  export type CommunityScalarRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type CommunityMemberCommunityIdUserIdCompoundUniqueInput = {
    communityId: number
    userId: number
  }

  export type CommunityMemberCountOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
    joinedDate?: SortOrder
    role?: SortOrder
  }

  export type CommunityMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
  }

  export type CommunityMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
    joinedDate?: SortOrder
    role?: SortOrder
  }

  export type CommunityMemberMinOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
    joinedDate?: SortOrder
    role?: SortOrder
  }

  export type CommunityMemberSumOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    userId?: SortOrder
  }

  export type EnumCommunityRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunityRole | EnumCommunityRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunityRoleWithAggregatesFilter<$PrismaModel> | $Enums.CommunityRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunityRoleFilter<$PrismaModel>
    _max?: NestedEnumCommunityRoleFilter<$PrismaModel>
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    githubUrl?: SortOrder
    demoUrl?: SortOrder
    thumbnail?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    githubUrl?: SortOrder
    demoUrl?: SortOrder
    thumbnail?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    githubUrl?: SortOrder
    demoUrl?: SortOrder
    thumbnail?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: number
    userId: number
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedDate?: SortOrder
  }

  export type ProjectMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedDate?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedDate?: SortOrder
  }

  export type ProjectMemberSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type SponsorshipListRelationFilter = {
    every?: SponsorshipWhereInput
    some?: SponsorshipWhereInput
    none?: SponsorshipWhereInput
  }

  export type SponsorshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SponsorCountOrderByAggregateInput = {
    id?: SortOrder
    organizationName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    partnershipStart?: SortOrder
  }

  export type SponsorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SponsorMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    partnershipStart?: SortOrder
  }

  export type SponsorMinOrderByAggregateInput = {
    id?: SortOrder
    organizationName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    partnershipStart?: SortOrder
  }

  export type SponsorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumSponsorshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsorshipType | EnumSponsorshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsorshipTypeFilter<$PrismaModel> | $Enums.SponsorshipType
  }

  export type SponsorScalarRelationFilter = {
    is?: SponsorWhereInput
    isNot?: SponsorWhereInput
  }

  export type SponsorshipCountOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SponsorshipAvgOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    amount?: SortOrder
  }

  export type SponsorshipMaxOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SponsorshipMinOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SponsorshipSumOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumSponsorshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsorshipType | EnumSponsorshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsorshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.SponsorshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSponsorshipTypeFilter<$PrismaModel>
    _max?: NestedEnumSponsorshipTypeFilter<$PrismaModel>
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeImage?: SortOrder
    points?: SortOrder
    category?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeImage?: SortOrder
    points?: SortOrder
    category?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeImage?: SortOrder
    points?: SortOrder
    category?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: number
    achievementId: number
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    actionUrl?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    actionUrl?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    actionUrl?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploaderId?: SortOrder
    uploadDate?: SortOrder
    isApproved?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    uploaderId?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploaderId?: SortOrder
    uploadDate?: SortOrder
    isApproved?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploaderId?: SortOrder
    uploadDate?: SortOrder
    isApproved?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
    uploaderId?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type AssessmentQuestionListRelationFilter = {
    every?: AssessmentQuestionWhereInput
    some?: AssessmentQuestionWhereInput
    none?: AssessmentQuestionWhereInput
  }

  export type AssessmentQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
  }

  export type AssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalPoints?: SortOrder
    passingPoints?: SortOrder
  }

  export type AssessmentScalarRelationFilter = {
    is?: AssessmentWhereInput
    isNot?: AssessmentWhereInput
  }

  export type AssessmentQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
  }

  export type AssessmentQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    points?: SortOrder
    orderNumber?: SortOrder
  }

  export type UserAssessmentAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    attemptDate?: SortOrder
    attemptNumber?: SortOrder
    answers?: SortOrder
  }

  export type UserAssessmentAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    attemptNumber?: SortOrder
  }

  export type UserAssessmentAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    attemptDate?: SortOrder
    attemptNumber?: SortOrder
    answers?: SortOrder
  }

  export type UserAssessmentAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    attemptDate?: SortOrder
    attemptNumber?: SortOrder
    answers?: SortOrder
  }

  export type UserAssessmentAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    attemptNumber?: SortOrder
  }

  export type EnumFeedbackTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackTarget | EnumFeedbackTargetFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTargetFilter<$PrismaModel> | $Enums.FeedbackTarget
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    targetId?: SortOrder
    rating?: SortOrder
  }

  export type EnumFeedbackTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackTarget | EnumFeedbackTargetFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTargetWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTargetFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTargetFilter<$PrismaModel>
  }

  export type SubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CourseReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type UserSkillCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type MentorshipCreateNestedManyWithoutMenteeInput = {
    create?: XOR<MentorshipCreateWithoutMenteeInput, MentorshipUncheckedCreateWithoutMenteeInput> | MentorshipCreateWithoutMenteeInput[] | MentorshipUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMenteeInput | MentorshipCreateOrConnectWithoutMenteeInput[]
    createMany?: MentorshipCreateManyMenteeInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutInstructorInput = {
    create?: XOR<CourseCreateWithoutInstructorInput, CourseUncheckedCreateWithoutInstructorInput> | CourseCreateWithoutInstructorInput[] | CourseUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorInput | CourseCreateOrConnectWithoutInstructorInput[]
    createMany?: CourseCreateManyInstructorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EventRegistrationCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type CommunityCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CommunityCreateWithoutCreatorInput, CommunityUncheckedCreateWithoutCreatorInput> | CommunityCreateWithoutCreatorInput[] | CommunityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCreatorInput | CommunityCreateOrConnectWithoutCreatorInput[]
    createMany?: CommunityCreateManyCreatorInputEnvelope
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type CommunityMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutUploaderInput = {
    create?: XOR<ResourceCreateWithoutUploaderInput, ResourceUncheckedCreateWithoutUploaderInput> | ResourceCreateWithoutUploaderInput[] | ResourceUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploaderInput | ResourceCreateOrConnectWithoutUploaderInput[]
    createMany?: ResourceCreateManyUploaderInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type UserAssessmentAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutUserInput, UserAssessmentAttemptUncheckedCreateWithoutUserInput> | UserAssessmentAttemptCreateWithoutUserInput[] | UserAssessmentAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutUserInput | UserAssessmentAttemptCreateOrConnectWithoutUserInput[]
    createMany?: UserAssessmentAttemptCreateManyUserInputEnvelope
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutProviderInput = {
    create?: XOR<FeedbackCreateWithoutProviderInput, FeedbackUncheckedCreateWithoutProviderInput> | FeedbackCreateWithoutProviderInput[] | FeedbackUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutProviderInput | FeedbackCreateOrConnectWithoutProviderInput[]
    createMany?: FeedbackCreateManyProviderInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FlashcardInteractionCreateNestedManyWithoutUserInput = {
    create?: XOR<FlashcardInteractionCreateWithoutUserInput, FlashcardInteractionUncheckedCreateWithoutUserInput> | FlashcardInteractionCreateWithoutUserInput[] | FlashcardInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutUserInput | FlashcardInteractionCreateOrConnectWithoutUserInput[]
    createMany?: FlashcardInteractionCreateManyUserInputEnvelope
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
  }

  export type FlashcardCreateNestedManyWithoutUserInput = {
    create?: XOR<FlashcardCreateWithoutUserInput, FlashcardUncheckedCreateWithoutUserInput> | FlashcardCreateWithoutUserInput[] | FlashcardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutUserInput | FlashcardCreateOrConnectWithoutUserInput[]
    createMany?: FlashcardCreateManyUserInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type FlashcardCollectionCreateNestedManyWithoutUserInput = {
    create?: XOR<FlashcardCollectionCreateWithoutUserInput, FlashcardCollectionUncheckedCreateWithoutUserInput> | FlashcardCollectionCreateWithoutUserInput[] | FlashcardCollectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCollectionCreateOrConnectWithoutUserInput | FlashcardCollectionCreateOrConnectWithoutUserInput[]
    createMany?: FlashcardCollectionCreateManyUserInputEnvelope
    connect?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
  }

  export type ChatbotSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatbotSessionCreateWithoutUserInput, ChatbotSessionUncheckedCreateWithoutUserInput> | ChatbotSessionCreateWithoutUserInput[] | ChatbotSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutUserInput | ChatbotSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatbotSessionCreateManyUserInputEnvelope
    connect?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
  }

  export type ChatbotFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutUserInput, ChatbotFeedbackUncheckedCreateWithoutUserInput> | ChatbotFeedbackCreateWithoutUserInput[] | ChatbotFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutUserInput | ChatbotFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: ChatbotFeedbackCreateManyUserInputEnvelope
    connect?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
  }

  export type SavedAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedAnswerCreateWithoutUserInput, SavedAnswerUncheckedCreateWithoutUserInput> | SavedAnswerCreateWithoutUserInput[] | SavedAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutUserInput | SavedAnswerCreateOrConnectWithoutUserInput[]
    createMany?: SavedAnswerCreateManyUserInputEnvelope
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
  }

  export type CourseReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type UserSkillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type MentorshipUncheckedCreateNestedManyWithoutMenteeInput = {
    create?: XOR<MentorshipCreateWithoutMenteeInput, MentorshipUncheckedCreateWithoutMenteeInput> | MentorshipCreateWithoutMenteeInput[] | MentorshipUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMenteeInput | MentorshipCreateOrConnectWithoutMenteeInput[]
    createMany?: MentorshipCreateManyMenteeInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<CourseCreateWithoutInstructorInput, CourseUncheckedCreateWithoutInstructorInput> | CourseCreateWithoutInstructorInput[] | CourseUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorInput | CourseCreateOrConnectWithoutInstructorInput[]
    createMany?: CourseCreateManyInstructorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type CommunityUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CommunityCreateWithoutCreatorInput, CommunityUncheckedCreateWithoutCreatorInput> | CommunityCreateWithoutCreatorInput[] | CommunityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCreatorInput | CommunityCreateOrConnectWithoutCreatorInput[]
    createMany?: CommunityCreateManyCreatorInputEnvelope
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type CommunityMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<ResourceCreateWithoutUploaderInput, ResourceUncheckedCreateWithoutUploaderInput> | ResourceCreateWithoutUploaderInput[] | ResourceUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploaderInput | ResourceCreateOrConnectWithoutUploaderInput[]
    createMany?: ResourceCreateManyUploaderInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutUserInput, UserAssessmentAttemptUncheckedCreateWithoutUserInput> | UserAssessmentAttemptCreateWithoutUserInput[] | UserAssessmentAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutUserInput | UserAssessmentAttemptCreateOrConnectWithoutUserInput[]
    createMany?: UserAssessmentAttemptCreateManyUserInputEnvelope
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<FeedbackCreateWithoutProviderInput, FeedbackUncheckedCreateWithoutProviderInput> | FeedbackCreateWithoutProviderInput[] | FeedbackUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutProviderInput | FeedbackCreateOrConnectWithoutProviderInput[]
    createMany?: FeedbackCreateManyProviderInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlashcardInteractionCreateWithoutUserInput, FlashcardInteractionUncheckedCreateWithoutUserInput> | FlashcardInteractionCreateWithoutUserInput[] | FlashcardInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutUserInput | FlashcardInteractionCreateOrConnectWithoutUserInput[]
    createMany?: FlashcardInteractionCreateManyUserInputEnvelope
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
  }

  export type FlashcardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlashcardCreateWithoutUserInput, FlashcardUncheckedCreateWithoutUserInput> | FlashcardCreateWithoutUserInput[] | FlashcardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutUserInput | FlashcardCreateOrConnectWithoutUserInput[]
    createMany?: FlashcardCreateManyUserInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlashcardCollectionCreateWithoutUserInput, FlashcardCollectionUncheckedCreateWithoutUserInput> | FlashcardCollectionCreateWithoutUserInput[] | FlashcardCollectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCollectionCreateOrConnectWithoutUserInput | FlashcardCollectionCreateOrConnectWithoutUserInput[]
    createMany?: FlashcardCollectionCreateManyUserInputEnvelope
    connect?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
  }

  export type ChatbotSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatbotSessionCreateWithoutUserInput, ChatbotSessionUncheckedCreateWithoutUserInput> | ChatbotSessionCreateWithoutUserInput[] | ChatbotSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutUserInput | ChatbotSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatbotSessionCreateManyUserInputEnvelope
    connect?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
  }

  export type ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutUserInput, ChatbotFeedbackUncheckedCreateWithoutUserInput> | ChatbotFeedbackCreateWithoutUserInput[] | ChatbotFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutUserInput | ChatbotFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: ChatbotFeedbackCreateManyUserInputEnvelope
    connect?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
  }

  export type SavedAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedAnswerCreateWithoutUserInput, SavedAnswerUncheckedCreateWithoutUserInput> | SavedAnswerCreateWithoutUserInput[] | SavedAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutUserInput | SavedAnswerCreateOrConnectWithoutUserInput[]
    createMany?: SavedAnswerCreateManyUserInputEnvelope
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourseReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutUserInput | CourseReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutUserInput | CourseReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutUserInput | CourseReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type UserSkillUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutUserInput | UserSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutUserInput | UserSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutUserInput | UserSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type MentorshipUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<MentorshipCreateWithoutMenteeInput, MentorshipUncheckedCreateWithoutMenteeInput> | MentorshipCreateWithoutMenteeInput[] | MentorshipUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMenteeInput | MentorshipCreateOrConnectWithoutMenteeInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutMenteeInput | MentorshipUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: MentorshipCreateManyMenteeInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutMenteeInput | MentorshipUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutMenteeInput | MentorshipUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type MentorshipUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutMentorInput | MentorshipUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutMentorInput | MentorshipUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutMentorInput | MentorshipUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<CourseCreateWithoutInstructorInput, CourseUncheckedCreateWithoutInstructorInput> | CourseCreateWithoutInstructorInput[] | CourseUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorInput | CourseCreateOrConnectWithoutInstructorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutInstructorInput | CourseUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: CourseCreateManyInstructorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutInstructorInput | CourseUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutInstructorInput | CourseUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EventRegistrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutUserInput | EventRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutUserInput | EventRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutUserInput | EventRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type CommunityUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CommunityCreateWithoutCreatorInput, CommunityUncheckedCreateWithoutCreatorInput> | CommunityCreateWithoutCreatorInput[] | CommunityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCreatorInput | CommunityCreateOrConnectWithoutCreatorInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutCreatorInput | CommunityUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CommunityCreateManyCreatorInputEnvelope
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutCreatorInput | CommunityUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutCreatorInput | CommunityUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type CommunityMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutUserInput | CommunityMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutUserInput | CommunityMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutUserInput | CommunityMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<ResourceCreateWithoutUploaderInput, ResourceUncheckedCreateWithoutUploaderInput> | ResourceCreateWithoutUploaderInput[] | ResourceUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploaderInput | ResourceCreateOrConnectWithoutUploaderInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUploaderInput | ResourceUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: ResourceCreateManyUploaderInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUploaderInput | ResourceUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUploaderInput | ResourceUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type UserAssessmentAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutUserInput, UserAssessmentAttemptUncheckedCreateWithoutUserInput> | UserAssessmentAttemptCreateWithoutUserInput[] | UserAssessmentAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutUserInput | UserAssessmentAttemptCreateOrConnectWithoutUserInput[]
    upsert?: UserAssessmentAttemptUpsertWithWhereUniqueWithoutUserInput | UserAssessmentAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAssessmentAttemptCreateManyUserInputEnvelope
    set?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    disconnect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    delete?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    update?: UserAssessmentAttemptUpdateWithWhereUniqueWithoutUserInput | UserAssessmentAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAssessmentAttemptUpdateManyWithWhereWithoutUserInput | UserAssessmentAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAssessmentAttemptScalarWhereInput | UserAssessmentAttemptScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutProviderNestedInput = {
    create?: XOR<FeedbackCreateWithoutProviderInput, FeedbackUncheckedCreateWithoutProviderInput> | FeedbackCreateWithoutProviderInput[] | FeedbackUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutProviderInput | FeedbackCreateOrConnectWithoutProviderInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutProviderInput | FeedbackUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: FeedbackCreateManyProviderInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutProviderInput | FeedbackUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutProviderInput | FeedbackUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FlashcardInteractionUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlashcardInteractionCreateWithoutUserInput, FlashcardInteractionUncheckedCreateWithoutUserInput> | FlashcardInteractionCreateWithoutUserInput[] | FlashcardInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutUserInput | FlashcardInteractionCreateOrConnectWithoutUserInput[]
    upsert?: FlashcardInteractionUpsertWithWhereUniqueWithoutUserInput | FlashcardInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlashcardInteractionCreateManyUserInputEnvelope
    set?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    disconnect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    delete?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    update?: FlashcardInteractionUpdateWithWhereUniqueWithoutUserInput | FlashcardInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlashcardInteractionUpdateManyWithWhereWithoutUserInput | FlashcardInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlashcardInteractionScalarWhereInput | FlashcardInteractionScalarWhereInput[]
  }

  export type FlashcardUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlashcardCreateWithoutUserInput, FlashcardUncheckedCreateWithoutUserInput> | FlashcardCreateWithoutUserInput[] | FlashcardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutUserInput | FlashcardCreateOrConnectWithoutUserInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutUserInput | FlashcardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlashcardCreateManyUserInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutUserInput | FlashcardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutUserInput | FlashcardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type FlashcardCollectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlashcardCollectionCreateWithoutUserInput, FlashcardCollectionUncheckedCreateWithoutUserInput> | FlashcardCollectionCreateWithoutUserInput[] | FlashcardCollectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCollectionCreateOrConnectWithoutUserInput | FlashcardCollectionCreateOrConnectWithoutUserInput[]
    upsert?: FlashcardCollectionUpsertWithWhereUniqueWithoutUserInput | FlashcardCollectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlashcardCollectionCreateManyUserInputEnvelope
    set?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    disconnect?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    delete?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    connect?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    update?: FlashcardCollectionUpdateWithWhereUniqueWithoutUserInput | FlashcardCollectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlashcardCollectionUpdateManyWithWhereWithoutUserInput | FlashcardCollectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlashcardCollectionScalarWhereInput | FlashcardCollectionScalarWhereInput[]
  }

  export type ChatbotSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatbotSessionCreateWithoutUserInput, ChatbotSessionUncheckedCreateWithoutUserInput> | ChatbotSessionCreateWithoutUserInput[] | ChatbotSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutUserInput | ChatbotSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatbotSessionUpsertWithWhereUniqueWithoutUserInput | ChatbotSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatbotSessionCreateManyUserInputEnvelope
    set?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    disconnect?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    delete?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    connect?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    update?: ChatbotSessionUpdateWithWhereUniqueWithoutUserInput | ChatbotSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatbotSessionUpdateManyWithWhereWithoutUserInput | ChatbotSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatbotSessionScalarWhereInput | ChatbotSessionScalarWhereInput[]
  }

  export type ChatbotFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutUserInput, ChatbotFeedbackUncheckedCreateWithoutUserInput> | ChatbotFeedbackCreateWithoutUserInput[] | ChatbotFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutUserInput | ChatbotFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: ChatbotFeedbackUpsertWithWhereUniqueWithoutUserInput | ChatbotFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatbotFeedbackCreateManyUserInputEnvelope
    set?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    disconnect?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    delete?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    connect?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    update?: ChatbotFeedbackUpdateWithWhereUniqueWithoutUserInput | ChatbotFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatbotFeedbackUpdateManyWithWhereWithoutUserInput | ChatbotFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatbotFeedbackScalarWhereInput | ChatbotFeedbackScalarWhereInput[]
  }

  export type SavedAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedAnswerCreateWithoutUserInput, SavedAnswerUncheckedCreateWithoutUserInput> | SavedAnswerCreateWithoutUserInput[] | SavedAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutUserInput | SavedAnswerCreateOrConnectWithoutUserInput[]
    upsert?: SavedAnswerUpsertWithWhereUniqueWithoutUserInput | SavedAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedAnswerCreateManyUserInputEnvelope
    set?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    disconnect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    delete?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    update?: SavedAnswerUpdateWithWhereUniqueWithoutUserInput | SavedAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedAnswerUpdateManyWithWhereWithoutUserInput | SavedAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedAnswerScalarWhereInput | SavedAnswerScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput> | CourseReviewCreateWithoutUserInput[] | CourseReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutUserInput | CourseReviewCreateOrConnectWithoutUserInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutUserInput | CourseReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseReviewCreateManyUserInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutUserInput | CourseReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutUserInput | CourseReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type UserSkillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutUserInput | UserSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutUserInput | UserSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutUserInput | UserSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type MentorshipUncheckedUpdateManyWithoutMenteeNestedInput = {
    create?: XOR<MentorshipCreateWithoutMenteeInput, MentorshipUncheckedCreateWithoutMenteeInput> | MentorshipCreateWithoutMenteeInput[] | MentorshipUncheckedCreateWithoutMenteeInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMenteeInput | MentorshipCreateOrConnectWithoutMenteeInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutMenteeInput | MentorshipUpsertWithWhereUniqueWithoutMenteeInput[]
    createMany?: MentorshipCreateManyMenteeInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutMenteeInput | MentorshipUpdateWithWhereUniqueWithoutMenteeInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutMenteeInput | MentorshipUpdateManyWithWhereWithoutMenteeInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type MentorshipUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput> | MentorshipCreateWithoutMentorInput[] | MentorshipUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutMentorInput | MentorshipCreateOrConnectWithoutMentorInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutMentorInput | MentorshipUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorshipCreateManyMentorInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutMentorInput | MentorshipUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutMentorInput | MentorshipUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<CourseCreateWithoutInstructorInput, CourseUncheckedCreateWithoutInstructorInput> | CourseCreateWithoutInstructorInput[] | CourseUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorInput | CourseCreateOrConnectWithoutInstructorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutInstructorInput | CourseUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: CourseCreateManyInstructorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutInstructorInput | CourseUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutInstructorInput | CourseUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutUserInput | EventRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutUserInput | EventRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutUserInput | EventRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type CommunityUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CommunityCreateWithoutCreatorInput, CommunityUncheckedCreateWithoutCreatorInput> | CommunityCreateWithoutCreatorInput[] | CommunityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutCreatorInput | CommunityCreateOrConnectWithoutCreatorInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutCreatorInput | CommunityUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CommunityCreateManyCreatorInputEnvelope
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutCreatorInput | CommunityUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutCreatorInput | CommunityUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type CommunityMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutUserInput | CommunityMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutUserInput | CommunityMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutUserInput | CommunityMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<ResourceCreateWithoutUploaderInput, ResourceUncheckedCreateWithoutUploaderInput> | ResourceCreateWithoutUploaderInput[] | ResourceUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploaderInput | ResourceCreateOrConnectWithoutUploaderInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUploaderInput | ResourceUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: ResourceCreateManyUploaderInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUploaderInput | ResourceUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUploaderInput | ResourceUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutUserInput, UserAssessmentAttemptUncheckedCreateWithoutUserInput> | UserAssessmentAttemptCreateWithoutUserInput[] | UserAssessmentAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutUserInput | UserAssessmentAttemptCreateOrConnectWithoutUserInput[]
    upsert?: UserAssessmentAttemptUpsertWithWhereUniqueWithoutUserInput | UserAssessmentAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAssessmentAttemptCreateManyUserInputEnvelope
    set?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    disconnect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    delete?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    update?: UserAssessmentAttemptUpdateWithWhereUniqueWithoutUserInput | UserAssessmentAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAssessmentAttemptUpdateManyWithWhereWithoutUserInput | UserAssessmentAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAssessmentAttemptScalarWhereInput | UserAssessmentAttemptScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<FeedbackCreateWithoutProviderInput, FeedbackUncheckedCreateWithoutProviderInput> | FeedbackCreateWithoutProviderInput[] | FeedbackUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutProviderInput | FeedbackCreateOrConnectWithoutProviderInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutProviderInput | FeedbackUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: FeedbackCreateManyProviderInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutProviderInput | FeedbackUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutProviderInput | FeedbackUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlashcardInteractionCreateWithoutUserInput, FlashcardInteractionUncheckedCreateWithoutUserInput> | FlashcardInteractionCreateWithoutUserInput[] | FlashcardInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutUserInput | FlashcardInteractionCreateOrConnectWithoutUserInput[]
    upsert?: FlashcardInteractionUpsertWithWhereUniqueWithoutUserInput | FlashcardInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlashcardInteractionCreateManyUserInputEnvelope
    set?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    disconnect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    delete?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    update?: FlashcardInteractionUpdateWithWhereUniqueWithoutUserInput | FlashcardInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlashcardInteractionUpdateManyWithWhereWithoutUserInput | FlashcardInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlashcardInteractionScalarWhereInput | FlashcardInteractionScalarWhereInput[]
  }

  export type FlashcardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlashcardCreateWithoutUserInput, FlashcardUncheckedCreateWithoutUserInput> | FlashcardCreateWithoutUserInput[] | FlashcardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutUserInput | FlashcardCreateOrConnectWithoutUserInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutUserInput | FlashcardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlashcardCreateManyUserInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutUserInput | FlashcardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutUserInput | FlashcardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlashcardCollectionCreateWithoutUserInput, FlashcardCollectionUncheckedCreateWithoutUserInput> | FlashcardCollectionCreateWithoutUserInput[] | FlashcardCollectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlashcardCollectionCreateOrConnectWithoutUserInput | FlashcardCollectionCreateOrConnectWithoutUserInput[]
    upsert?: FlashcardCollectionUpsertWithWhereUniqueWithoutUserInput | FlashcardCollectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlashcardCollectionCreateManyUserInputEnvelope
    set?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    disconnect?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    delete?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    connect?: FlashcardCollectionWhereUniqueInput | FlashcardCollectionWhereUniqueInput[]
    update?: FlashcardCollectionUpdateWithWhereUniqueWithoutUserInput | FlashcardCollectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlashcardCollectionUpdateManyWithWhereWithoutUserInput | FlashcardCollectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlashcardCollectionScalarWhereInput | FlashcardCollectionScalarWhereInput[]
  }

  export type ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatbotSessionCreateWithoutUserInput, ChatbotSessionUncheckedCreateWithoutUserInput> | ChatbotSessionCreateWithoutUserInput[] | ChatbotSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutUserInput | ChatbotSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatbotSessionUpsertWithWhereUniqueWithoutUserInput | ChatbotSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatbotSessionCreateManyUserInputEnvelope
    set?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    disconnect?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    delete?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    connect?: ChatbotSessionWhereUniqueInput | ChatbotSessionWhereUniqueInput[]
    update?: ChatbotSessionUpdateWithWhereUniqueWithoutUserInput | ChatbotSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatbotSessionUpdateManyWithWhereWithoutUserInput | ChatbotSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatbotSessionScalarWhereInput | ChatbotSessionScalarWhereInput[]
  }

  export type ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutUserInput, ChatbotFeedbackUncheckedCreateWithoutUserInput> | ChatbotFeedbackCreateWithoutUserInput[] | ChatbotFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutUserInput | ChatbotFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: ChatbotFeedbackUpsertWithWhereUniqueWithoutUserInput | ChatbotFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatbotFeedbackCreateManyUserInputEnvelope
    set?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    disconnect?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    delete?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    connect?: ChatbotFeedbackWhereUniqueInput | ChatbotFeedbackWhereUniqueInput[]
    update?: ChatbotFeedbackUpdateWithWhereUniqueWithoutUserInput | ChatbotFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatbotFeedbackUpdateManyWithWhereWithoutUserInput | ChatbotFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatbotFeedbackScalarWhereInput | ChatbotFeedbackScalarWhereInput[]
  }

  export type SavedAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedAnswerCreateWithoutUserInput, SavedAnswerUncheckedCreateWithoutUserInput> | SavedAnswerCreateWithoutUserInput[] | SavedAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutUserInput | SavedAnswerCreateOrConnectWithoutUserInput[]
    upsert?: SavedAnswerUpsertWithWhereUniqueWithoutUserInput | SavedAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedAnswerCreateManyUserInputEnvelope
    set?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    disconnect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    delete?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    update?: SavedAnswerUpdateWithWhereUniqueWithoutUserInput | SavedAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedAnswerUpdateManyWithWhereWithoutUserInput | SavedAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedAnswerScalarWhereInput | SavedAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFlashcardsInput = {
    create?: XOR<UserCreateWithoutFlashcardsInput, UserUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlashcardsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutFlashcardsInput = {
    create?: XOR<CourseCreateWithoutFlashcardsInput, CourseUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFlashcardsInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseModuleCreateNestedOneWithoutFlashcardsInput = {
    create?: XOR<CourseModuleCreateWithoutFlashcardsInput, CourseModuleUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutFlashcardsInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type FlashcardInteractionCreateNestedManyWithoutFlashcardInput = {
    create?: XOR<FlashcardInteractionCreateWithoutFlashcardInput, FlashcardInteractionUncheckedCreateWithoutFlashcardInput> | FlashcardInteractionCreateWithoutFlashcardInput[] | FlashcardInteractionUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutFlashcardInput | FlashcardInteractionCreateOrConnectWithoutFlashcardInput[]
    createMany?: FlashcardInteractionCreateManyFlashcardInputEnvelope
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
  }

  export type FlashcardCollectionItemCreateNestedManyWithoutFlashcardInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutFlashcardInput, FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput> | FlashcardCollectionItemCreateWithoutFlashcardInput[] | FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput | FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput[]
    createMany?: FlashcardCollectionItemCreateManyFlashcardInputEnvelope
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
  }

  export type FlashcardInteractionUncheckedCreateNestedManyWithoutFlashcardInput = {
    create?: XOR<FlashcardInteractionCreateWithoutFlashcardInput, FlashcardInteractionUncheckedCreateWithoutFlashcardInput> | FlashcardInteractionCreateWithoutFlashcardInput[] | FlashcardInteractionUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutFlashcardInput | FlashcardInteractionCreateOrConnectWithoutFlashcardInput[]
    createMany?: FlashcardInteractionCreateManyFlashcardInputEnvelope
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
  }

  export type FlashcardCollectionItemUncheckedCreateNestedManyWithoutFlashcardInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutFlashcardInput, FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput> | FlashcardCollectionItemCreateWithoutFlashcardInput[] | FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput | FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput[]
    createMany?: FlashcardCollectionItemCreateManyFlashcardInputEnvelope
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFlashcardsNestedInput = {
    create?: XOR<UserCreateWithoutFlashcardsInput, UserUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlashcardsInput
    upsert?: UserUpsertWithoutFlashcardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlashcardsInput, UserUpdateWithoutFlashcardsInput>, UserUncheckedUpdateWithoutFlashcardsInput>
  }

  export type CourseUpdateOneWithoutFlashcardsNestedInput = {
    create?: XOR<CourseCreateWithoutFlashcardsInput, CourseUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFlashcardsInput
    upsert?: CourseUpsertWithoutFlashcardsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFlashcardsInput, CourseUpdateWithoutFlashcardsInput>, CourseUncheckedUpdateWithoutFlashcardsInput>
  }

  export type CourseModuleUpdateOneWithoutFlashcardsNestedInput = {
    create?: XOR<CourseModuleCreateWithoutFlashcardsInput, CourseModuleUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutFlashcardsInput
    upsert?: CourseModuleUpsertWithoutFlashcardsInput
    disconnect?: CourseModuleWhereInput | boolean
    delete?: CourseModuleWhereInput | boolean
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutFlashcardsInput, CourseModuleUpdateWithoutFlashcardsInput>, CourseModuleUncheckedUpdateWithoutFlashcardsInput>
  }

  export type FlashcardInteractionUpdateManyWithoutFlashcardNestedInput = {
    create?: XOR<FlashcardInteractionCreateWithoutFlashcardInput, FlashcardInteractionUncheckedCreateWithoutFlashcardInput> | FlashcardInteractionCreateWithoutFlashcardInput[] | FlashcardInteractionUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutFlashcardInput | FlashcardInteractionCreateOrConnectWithoutFlashcardInput[]
    upsert?: FlashcardInteractionUpsertWithWhereUniqueWithoutFlashcardInput | FlashcardInteractionUpsertWithWhereUniqueWithoutFlashcardInput[]
    createMany?: FlashcardInteractionCreateManyFlashcardInputEnvelope
    set?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    disconnect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    delete?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    update?: FlashcardInteractionUpdateWithWhereUniqueWithoutFlashcardInput | FlashcardInteractionUpdateWithWhereUniqueWithoutFlashcardInput[]
    updateMany?: FlashcardInteractionUpdateManyWithWhereWithoutFlashcardInput | FlashcardInteractionUpdateManyWithWhereWithoutFlashcardInput[]
    deleteMany?: FlashcardInteractionScalarWhereInput | FlashcardInteractionScalarWhereInput[]
  }

  export type FlashcardCollectionItemUpdateManyWithoutFlashcardNestedInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutFlashcardInput, FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput> | FlashcardCollectionItemCreateWithoutFlashcardInput[] | FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput | FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput[]
    upsert?: FlashcardCollectionItemUpsertWithWhereUniqueWithoutFlashcardInput | FlashcardCollectionItemUpsertWithWhereUniqueWithoutFlashcardInput[]
    createMany?: FlashcardCollectionItemCreateManyFlashcardInputEnvelope
    set?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    disconnect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    delete?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    update?: FlashcardCollectionItemUpdateWithWhereUniqueWithoutFlashcardInput | FlashcardCollectionItemUpdateWithWhereUniqueWithoutFlashcardInput[]
    updateMany?: FlashcardCollectionItemUpdateManyWithWhereWithoutFlashcardInput | FlashcardCollectionItemUpdateManyWithWhereWithoutFlashcardInput[]
    deleteMany?: FlashcardCollectionItemScalarWhereInput | FlashcardCollectionItemScalarWhereInput[]
  }

  export type FlashcardInteractionUncheckedUpdateManyWithoutFlashcardNestedInput = {
    create?: XOR<FlashcardInteractionCreateWithoutFlashcardInput, FlashcardInteractionUncheckedCreateWithoutFlashcardInput> | FlashcardInteractionCreateWithoutFlashcardInput[] | FlashcardInteractionUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardInteractionCreateOrConnectWithoutFlashcardInput | FlashcardInteractionCreateOrConnectWithoutFlashcardInput[]
    upsert?: FlashcardInteractionUpsertWithWhereUniqueWithoutFlashcardInput | FlashcardInteractionUpsertWithWhereUniqueWithoutFlashcardInput[]
    createMany?: FlashcardInteractionCreateManyFlashcardInputEnvelope
    set?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    disconnect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    delete?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    connect?: FlashcardInteractionWhereUniqueInput | FlashcardInteractionWhereUniqueInput[]
    update?: FlashcardInteractionUpdateWithWhereUniqueWithoutFlashcardInput | FlashcardInteractionUpdateWithWhereUniqueWithoutFlashcardInput[]
    updateMany?: FlashcardInteractionUpdateManyWithWhereWithoutFlashcardInput | FlashcardInteractionUpdateManyWithWhereWithoutFlashcardInput[]
    deleteMany?: FlashcardInteractionScalarWhereInput | FlashcardInteractionScalarWhereInput[]
  }

  export type FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardNestedInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutFlashcardInput, FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput> | FlashcardCollectionItemCreateWithoutFlashcardInput[] | FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput | FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput[]
    upsert?: FlashcardCollectionItemUpsertWithWhereUniqueWithoutFlashcardInput | FlashcardCollectionItemUpsertWithWhereUniqueWithoutFlashcardInput[]
    createMany?: FlashcardCollectionItemCreateManyFlashcardInputEnvelope
    set?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    disconnect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    delete?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    update?: FlashcardCollectionItemUpdateWithWhereUniqueWithoutFlashcardInput | FlashcardCollectionItemUpdateWithWhereUniqueWithoutFlashcardInput[]
    updateMany?: FlashcardCollectionItemUpdateManyWithWhereWithoutFlashcardInput | FlashcardCollectionItemUpdateManyWithWhereWithoutFlashcardInput[]
    deleteMany?: FlashcardCollectionItemScalarWhereInput | FlashcardCollectionItemScalarWhereInput[]
  }

  export type FlashcardCreateNestedOneWithoutUserInteractionsInput = {
    create?: XOR<FlashcardCreateWithoutUserInteractionsInput, FlashcardUncheckedCreateWithoutUserInteractionsInput>
    connectOrCreate?: FlashcardCreateOrConnectWithoutUserInteractionsInput
    connect?: FlashcardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserInteractionsInput = {
    create?: XOR<UserCreateWithoutUserInteractionsInput, UserUncheckedCreateWithoutUserInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserInteractionsInput
    connect?: UserWhereUniqueInput
  }

  export type FlashcardUpdateOneRequiredWithoutUserInteractionsNestedInput = {
    create?: XOR<FlashcardCreateWithoutUserInteractionsInput, FlashcardUncheckedCreateWithoutUserInteractionsInput>
    connectOrCreate?: FlashcardCreateOrConnectWithoutUserInteractionsInput
    upsert?: FlashcardUpsertWithoutUserInteractionsInput
    connect?: FlashcardWhereUniqueInput
    update?: XOR<XOR<FlashcardUpdateToOneWithWhereWithoutUserInteractionsInput, FlashcardUpdateWithoutUserInteractionsInput>, FlashcardUncheckedUpdateWithoutUserInteractionsInput>
  }

  export type UserUpdateOneRequiredWithoutUserInteractionsNestedInput = {
    create?: XOR<UserCreateWithoutUserInteractionsInput, UserUncheckedCreateWithoutUserInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserInteractionsInput
    upsert?: UserUpsertWithoutUserInteractionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserInteractionsInput, UserUpdateWithoutUserInteractionsInput>, UserUncheckedUpdateWithoutUserInteractionsInput>
  }

  export type UserCreateNestedOneWithoutFlashcardCollectionsInput = {
    create?: XOR<UserCreateWithoutFlashcardCollectionsInput, UserUncheckedCreateWithoutFlashcardCollectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlashcardCollectionsInput
    connect?: UserWhereUniqueInput
  }

  export type FlashcardCollectionItemCreateNestedManyWithoutCollectionInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutCollectionInput, FlashcardCollectionItemUncheckedCreateWithoutCollectionInput> | FlashcardCollectionItemCreateWithoutCollectionInput[] | FlashcardCollectionItemUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutCollectionInput | FlashcardCollectionItemCreateOrConnectWithoutCollectionInput[]
    createMany?: FlashcardCollectionItemCreateManyCollectionInputEnvelope
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
  }

  export type FlashcardCollectionItemUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutCollectionInput, FlashcardCollectionItemUncheckedCreateWithoutCollectionInput> | FlashcardCollectionItemCreateWithoutCollectionInput[] | FlashcardCollectionItemUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutCollectionInput | FlashcardCollectionItemCreateOrConnectWithoutCollectionInput[]
    createMany?: FlashcardCollectionItemCreateManyCollectionInputEnvelope
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFlashcardCollectionsNestedInput = {
    create?: XOR<UserCreateWithoutFlashcardCollectionsInput, UserUncheckedCreateWithoutFlashcardCollectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlashcardCollectionsInput
    upsert?: UserUpsertWithoutFlashcardCollectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlashcardCollectionsInput, UserUpdateWithoutFlashcardCollectionsInput>, UserUncheckedUpdateWithoutFlashcardCollectionsInput>
  }

  export type FlashcardCollectionItemUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutCollectionInput, FlashcardCollectionItemUncheckedCreateWithoutCollectionInput> | FlashcardCollectionItemCreateWithoutCollectionInput[] | FlashcardCollectionItemUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutCollectionInput | FlashcardCollectionItemCreateOrConnectWithoutCollectionInput[]
    upsert?: FlashcardCollectionItemUpsertWithWhereUniqueWithoutCollectionInput | FlashcardCollectionItemUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: FlashcardCollectionItemCreateManyCollectionInputEnvelope
    set?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    disconnect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    delete?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    update?: FlashcardCollectionItemUpdateWithWhereUniqueWithoutCollectionInput | FlashcardCollectionItemUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: FlashcardCollectionItemUpdateManyWithWhereWithoutCollectionInput | FlashcardCollectionItemUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: FlashcardCollectionItemScalarWhereInput | FlashcardCollectionItemScalarWhereInput[]
  }

  export type FlashcardCollectionItemUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<FlashcardCollectionItemCreateWithoutCollectionInput, FlashcardCollectionItemUncheckedCreateWithoutCollectionInput> | FlashcardCollectionItemCreateWithoutCollectionInput[] | FlashcardCollectionItemUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FlashcardCollectionItemCreateOrConnectWithoutCollectionInput | FlashcardCollectionItemCreateOrConnectWithoutCollectionInput[]
    upsert?: FlashcardCollectionItemUpsertWithWhereUniqueWithoutCollectionInput | FlashcardCollectionItemUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: FlashcardCollectionItemCreateManyCollectionInputEnvelope
    set?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    disconnect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    delete?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    connect?: FlashcardCollectionItemWhereUniqueInput | FlashcardCollectionItemWhereUniqueInput[]
    update?: FlashcardCollectionItemUpdateWithWhereUniqueWithoutCollectionInput | FlashcardCollectionItemUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: FlashcardCollectionItemUpdateManyWithWhereWithoutCollectionInput | FlashcardCollectionItemUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: FlashcardCollectionItemScalarWhereInput | FlashcardCollectionItemScalarWhereInput[]
  }

  export type FlashcardCollectionCreateNestedOneWithoutCardsInput = {
    create?: XOR<FlashcardCollectionCreateWithoutCardsInput, FlashcardCollectionUncheckedCreateWithoutCardsInput>
    connectOrCreate?: FlashcardCollectionCreateOrConnectWithoutCardsInput
    connect?: FlashcardCollectionWhereUniqueInput
  }

  export type FlashcardCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<FlashcardCreateWithoutCollectionsInput, FlashcardUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: FlashcardCreateOrConnectWithoutCollectionsInput
    connect?: FlashcardWhereUniqueInput
  }

  export type FlashcardCollectionUpdateOneRequiredWithoutCardsNestedInput = {
    create?: XOR<FlashcardCollectionCreateWithoutCardsInput, FlashcardCollectionUncheckedCreateWithoutCardsInput>
    connectOrCreate?: FlashcardCollectionCreateOrConnectWithoutCardsInput
    upsert?: FlashcardCollectionUpsertWithoutCardsInput
    connect?: FlashcardCollectionWhereUniqueInput
    update?: XOR<XOR<FlashcardCollectionUpdateToOneWithWhereWithoutCardsInput, FlashcardCollectionUpdateWithoutCardsInput>, FlashcardCollectionUncheckedUpdateWithoutCardsInput>
  }

  export type FlashcardUpdateOneRequiredWithoutCollectionsNestedInput = {
    create?: XOR<FlashcardCreateWithoutCollectionsInput, FlashcardUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: FlashcardCreateOrConnectWithoutCollectionsInput
    upsert?: FlashcardUpsertWithoutCollectionsInput
    connect?: FlashcardWhereUniqueInput
    update?: XOR<XOR<FlashcardUpdateToOneWithWhereWithoutCollectionsInput, FlashcardUpdateWithoutCollectionsInput>, FlashcardUncheckedUpdateWithoutCollectionsInput>
  }

  export type UserCreateNestedOneWithoutChatbotSessionsInput = {
    create?: XOR<UserCreateWithoutChatbotSessionsInput, UserUncheckedCreateWithoutChatbotSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatbotMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatbotMessageCreateWithoutSessionInput, ChatbotMessageUncheckedCreateWithoutSessionInput> | ChatbotMessageCreateWithoutSessionInput[] | ChatbotMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutSessionInput | ChatbotMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatbotMessageCreateManySessionInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type ChatbotSessionAnalyticsCreateNestedOneWithoutSessionInput = {
    create?: XOR<ChatbotSessionAnalyticsCreateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ChatbotSessionAnalyticsCreateOrConnectWithoutSessionInput
    connect?: ChatbotSessionAnalyticsWhereUniqueInput
  }

  export type ChatbotMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatbotMessageCreateWithoutSessionInput, ChatbotMessageUncheckedCreateWithoutSessionInput> | ChatbotMessageCreateWithoutSessionInput[] | ChatbotMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutSessionInput | ChatbotMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatbotMessageCreateManySessionInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type ChatbotSessionAnalyticsUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<ChatbotSessionAnalyticsCreateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ChatbotSessionAnalyticsCreateOrConnectWithoutSessionInput
    connect?: ChatbotSessionAnalyticsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChatbotSessionsNestedInput = {
    create?: XOR<UserCreateWithoutChatbotSessionsInput, UserUncheckedCreateWithoutChatbotSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotSessionsInput
    upsert?: UserUpsertWithoutChatbotSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatbotSessionsInput, UserUpdateWithoutChatbotSessionsInput>, UserUncheckedUpdateWithoutChatbotSessionsInput>
  }

  export type ChatbotMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutSessionInput, ChatbotMessageUncheckedCreateWithoutSessionInput> | ChatbotMessageCreateWithoutSessionInput[] | ChatbotMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutSessionInput | ChatbotMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutSessionInput | ChatbotMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatbotMessageCreateManySessionInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutSessionInput | ChatbotMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutSessionInput | ChatbotMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type ChatbotSessionAnalyticsUpdateOneWithoutSessionNestedInput = {
    create?: XOR<ChatbotSessionAnalyticsCreateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ChatbotSessionAnalyticsCreateOrConnectWithoutSessionInput
    upsert?: ChatbotSessionAnalyticsUpsertWithoutSessionInput
    disconnect?: ChatbotSessionAnalyticsWhereInput | boolean
    delete?: ChatbotSessionAnalyticsWhereInput | boolean
    connect?: ChatbotSessionAnalyticsWhereUniqueInput
    update?: XOR<XOR<ChatbotSessionAnalyticsUpdateToOneWithWhereWithoutSessionInput, ChatbotSessionAnalyticsUpdateWithoutSessionInput>, ChatbotSessionAnalyticsUncheckedUpdateWithoutSessionInput>
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutSessionInput, ChatbotMessageUncheckedCreateWithoutSessionInput> | ChatbotMessageCreateWithoutSessionInput[] | ChatbotMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutSessionInput | ChatbotMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutSessionInput | ChatbotMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatbotMessageCreateManySessionInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutSessionInput | ChatbotMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutSessionInput | ChatbotMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type ChatbotSessionAnalyticsUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<ChatbotSessionAnalyticsCreateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: ChatbotSessionAnalyticsCreateOrConnectWithoutSessionInput
    upsert?: ChatbotSessionAnalyticsUpsertWithoutSessionInput
    disconnect?: ChatbotSessionAnalyticsWhereInput | boolean
    delete?: ChatbotSessionAnalyticsWhereInput | boolean
    connect?: ChatbotSessionAnalyticsWhereUniqueInput
    update?: XOR<XOR<ChatbotSessionAnalyticsUpdateToOneWithWhereWithoutSessionInput, ChatbotSessionAnalyticsUpdateWithoutSessionInput>, ChatbotSessionAnalyticsUncheckedUpdateWithoutSessionInput>
  }

  export type ChatbotSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatbotSessionCreateWithoutMessagesInput, ChatbotSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutMessagesInput
    connect?: ChatbotSessionWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutChatbotMessagesInput = {
    create?: XOR<CourseCreateWithoutChatbotMessagesInput, CourseUncheckedCreateWithoutChatbotMessagesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutChatbotMessagesInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseModuleCreateNestedOneWithoutChatbotMessagesInput = {
    create?: XOR<CourseModuleCreateWithoutChatbotMessagesInput, CourseModuleUncheckedCreateWithoutChatbotMessagesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutChatbotMessagesInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type ChatbotFeedbackCreateNestedOneWithoutMessageInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutMessageInput, ChatbotFeedbackUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutMessageInput
    connect?: ChatbotFeedbackWhereUniqueInput
  }

  export type ChatbotFeedbackUncheckedCreateNestedOneWithoutMessageInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutMessageInput, ChatbotFeedbackUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutMessageInput
    connect?: ChatbotFeedbackWhereUniqueInput
  }

  export type EnumMessageRoleFieldUpdateOperationsInput = {
    set?: $Enums.MessageRole
  }

  export type ChatbotSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatbotSessionCreateWithoutMessagesInput, ChatbotSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutMessagesInput
    upsert?: ChatbotSessionUpsertWithoutMessagesInput
    connect?: ChatbotSessionWhereUniqueInput
    update?: XOR<XOR<ChatbotSessionUpdateToOneWithWhereWithoutMessagesInput, ChatbotSessionUpdateWithoutMessagesInput>, ChatbotSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type CourseUpdateOneWithoutChatbotMessagesNestedInput = {
    create?: XOR<CourseCreateWithoutChatbotMessagesInput, CourseUncheckedCreateWithoutChatbotMessagesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutChatbotMessagesInput
    upsert?: CourseUpsertWithoutChatbotMessagesInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutChatbotMessagesInput, CourseUpdateWithoutChatbotMessagesInput>, CourseUncheckedUpdateWithoutChatbotMessagesInput>
  }

  export type CourseModuleUpdateOneWithoutChatbotMessagesNestedInput = {
    create?: XOR<CourseModuleCreateWithoutChatbotMessagesInput, CourseModuleUncheckedCreateWithoutChatbotMessagesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutChatbotMessagesInput
    upsert?: CourseModuleUpsertWithoutChatbotMessagesInput
    disconnect?: CourseModuleWhereInput | boolean
    delete?: CourseModuleWhereInput | boolean
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutChatbotMessagesInput, CourseModuleUpdateWithoutChatbotMessagesInput>, CourseModuleUncheckedUpdateWithoutChatbotMessagesInput>
  }

  export type ChatbotFeedbackUpdateOneWithoutMessageNestedInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutMessageInput, ChatbotFeedbackUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutMessageInput
    upsert?: ChatbotFeedbackUpsertWithoutMessageInput
    disconnect?: ChatbotFeedbackWhereInput | boolean
    delete?: ChatbotFeedbackWhereInput | boolean
    connect?: ChatbotFeedbackWhereUniqueInput
    update?: XOR<XOR<ChatbotFeedbackUpdateToOneWithWhereWithoutMessageInput, ChatbotFeedbackUpdateWithoutMessageInput>, ChatbotFeedbackUncheckedUpdateWithoutMessageInput>
  }

  export type ChatbotFeedbackUncheckedUpdateOneWithoutMessageNestedInput = {
    create?: XOR<ChatbotFeedbackCreateWithoutMessageInput, ChatbotFeedbackUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChatbotFeedbackCreateOrConnectWithoutMessageInput
    upsert?: ChatbotFeedbackUpsertWithoutMessageInput
    disconnect?: ChatbotFeedbackWhereInput | boolean
    delete?: ChatbotFeedbackWhereInput | boolean
    connect?: ChatbotFeedbackWhereUniqueInput
    update?: XOR<XOR<ChatbotFeedbackUpdateToOneWithWhereWithoutMessageInput, ChatbotFeedbackUpdateWithoutMessageInput>, ChatbotFeedbackUncheckedUpdateWithoutMessageInput>
  }

  export type ChatbotMessageCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<ChatbotMessageCreateWithoutFeedbackInput, ChatbotMessageUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutFeedbackInput
    connect?: ChatbotMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatbotFeedbackInput = {
    create?: XOR<UserCreateWithoutChatbotFeedbackInput, UserUncheckedCreateWithoutChatbotFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type ChatbotMessageUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutFeedbackInput, ChatbotMessageUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutFeedbackInput
    upsert?: ChatbotMessageUpsertWithoutFeedbackInput
    connect?: ChatbotMessageWhereUniqueInput
    update?: XOR<XOR<ChatbotMessageUpdateToOneWithWhereWithoutFeedbackInput, ChatbotMessageUpdateWithoutFeedbackInput>, ChatbotMessageUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneRequiredWithoutChatbotFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutChatbotFeedbackInput, UserUncheckedCreateWithoutChatbotFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotFeedbackInput
    upsert?: UserUpsertWithoutChatbotFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatbotFeedbackInput, UserUpdateWithoutChatbotFeedbackInput>, UserUncheckedUpdateWithoutChatbotFeedbackInput>
  }

  export type ChatbotSessionCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<ChatbotSessionCreateWithoutAnalyticsInput, ChatbotSessionUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutAnalyticsInput
    connect?: ChatbotSessionWhereUniqueInput
  }

  export type ChatbotSessionUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<ChatbotSessionCreateWithoutAnalyticsInput, ChatbotSessionUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: ChatbotSessionCreateOrConnectWithoutAnalyticsInput
    upsert?: ChatbotSessionUpsertWithoutAnalyticsInput
    connect?: ChatbotSessionWhereUniqueInput
    update?: XOR<XOR<ChatbotSessionUpdateToOneWithWhereWithoutAnalyticsInput, ChatbotSessionUpdateWithoutAnalyticsInput>, ChatbotSessionUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutSavedAnswersInput = {
    create?: XOR<UserCreateWithoutSavedAnswersInput, UserUncheckedCreateWithoutSavedAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutSavedAnswersInput = {
    create?: XOR<CourseCreateWithoutSavedAnswersInput, CourseUncheckedCreateWithoutSavedAnswersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSavedAnswersInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneWithoutSavedAnswersNestedInput = {
    create?: XOR<UserCreateWithoutSavedAnswersInput, UserUncheckedCreateWithoutSavedAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedAnswersInput
    upsert?: UserUpsertWithoutSavedAnswersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedAnswersInput, UserUpdateWithoutSavedAnswersInput>, UserUncheckedUpdateWithoutSavedAnswersInput>
  }

  export type CourseUpdateOneWithoutSavedAnswersNestedInput = {
    create?: XOR<CourseCreateWithoutSavedAnswersInput, CourseUncheckedCreateWithoutSavedAnswersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSavedAnswersInput
    upsert?: CourseUpsertWithoutSavedAnswersInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSavedAnswersInput, CourseUpdateWithoutSavedAnswersInput>, CourseUncheckedUpdateWithoutSavedAnswersInput>
  }

  export type UserSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type UserSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type UserSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutSkillInput | UserSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutSkillInput | UserSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutSkillInput | UserSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type UserSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutSkillInput | UserSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutSkillInput | UserSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutSkillInput | UserSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSkillsInput
    connect?: UserWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSkillsInput
    upsert?: UserUpsertWithoutUserSkillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSkillsInput, UserUpdateWithoutUserSkillsInput>, UserUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserSkillsInput
    upsert?: SkillUpsertWithoutUserSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutUserSkillsInput, SkillUpdateWithoutUserSkillsInput>, SkillUncheckedUpdateWithoutUserSkillsInput>
  }

  export type UserCreateNestedOneWithoutInstructedCoursesInput = {
    create?: XOR<UserCreateWithoutInstructedCoursesInput, UserUncheckedCreateWithoutInstructedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type LearningOutcomeCreateNestedManyWithoutCourseInput = {
    create?: XOR<LearningOutcomeCreateWithoutCourseInput, LearningOutcomeUncheckedCreateWithoutCourseInput> | LearningOutcomeCreateWithoutCourseInput[] | LearningOutcomeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutCourseInput | LearningOutcomeCreateOrConnectWithoutCourseInput[]
    createMany?: LearningOutcomeCreateManyCourseInputEnvelope
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
  }

  export type CourseRequirementCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseRequirementCreateWithoutCourseInput, CourseRequirementUncheckedCreateWithoutCourseInput> | CourseRequirementCreateWithoutCourseInput[] | CourseRequirementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRequirementCreateOrConnectWithoutCourseInput | CourseRequirementCreateOrConnectWithoutCourseInput[]
    createMany?: CourseRequirementCreateManyCourseInputEnvelope
    connect?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
  }

  export type AssessmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<AssessmentCreateWithoutCourseInput, AssessmentUncheckedCreateWithoutCourseInput> | AssessmentCreateWithoutCourseInput[] | AssessmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutCourseInput | AssessmentCreateOrConnectWithoutCourseInput[]
    createMany?: AssessmentCreateManyCourseInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type FlashcardCreateNestedManyWithoutCourseInput = {
    create?: XOR<FlashcardCreateWithoutCourseInput, FlashcardUncheckedCreateWithoutCourseInput> | FlashcardCreateWithoutCourseInput[] | FlashcardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutCourseInput | FlashcardCreateOrConnectWithoutCourseInput[]
    createMany?: FlashcardCreateManyCourseInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type ChatbotMessageCreateNestedManyWithoutCourseInput = {
    create?: XOR<ChatbotMessageCreateWithoutCourseInput, ChatbotMessageUncheckedCreateWithoutCourseInput> | ChatbotMessageCreateWithoutCourseInput[] | ChatbotMessageUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutCourseInput | ChatbotMessageCreateOrConnectWithoutCourseInput[]
    createMany?: ChatbotMessageCreateManyCourseInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type SavedAnswerCreateNestedManyWithoutCourseInput = {
    create?: XOR<SavedAnswerCreateWithoutCourseInput, SavedAnswerUncheckedCreateWithoutCourseInput> | SavedAnswerCreateWithoutCourseInput[] | SavedAnswerUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutCourseInput | SavedAnswerCreateOrConnectWithoutCourseInput[]
    createMany?: SavedAnswerCreateManyCourseInputEnvelope
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
  }

  export type CourseTagsCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagsCreateWithoutCourseInput, CourseTagsUncheckedCreateWithoutCourseInput> | CourseTagsCreateWithoutCourseInput[] | CourseTagsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCourseInput | CourseTagsCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagsCreateManyCourseInputEnvelope
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
  }

  export type CourseReviewCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type CourseModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LearningOutcomeCreateWithoutCourseInput, LearningOutcomeUncheckedCreateWithoutCourseInput> | LearningOutcomeCreateWithoutCourseInput[] | LearningOutcomeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutCourseInput | LearningOutcomeCreateOrConnectWithoutCourseInput[]
    createMany?: LearningOutcomeCreateManyCourseInputEnvelope
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
  }

  export type CourseRequirementUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseRequirementCreateWithoutCourseInput, CourseRequirementUncheckedCreateWithoutCourseInput> | CourseRequirementCreateWithoutCourseInput[] | CourseRequirementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRequirementCreateOrConnectWithoutCourseInput | CourseRequirementCreateOrConnectWithoutCourseInput[]
    createMany?: CourseRequirementCreateManyCourseInputEnvelope
    connect?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
  }

  export type AssessmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<AssessmentCreateWithoutCourseInput, AssessmentUncheckedCreateWithoutCourseInput> | AssessmentCreateWithoutCourseInput[] | AssessmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutCourseInput | AssessmentCreateOrConnectWithoutCourseInput[]
    createMany?: AssessmentCreateManyCourseInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type FlashcardUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<FlashcardCreateWithoutCourseInput, FlashcardUncheckedCreateWithoutCourseInput> | FlashcardCreateWithoutCourseInput[] | FlashcardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutCourseInput | FlashcardCreateOrConnectWithoutCourseInput[]
    createMany?: FlashcardCreateManyCourseInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ChatbotMessageCreateWithoutCourseInput, ChatbotMessageUncheckedCreateWithoutCourseInput> | ChatbotMessageCreateWithoutCourseInput[] | ChatbotMessageUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutCourseInput | ChatbotMessageCreateOrConnectWithoutCourseInput[]
    createMany?: ChatbotMessageCreateManyCourseInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type SavedAnswerUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<SavedAnswerCreateWithoutCourseInput, SavedAnswerUncheckedCreateWithoutCourseInput> | SavedAnswerCreateWithoutCourseInput[] | SavedAnswerUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutCourseInput | SavedAnswerCreateOrConnectWithoutCourseInput[]
    createMany?: SavedAnswerCreateManyCourseInputEnvelope
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
  }

  export type CourseTagsUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagsCreateWithoutCourseInput, CourseTagsUncheckedCreateWithoutCourseInput> | CourseTagsCreateWithoutCourseInput[] | CourseTagsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCourseInput | CourseTagsCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagsCreateManyCourseInputEnvelope
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
  }

  export type CourseReviewUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
  }

  export type EnumCourseTypeFieldUpdateOperationsInput = {
    set?: $Enums.CourseType
  }

  export type NullableEnumDifficultyLevelFieldUpdateOperationsInput = {
    set?: $Enums.DifficultyLevel | null
  }

  export type UserUpdateOneWithoutInstructedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutInstructedCoursesInput, UserUncheckedCreateWithoutInstructedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructedCoursesInput
    upsert?: UserUpsertWithoutInstructedCoursesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstructedCoursesInput, UserUpdateWithoutInstructedCoursesInput>, UserUncheckedUpdateWithoutInstructedCoursesInput>
  }

  export type CourseModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type LearningOutcomeUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LearningOutcomeCreateWithoutCourseInput, LearningOutcomeUncheckedCreateWithoutCourseInput> | LearningOutcomeCreateWithoutCourseInput[] | LearningOutcomeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutCourseInput | LearningOutcomeCreateOrConnectWithoutCourseInput[]
    upsert?: LearningOutcomeUpsertWithWhereUniqueWithoutCourseInput | LearningOutcomeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LearningOutcomeCreateManyCourseInputEnvelope
    set?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    disconnect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    delete?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    update?: LearningOutcomeUpdateWithWhereUniqueWithoutCourseInput | LearningOutcomeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LearningOutcomeUpdateManyWithWhereWithoutCourseInput | LearningOutcomeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
  }

  export type CourseRequirementUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseRequirementCreateWithoutCourseInput, CourseRequirementUncheckedCreateWithoutCourseInput> | CourseRequirementCreateWithoutCourseInput[] | CourseRequirementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRequirementCreateOrConnectWithoutCourseInput | CourseRequirementCreateOrConnectWithoutCourseInput[]
    upsert?: CourseRequirementUpsertWithWhereUniqueWithoutCourseInput | CourseRequirementUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseRequirementCreateManyCourseInputEnvelope
    set?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    disconnect?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    delete?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    connect?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    update?: CourseRequirementUpdateWithWhereUniqueWithoutCourseInput | CourseRequirementUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseRequirementUpdateManyWithWhereWithoutCourseInput | CourseRequirementUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseRequirementScalarWhereInput | CourseRequirementScalarWhereInput[]
  }

  export type AssessmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<AssessmentCreateWithoutCourseInput, AssessmentUncheckedCreateWithoutCourseInput> | AssessmentCreateWithoutCourseInput[] | AssessmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutCourseInput | AssessmentCreateOrConnectWithoutCourseInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutCourseInput | AssessmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: AssessmentCreateManyCourseInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutCourseInput | AssessmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutCourseInput | AssessmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type FlashcardUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FlashcardCreateWithoutCourseInput, FlashcardUncheckedCreateWithoutCourseInput> | FlashcardCreateWithoutCourseInput[] | FlashcardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutCourseInput | FlashcardCreateOrConnectWithoutCourseInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutCourseInput | FlashcardUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FlashcardCreateManyCourseInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutCourseInput | FlashcardUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutCourseInput | FlashcardUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type ChatbotMessageUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutCourseInput, ChatbotMessageUncheckedCreateWithoutCourseInput> | ChatbotMessageCreateWithoutCourseInput[] | ChatbotMessageUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutCourseInput | ChatbotMessageCreateOrConnectWithoutCourseInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutCourseInput | ChatbotMessageUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ChatbotMessageCreateManyCourseInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutCourseInput | ChatbotMessageUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutCourseInput | ChatbotMessageUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type SavedAnswerUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SavedAnswerCreateWithoutCourseInput, SavedAnswerUncheckedCreateWithoutCourseInput> | SavedAnswerCreateWithoutCourseInput[] | SavedAnswerUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutCourseInput | SavedAnswerCreateOrConnectWithoutCourseInput[]
    upsert?: SavedAnswerUpsertWithWhereUniqueWithoutCourseInput | SavedAnswerUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SavedAnswerCreateManyCourseInputEnvelope
    set?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    disconnect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    delete?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    update?: SavedAnswerUpdateWithWhereUniqueWithoutCourseInput | SavedAnswerUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SavedAnswerUpdateManyWithWhereWithoutCourseInput | SavedAnswerUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SavedAnswerScalarWhereInput | SavedAnswerScalarWhereInput[]
  }

  export type CourseTagsUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagsCreateWithoutCourseInput, CourseTagsUncheckedCreateWithoutCourseInput> | CourseTagsCreateWithoutCourseInput[] | CourseTagsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCourseInput | CourseTagsCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagsUpsertWithWhereUniqueWithoutCourseInput | CourseTagsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagsCreateManyCourseInputEnvelope
    set?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    disconnect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    delete?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    update?: CourseTagsUpdateWithWhereUniqueWithoutCourseInput | CourseTagsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagsUpdateManyWithWhereWithoutCourseInput | CourseTagsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
  }

  export type CourseReviewUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutCourseInput | CourseReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutCourseInput | CourseReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutCourseInput | CourseReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LearningOutcomeCreateWithoutCourseInput, LearningOutcomeUncheckedCreateWithoutCourseInput> | LearningOutcomeCreateWithoutCourseInput[] | LearningOutcomeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutCourseInput | LearningOutcomeCreateOrConnectWithoutCourseInput[]
    upsert?: LearningOutcomeUpsertWithWhereUniqueWithoutCourseInput | LearningOutcomeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LearningOutcomeCreateManyCourseInputEnvelope
    set?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    disconnect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    delete?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    update?: LearningOutcomeUpdateWithWhereUniqueWithoutCourseInput | LearningOutcomeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LearningOutcomeUpdateManyWithWhereWithoutCourseInput | LearningOutcomeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
  }

  export type CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseRequirementCreateWithoutCourseInput, CourseRequirementUncheckedCreateWithoutCourseInput> | CourseRequirementCreateWithoutCourseInput[] | CourseRequirementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRequirementCreateOrConnectWithoutCourseInput | CourseRequirementCreateOrConnectWithoutCourseInput[]
    upsert?: CourseRequirementUpsertWithWhereUniqueWithoutCourseInput | CourseRequirementUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseRequirementCreateManyCourseInputEnvelope
    set?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    disconnect?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    delete?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    connect?: CourseRequirementWhereUniqueInput | CourseRequirementWhereUniqueInput[]
    update?: CourseRequirementUpdateWithWhereUniqueWithoutCourseInput | CourseRequirementUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseRequirementUpdateManyWithWhereWithoutCourseInput | CourseRequirementUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseRequirementScalarWhereInput | CourseRequirementScalarWhereInput[]
  }

  export type AssessmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<AssessmentCreateWithoutCourseInput, AssessmentUncheckedCreateWithoutCourseInput> | AssessmentCreateWithoutCourseInput[] | AssessmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutCourseInput | AssessmentCreateOrConnectWithoutCourseInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutCourseInput | AssessmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: AssessmentCreateManyCourseInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutCourseInput | AssessmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutCourseInput | AssessmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type FlashcardUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FlashcardCreateWithoutCourseInput, FlashcardUncheckedCreateWithoutCourseInput> | FlashcardCreateWithoutCourseInput[] | FlashcardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutCourseInput | FlashcardCreateOrConnectWithoutCourseInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutCourseInput | FlashcardUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FlashcardCreateManyCourseInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutCourseInput | FlashcardUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutCourseInput | FlashcardUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutCourseInput, ChatbotMessageUncheckedCreateWithoutCourseInput> | ChatbotMessageCreateWithoutCourseInput[] | ChatbotMessageUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutCourseInput | ChatbotMessageCreateOrConnectWithoutCourseInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutCourseInput | ChatbotMessageUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ChatbotMessageCreateManyCourseInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutCourseInput | ChatbotMessageUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutCourseInput | ChatbotMessageUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SavedAnswerCreateWithoutCourseInput, SavedAnswerUncheckedCreateWithoutCourseInput> | SavedAnswerCreateWithoutCourseInput[] | SavedAnswerUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SavedAnswerCreateOrConnectWithoutCourseInput | SavedAnswerCreateOrConnectWithoutCourseInput[]
    upsert?: SavedAnswerUpsertWithWhereUniqueWithoutCourseInput | SavedAnswerUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SavedAnswerCreateManyCourseInputEnvelope
    set?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    disconnect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    delete?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    connect?: SavedAnswerWhereUniqueInput | SavedAnswerWhereUniqueInput[]
    update?: SavedAnswerUpdateWithWhereUniqueWithoutCourseInput | SavedAnswerUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SavedAnswerUpdateManyWithWhereWithoutCourseInput | SavedAnswerUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SavedAnswerScalarWhereInput | SavedAnswerScalarWhereInput[]
  }

  export type CourseTagsUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagsCreateWithoutCourseInput, CourseTagsUncheckedCreateWithoutCourseInput> | CourseTagsCreateWithoutCourseInput[] | CourseTagsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCourseInput | CourseTagsCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagsUpsertWithWhereUniqueWithoutCourseInput | CourseTagsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagsCreateManyCourseInputEnvelope
    set?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    disconnect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    delete?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    update?: CourseTagsUpdateWithWhereUniqueWithoutCourseInput | CourseTagsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagsUpdateManyWithWhereWithoutCourseInput | CourseTagsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
  }

  export type CourseReviewUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput> | CourseReviewCreateWithoutCourseInput[] | CourseReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseReviewCreateOrConnectWithoutCourseInput | CourseReviewCreateOrConnectWithoutCourseInput[]
    upsert?: CourseReviewUpsertWithWhereUniqueWithoutCourseInput | CourseReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseReviewCreateManyCourseInputEnvelope
    set?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    disconnect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    delete?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    connect?: CourseReviewWhereUniqueInput | CourseReviewWhereUniqueInput[]
    update?: CourseReviewUpdateWithWhereUniqueWithoutCourseInput | CourseReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseReviewUpdateManyWithWhereWithoutCourseInput | CourseReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutTagsInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    upsert?: CourseUpsertWithoutTagsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTagsInput, CourseUpdateWithoutTagsInput>, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type CourseCreateNestedOneWithoutLearningOutcomesInput = {
    create?: XOR<CourseCreateWithoutLearningOutcomesInput, CourseUncheckedCreateWithoutLearningOutcomesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLearningOutcomesInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutLearningOutcomesNestedInput = {
    create?: XOR<CourseCreateWithoutLearningOutcomesInput, CourseUncheckedCreateWithoutLearningOutcomesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLearningOutcomesInput
    upsert?: CourseUpsertWithoutLearningOutcomesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLearningOutcomesInput, CourseUpdateWithoutLearningOutcomesInput>, CourseUncheckedUpdateWithoutLearningOutcomesInput>
  }

  export type CourseCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<CourseCreateWithoutRequirementsInput, CourseUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRequirementsInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<CourseCreateWithoutRequirementsInput, CourseUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRequirementsInput
    upsert?: CourseUpsertWithoutRequirementsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutRequirementsInput, CourseUpdateWithoutRequirementsInput>, CourseUncheckedUpdateWithoutRequirementsInput>
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type ContentUnitCreateNestedManyWithoutModuleInput = {
    create?: XOR<ContentUnitCreateWithoutModuleInput, ContentUnitUncheckedCreateWithoutModuleInput> | ContentUnitCreateWithoutModuleInput[] | ContentUnitUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutModuleInput | ContentUnitCreateOrConnectWithoutModuleInput[]
    createMany?: ContentUnitCreateManyModuleInputEnvelope
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutModuleInput = {
    create?: XOR<QuizCreateWithoutModuleInput, QuizUncheckedCreateWithoutModuleInput> | QuizCreateWithoutModuleInput[] | QuizUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutModuleInput | QuizCreateOrConnectWithoutModuleInput[]
    createMany?: QuizCreateManyModuleInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutModuleInput = {
    create?: XOR<ExerciseCreateWithoutModuleInput, ExerciseUncheckedCreateWithoutModuleInput> | ExerciseCreateWithoutModuleInput[] | ExerciseUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutModuleInput | ExerciseCreateOrConnectWithoutModuleInput[]
    createMany?: ExerciseCreateManyModuleInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ModuleProgressCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type FlashcardCreateNestedManyWithoutModuleInput = {
    create?: XOR<FlashcardCreateWithoutModuleInput, FlashcardUncheckedCreateWithoutModuleInput> | FlashcardCreateWithoutModuleInput[] | FlashcardUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutModuleInput | FlashcardCreateOrConnectWithoutModuleInput[]
    createMany?: FlashcardCreateManyModuleInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type ChatbotMessageCreateNestedManyWithoutModuleInput = {
    create?: XOR<ChatbotMessageCreateWithoutModuleInput, ChatbotMessageUncheckedCreateWithoutModuleInput> | ChatbotMessageCreateWithoutModuleInput[] | ChatbotMessageUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutModuleInput | ChatbotMessageCreateOrConnectWithoutModuleInput[]
    createMany?: ChatbotMessageCreateManyModuleInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type ContentUnitUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ContentUnitCreateWithoutModuleInput, ContentUnitUncheckedCreateWithoutModuleInput> | ContentUnitCreateWithoutModuleInput[] | ContentUnitUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutModuleInput | ContentUnitCreateOrConnectWithoutModuleInput[]
    createMany?: ContentUnitCreateManyModuleInputEnvelope
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<QuizCreateWithoutModuleInput, QuizUncheckedCreateWithoutModuleInput> | QuizCreateWithoutModuleInput[] | QuizUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutModuleInput | QuizCreateOrConnectWithoutModuleInput[]
    createMany?: QuizCreateManyModuleInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ExerciseCreateWithoutModuleInput, ExerciseUncheckedCreateWithoutModuleInput> | ExerciseCreateWithoutModuleInput[] | ExerciseUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutModuleInput | ExerciseCreateOrConnectWithoutModuleInput[]
    createMany?: ExerciseCreateManyModuleInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ModuleProgressUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type FlashcardUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<FlashcardCreateWithoutModuleInput, FlashcardUncheckedCreateWithoutModuleInput> | FlashcardCreateWithoutModuleInput[] | FlashcardUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutModuleInput | FlashcardCreateOrConnectWithoutModuleInput[]
    createMany?: FlashcardCreateManyModuleInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ChatbotMessageCreateWithoutModuleInput, ChatbotMessageUncheckedCreateWithoutModuleInput> | ChatbotMessageCreateWithoutModuleInput[] | ChatbotMessageUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutModuleInput | ChatbotMessageCreateOrConnectWithoutModuleInput[]
    createMany?: ChatbotMessageCreateManyModuleInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type ContentUnitUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ContentUnitCreateWithoutModuleInput, ContentUnitUncheckedCreateWithoutModuleInput> | ContentUnitCreateWithoutModuleInput[] | ContentUnitUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutModuleInput | ContentUnitCreateOrConnectWithoutModuleInput[]
    upsert?: ContentUnitUpsertWithWhereUniqueWithoutModuleInput | ContentUnitUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ContentUnitCreateManyModuleInputEnvelope
    set?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    disconnect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    delete?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    update?: ContentUnitUpdateWithWhereUniqueWithoutModuleInput | ContentUnitUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ContentUnitUpdateManyWithWhereWithoutModuleInput | ContentUnitUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutModuleNestedInput = {
    create?: XOR<QuizCreateWithoutModuleInput, QuizUncheckedCreateWithoutModuleInput> | QuizCreateWithoutModuleInput[] | QuizUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutModuleInput | QuizCreateOrConnectWithoutModuleInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutModuleInput | QuizUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: QuizCreateManyModuleInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutModuleInput | QuizUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutModuleInput | QuizUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ExerciseCreateWithoutModuleInput, ExerciseUncheckedCreateWithoutModuleInput> | ExerciseCreateWithoutModuleInput[] | ExerciseUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutModuleInput | ExerciseCreateOrConnectWithoutModuleInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutModuleInput | ExerciseUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ExerciseCreateManyModuleInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutModuleInput | ExerciseUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutModuleInput | ExerciseUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ModuleProgressUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutModuleInput | ModuleProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutModuleInput | ModuleProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutModuleInput | ModuleProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type FlashcardUpdateManyWithoutModuleNestedInput = {
    create?: XOR<FlashcardCreateWithoutModuleInput, FlashcardUncheckedCreateWithoutModuleInput> | FlashcardCreateWithoutModuleInput[] | FlashcardUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutModuleInput | FlashcardCreateOrConnectWithoutModuleInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutModuleInput | FlashcardUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: FlashcardCreateManyModuleInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutModuleInput | FlashcardUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutModuleInput | FlashcardUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type ChatbotMessageUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutModuleInput, ChatbotMessageUncheckedCreateWithoutModuleInput> | ChatbotMessageCreateWithoutModuleInput[] | ChatbotMessageUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutModuleInput | ChatbotMessageCreateOrConnectWithoutModuleInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutModuleInput | ChatbotMessageUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ChatbotMessageCreateManyModuleInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutModuleInput | ChatbotMessageUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutModuleInput | ChatbotMessageUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type ContentUnitUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ContentUnitCreateWithoutModuleInput, ContentUnitUncheckedCreateWithoutModuleInput> | ContentUnitCreateWithoutModuleInput[] | ContentUnitUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutModuleInput | ContentUnitCreateOrConnectWithoutModuleInput[]
    upsert?: ContentUnitUpsertWithWhereUniqueWithoutModuleInput | ContentUnitUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ContentUnitCreateManyModuleInputEnvelope
    set?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    disconnect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    delete?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    update?: ContentUnitUpdateWithWhereUniqueWithoutModuleInput | ContentUnitUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ContentUnitUpdateManyWithWhereWithoutModuleInput | ContentUnitUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<QuizCreateWithoutModuleInput, QuizUncheckedCreateWithoutModuleInput> | QuizCreateWithoutModuleInput[] | QuizUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutModuleInput | QuizCreateOrConnectWithoutModuleInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutModuleInput | QuizUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: QuizCreateManyModuleInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutModuleInput | QuizUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutModuleInput | QuizUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ExerciseCreateWithoutModuleInput, ExerciseUncheckedCreateWithoutModuleInput> | ExerciseCreateWithoutModuleInput[] | ExerciseUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutModuleInput | ExerciseCreateOrConnectWithoutModuleInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutModuleInput | ExerciseUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ExerciseCreateManyModuleInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutModuleInput | ExerciseUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutModuleInput | ExerciseUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutModuleInput | ModuleProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutModuleInput | ModuleProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutModuleInput | ModuleProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type FlashcardUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<FlashcardCreateWithoutModuleInput, FlashcardUncheckedCreateWithoutModuleInput> | FlashcardCreateWithoutModuleInput[] | FlashcardUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutModuleInput | FlashcardCreateOrConnectWithoutModuleInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutModuleInput | FlashcardUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: FlashcardCreateManyModuleInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutModuleInput | FlashcardUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutModuleInput | FlashcardUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutModuleInput, ChatbotMessageUncheckedCreateWithoutModuleInput> | ChatbotMessageCreateWithoutModuleInput[] | ChatbotMessageUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutModuleInput | ChatbotMessageCreateOrConnectWithoutModuleInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutModuleInput | ChatbotMessageUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ChatbotMessageCreateManyModuleInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutModuleInput | ChatbotMessageUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutModuleInput | ChatbotMessageUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type CourseModuleCreateNestedOneWithoutUnitsInput = {
    create?: XOR<CourseModuleCreateWithoutUnitsInput, CourseModuleUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutUnitsInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type UnitProgressCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitProgressCreateWithoutUnitInput, UnitProgressUncheckedCreateWithoutUnitInput> | UnitProgressCreateWithoutUnitInput[] | UnitProgressUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutUnitInput | UnitProgressCreateOrConnectWithoutUnitInput[]
    createMany?: UnitProgressCreateManyUnitInputEnvelope
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
  }

  export type UnitAttachmentCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAttachmentCreateWithoutUnitInput, UnitAttachmentUncheckedCreateWithoutUnitInput> | UnitAttachmentCreateWithoutUnitInput[] | UnitAttachmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAttachmentCreateOrConnectWithoutUnitInput | UnitAttachmentCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAttachmentCreateManyUnitInputEnvelope
    connect?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
  }

  export type UnitProgressUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitProgressCreateWithoutUnitInput, UnitProgressUncheckedCreateWithoutUnitInput> | UnitProgressCreateWithoutUnitInput[] | UnitProgressUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutUnitInput | UnitProgressCreateOrConnectWithoutUnitInput[]
    createMany?: UnitProgressCreateManyUnitInputEnvelope
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
  }

  export type UnitAttachmentUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAttachmentCreateWithoutUnitInput, UnitAttachmentUncheckedCreateWithoutUnitInput> | UnitAttachmentCreateWithoutUnitInput[] | UnitAttachmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAttachmentCreateOrConnectWithoutUnitInput | UnitAttachmentCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAttachmentCreateManyUnitInputEnvelope
    connect?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type CourseModuleUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<CourseModuleCreateWithoutUnitsInput, CourseModuleUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutUnitsInput
    upsert?: CourseModuleUpsertWithoutUnitsInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutUnitsInput, CourseModuleUpdateWithoutUnitsInput>, CourseModuleUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitProgressUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitProgressCreateWithoutUnitInput, UnitProgressUncheckedCreateWithoutUnitInput> | UnitProgressCreateWithoutUnitInput[] | UnitProgressUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutUnitInput | UnitProgressCreateOrConnectWithoutUnitInput[]
    upsert?: UnitProgressUpsertWithWhereUniqueWithoutUnitInput | UnitProgressUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitProgressCreateManyUnitInputEnvelope
    set?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    disconnect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    delete?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    update?: UnitProgressUpdateWithWhereUniqueWithoutUnitInput | UnitProgressUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitProgressUpdateManyWithWhereWithoutUnitInput | UnitProgressUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitProgressScalarWhereInput | UnitProgressScalarWhereInput[]
  }

  export type UnitAttachmentUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAttachmentCreateWithoutUnitInput, UnitAttachmentUncheckedCreateWithoutUnitInput> | UnitAttachmentCreateWithoutUnitInput[] | UnitAttachmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAttachmentCreateOrConnectWithoutUnitInput | UnitAttachmentCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAttachmentUpsertWithWhereUniqueWithoutUnitInput | UnitAttachmentUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAttachmentCreateManyUnitInputEnvelope
    set?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    disconnect?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    delete?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    connect?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    update?: UnitAttachmentUpdateWithWhereUniqueWithoutUnitInput | UnitAttachmentUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAttachmentUpdateManyWithWhereWithoutUnitInput | UnitAttachmentUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAttachmentScalarWhereInput | UnitAttachmentScalarWhereInput[]
  }

  export type UnitProgressUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitProgressCreateWithoutUnitInput, UnitProgressUncheckedCreateWithoutUnitInput> | UnitProgressCreateWithoutUnitInput[] | UnitProgressUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutUnitInput | UnitProgressCreateOrConnectWithoutUnitInput[]
    upsert?: UnitProgressUpsertWithWhereUniqueWithoutUnitInput | UnitProgressUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitProgressCreateManyUnitInputEnvelope
    set?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    disconnect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    delete?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    update?: UnitProgressUpdateWithWhereUniqueWithoutUnitInput | UnitProgressUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitProgressUpdateManyWithWhereWithoutUnitInput | UnitProgressUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitProgressScalarWhereInput | UnitProgressScalarWhereInput[]
  }

  export type UnitAttachmentUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAttachmentCreateWithoutUnitInput, UnitAttachmentUncheckedCreateWithoutUnitInput> | UnitAttachmentCreateWithoutUnitInput[] | UnitAttachmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAttachmentCreateOrConnectWithoutUnitInput | UnitAttachmentCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAttachmentUpsertWithWhereUniqueWithoutUnitInput | UnitAttachmentUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAttachmentCreateManyUnitInputEnvelope
    set?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    disconnect?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    delete?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    connect?: UnitAttachmentWhereUniqueInput | UnitAttachmentWhereUniqueInput[]
    update?: UnitAttachmentUpdateWithWhereUniqueWithoutUnitInput | UnitAttachmentUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAttachmentUpdateManyWithWhereWithoutUnitInput | UnitAttachmentUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAttachmentScalarWhereInput | UnitAttachmentScalarWhereInput[]
  }

  export type ContentUnitCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ContentUnitCreateWithoutAttachmentsInput, ContentUnitUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ContentUnitCreateOrConnectWithoutAttachmentsInput
    connect?: ContentUnitWhereUniqueInput
  }

  export type ContentUnitUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<ContentUnitCreateWithoutAttachmentsInput, ContentUnitUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ContentUnitCreateOrConnectWithoutAttachmentsInput
    upsert?: ContentUnitUpsertWithoutAttachmentsInput
    connect?: ContentUnitWhereUniqueInput
    update?: XOR<XOR<ContentUnitUpdateToOneWithWhereWithoutAttachmentsInput, ContentUnitUpdateWithoutAttachmentsInput>, ContentUnitUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ModuleProgressCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<ModuleProgressCreateWithoutEnrollmentInput, ModuleProgressUncheckedCreateWithoutEnrollmentInput> | ModuleProgressCreateWithoutEnrollmentInput[] | ModuleProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutEnrollmentInput | ModuleProgressCreateOrConnectWithoutEnrollmentInput[]
    createMany?: ModuleProgressCreateManyEnrollmentInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type UnitProgressCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<UnitProgressCreateWithoutEnrollmentInput, UnitProgressUncheckedCreateWithoutEnrollmentInput> | UnitProgressCreateWithoutEnrollmentInput[] | UnitProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutEnrollmentInput | UnitProgressCreateOrConnectWithoutEnrollmentInput[]
    createMany?: UnitProgressCreateManyEnrollmentInputEnvelope
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<QuizAttemptCreateWithoutEnrollmentInput, QuizAttemptUncheckedCreateWithoutEnrollmentInput> | QuizAttemptCreateWithoutEnrollmentInput[] | QuizAttemptUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutEnrollmentInput | QuizAttemptCreateOrConnectWithoutEnrollmentInput[]
    createMany?: QuizAttemptCreateManyEnrollmentInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutEnrollmentInput, ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput> | ExerciseSubmissionCreateWithoutEnrollmentInput[] | ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput | ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput[]
    createMany?: ExerciseSubmissionCreateManyEnrollmentInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<ModuleProgressCreateWithoutEnrollmentInput, ModuleProgressUncheckedCreateWithoutEnrollmentInput> | ModuleProgressCreateWithoutEnrollmentInput[] | ModuleProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutEnrollmentInput | ModuleProgressCreateOrConnectWithoutEnrollmentInput[]
    createMany?: ModuleProgressCreateManyEnrollmentInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<UnitProgressCreateWithoutEnrollmentInput, UnitProgressUncheckedCreateWithoutEnrollmentInput> | UnitProgressCreateWithoutEnrollmentInput[] | UnitProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutEnrollmentInput | UnitProgressCreateOrConnectWithoutEnrollmentInput[]
    createMany?: UnitProgressCreateManyEnrollmentInputEnvelope
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<QuizAttemptCreateWithoutEnrollmentInput, QuizAttemptUncheckedCreateWithoutEnrollmentInput> | QuizAttemptCreateWithoutEnrollmentInput[] | QuizAttemptUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutEnrollmentInput | QuizAttemptCreateOrConnectWithoutEnrollmentInput[]
    createMany?: QuizAttemptCreateManyEnrollmentInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutEnrollmentInput, ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput> | ExerciseSubmissionCreateWithoutEnrollmentInput[] | ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput | ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput[]
    createMany?: ExerciseSubmissionCreateManyEnrollmentInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type EnumEnrollmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnrollmentStatus
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ModuleProgressUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutEnrollmentInput, ModuleProgressUncheckedCreateWithoutEnrollmentInput> | ModuleProgressCreateWithoutEnrollmentInput[] | ModuleProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutEnrollmentInput | ModuleProgressCreateOrConnectWithoutEnrollmentInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutEnrollmentInput | ModuleProgressUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: ModuleProgressCreateManyEnrollmentInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutEnrollmentInput | ModuleProgressUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutEnrollmentInput | ModuleProgressUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type UnitProgressUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<UnitProgressCreateWithoutEnrollmentInput, UnitProgressUncheckedCreateWithoutEnrollmentInput> | UnitProgressCreateWithoutEnrollmentInput[] | UnitProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutEnrollmentInput | UnitProgressCreateOrConnectWithoutEnrollmentInput[]
    upsert?: UnitProgressUpsertWithWhereUniqueWithoutEnrollmentInput | UnitProgressUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: UnitProgressCreateManyEnrollmentInputEnvelope
    set?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    disconnect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    delete?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    update?: UnitProgressUpdateWithWhereUniqueWithoutEnrollmentInput | UnitProgressUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: UnitProgressUpdateManyWithWhereWithoutEnrollmentInput | UnitProgressUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: UnitProgressScalarWhereInput | UnitProgressScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutEnrollmentInput, QuizAttemptUncheckedCreateWithoutEnrollmentInput> | QuizAttemptCreateWithoutEnrollmentInput[] | QuizAttemptUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutEnrollmentInput | QuizAttemptCreateOrConnectWithoutEnrollmentInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutEnrollmentInput | QuizAttemptUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: QuizAttemptCreateManyEnrollmentInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutEnrollmentInput | QuizAttemptUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutEnrollmentInput | QuizAttemptUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutEnrollmentInput, ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput> | ExerciseSubmissionCreateWithoutEnrollmentInput[] | ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput | ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutEnrollmentInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: ExerciseSubmissionCreateManyEnrollmentInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutEnrollmentInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutEnrollmentInput | ExerciseSubmissionUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutEnrollmentInput, ModuleProgressUncheckedCreateWithoutEnrollmentInput> | ModuleProgressCreateWithoutEnrollmentInput[] | ModuleProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutEnrollmentInput | ModuleProgressCreateOrConnectWithoutEnrollmentInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutEnrollmentInput | ModuleProgressUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: ModuleProgressCreateManyEnrollmentInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutEnrollmentInput | ModuleProgressUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutEnrollmentInput | ModuleProgressUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<UnitProgressCreateWithoutEnrollmentInput, UnitProgressUncheckedCreateWithoutEnrollmentInput> | UnitProgressCreateWithoutEnrollmentInput[] | UnitProgressUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: UnitProgressCreateOrConnectWithoutEnrollmentInput | UnitProgressCreateOrConnectWithoutEnrollmentInput[]
    upsert?: UnitProgressUpsertWithWhereUniqueWithoutEnrollmentInput | UnitProgressUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: UnitProgressCreateManyEnrollmentInputEnvelope
    set?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    disconnect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    delete?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    connect?: UnitProgressWhereUniqueInput | UnitProgressWhereUniqueInput[]
    update?: UnitProgressUpdateWithWhereUniqueWithoutEnrollmentInput | UnitProgressUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: UnitProgressUpdateManyWithWhereWithoutEnrollmentInput | UnitProgressUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: UnitProgressScalarWhereInput | UnitProgressScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutEnrollmentInput, QuizAttemptUncheckedCreateWithoutEnrollmentInput> | QuizAttemptCreateWithoutEnrollmentInput[] | QuizAttemptUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutEnrollmentInput | QuizAttemptCreateOrConnectWithoutEnrollmentInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutEnrollmentInput | QuizAttemptUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: QuizAttemptCreateManyEnrollmentInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutEnrollmentInput | QuizAttemptUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutEnrollmentInput | QuizAttemptUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutEnrollmentInput, ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput> | ExerciseSubmissionCreateWithoutEnrollmentInput[] | ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput | ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutEnrollmentInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: ExerciseSubmissionCreateManyEnrollmentInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutEnrollmentInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutEnrollmentInput | ExerciseSubmissionUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type EnrollmentCreateNestedOneWithoutModuleProgressInput = {
    create?: XOR<EnrollmentCreateWithoutModuleProgressInput, EnrollmentUncheckedCreateWithoutModuleProgressInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutModuleProgressInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type CourseModuleCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<CourseModuleCreateWithoutUserProgressInput, CourseModuleUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutUserProgressInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type EnrollmentUpdateOneRequiredWithoutModuleProgressNestedInput = {
    create?: XOR<EnrollmentCreateWithoutModuleProgressInput, EnrollmentUncheckedCreateWithoutModuleProgressInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutModuleProgressInput
    upsert?: EnrollmentUpsertWithoutModuleProgressInput
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutModuleProgressInput, EnrollmentUpdateWithoutModuleProgressInput>, EnrollmentUncheckedUpdateWithoutModuleProgressInput>
  }

  export type CourseModuleUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<CourseModuleCreateWithoutUserProgressInput, CourseModuleUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutUserProgressInput
    upsert?: CourseModuleUpsertWithoutUserProgressInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutUserProgressInput, CourseModuleUpdateWithoutUserProgressInput>, CourseModuleUncheckedUpdateWithoutUserProgressInput>
  }

  export type EnrollmentCreateNestedOneWithoutUnitProgressInput = {
    create?: XOR<EnrollmentCreateWithoutUnitProgressInput, EnrollmentUncheckedCreateWithoutUnitProgressInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUnitProgressInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type ContentUnitCreateNestedOneWithoutProgressInput = {
    create?: XOR<ContentUnitCreateWithoutProgressInput, ContentUnitUncheckedCreateWithoutProgressInput>
    connectOrCreate?: ContentUnitCreateOrConnectWithoutProgressInput
    connect?: ContentUnitWhereUniqueInput
  }

  export type EnrollmentUpdateOneRequiredWithoutUnitProgressNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUnitProgressInput, EnrollmentUncheckedCreateWithoutUnitProgressInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUnitProgressInput
    upsert?: EnrollmentUpsertWithoutUnitProgressInput
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutUnitProgressInput, EnrollmentUpdateWithoutUnitProgressInput>, EnrollmentUncheckedUpdateWithoutUnitProgressInput>
  }

  export type ContentUnitUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<ContentUnitCreateWithoutProgressInput, ContentUnitUncheckedCreateWithoutProgressInput>
    connectOrCreate?: ContentUnitCreateOrConnectWithoutProgressInput
    upsert?: ContentUnitUpsertWithoutProgressInput
    connect?: ContentUnitWhereUniqueInput
    update?: XOR<XOR<ContentUnitUpdateToOneWithWhereWithoutProgressInput, ContentUnitUpdateWithoutProgressInput>, ContentUnitUncheckedUpdateWithoutProgressInput>
  }

  export type CourseModuleCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<CourseModuleCreateWithoutQuizzesInput, CourseModuleUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutQuizzesInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type CourseModuleUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<CourseModuleCreateWithoutQuizzesInput, CourseModuleUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutQuizzesInput
    upsert?: CourseModuleUpsertWithoutQuizzesInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutQuizzesInput, CourseModuleUpdateWithoutQuizzesInput>, CourseModuleUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuestionAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutQuestionInput | QuestionAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutQuestionInput | QuestionAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type EnrollmentCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<EnrollmentCreateWithoutQuizAttemptsInput, EnrollmentUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutQuizAttemptsInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuestionAnswerCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionAnswerCreateWithoutAttemptInput, QuestionAnswerUncheckedCreateWithoutAttemptInput> | QuestionAnswerCreateWithoutAttemptInput[] | QuestionAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAttemptInput | QuestionAnswerCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionAnswerCreateManyAttemptInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionAnswerCreateWithoutAttemptInput, QuestionAnswerUncheckedCreateWithoutAttemptInput> | QuestionAnswerCreateWithoutAttemptInput[] | QuestionAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAttemptInput | QuestionAnswerCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionAnswerCreateManyAttemptInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnrollmentUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<EnrollmentCreateWithoutQuizAttemptsInput, EnrollmentUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutQuizAttemptsInput
    upsert?: EnrollmentUpsertWithoutQuizAttemptsInput
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutQuizAttemptsInput, EnrollmentUpdateWithoutQuizAttemptsInput>, EnrollmentUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuizUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    upsert?: QuizUpsertWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutAttemptsInput, QuizUpdateWithoutAttemptsInput>, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuestionAnswerUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAttemptInput, QuestionAnswerUncheckedCreateWithoutAttemptInput> | QuestionAnswerCreateWithoutAttemptInput[] | QuestionAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAttemptInput | QuestionAnswerCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAttemptInput | QuestionAnswerUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionAnswerCreateManyAttemptInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAttemptInput | QuestionAnswerUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAttemptInput | QuestionAnswerUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAttemptInput, QuestionAnswerUncheckedCreateWithoutAttemptInput> | QuestionAnswerCreateWithoutAttemptInput[] | QuestionAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAttemptInput | QuestionAnswerCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAttemptInput | QuestionAnswerUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionAnswerCreateManyAttemptInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAttemptInput | QuestionAnswerUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAttemptInput | QuestionAnswerUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuizAttemptCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAnswersInput
    connect?: QuizAttemptWhereUniqueInput
  }

  export type QuizQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAnswersInput
    upsert?: QuizAttemptUpsertWithoutAnswersInput
    connect?: QuizAttemptWhereUniqueInput
    update?: XOR<XOR<QuizAttemptUpdateToOneWithWhereWithoutAnswersInput, QuizAttemptUpdateWithoutAnswersInput>, QuizAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuizQuestionUpsertWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutAnswersInput, QuizQuestionUpdateWithoutAnswersInput>, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type CourseModuleCreateNestedOneWithoutExercisesInput = {
    create?: XOR<CourseModuleCreateWithoutExercisesInput, CourseModuleUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutExercisesInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type ExerciseSubmissionCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type EnumExerciseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExerciseType
  }

  export type CourseModuleUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<CourseModuleCreateWithoutExercisesInput, CourseModuleUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutExercisesInput
    upsert?: CourseModuleUpsertWithoutExercisesInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutExercisesInput, CourseModuleUpdateWithoutExercisesInput>, CourseModuleUncheckedUpdateWithoutExercisesInput>
  }

  export type ExerciseSubmissionUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput | ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput | ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSubmissionsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type EnrollmentCreateNestedOneWithoutExerciseSubmissionsInput = {
    create?: XOR<EnrollmentCreateWithoutExerciseSubmissionsInput, EnrollmentUncheckedCreateWithoutExerciseSubmissionsInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutExerciseSubmissionsInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSubmissionsInput
    upsert?: ExerciseUpsertWithoutSubmissionsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutSubmissionsInput, ExerciseUpdateWithoutSubmissionsInput>, ExerciseUncheckedUpdateWithoutSubmissionsInput>
  }

  export type EnrollmentUpdateOneRequiredWithoutExerciseSubmissionsNestedInput = {
    create?: XOR<EnrollmentCreateWithoutExerciseSubmissionsInput, EnrollmentUncheckedCreateWithoutExerciseSubmissionsInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutExerciseSubmissionsInput
    upsert?: EnrollmentUpsertWithoutExerciseSubmissionsInput
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutExerciseSubmissionsInput, EnrollmentUpdateWithoutExerciseSubmissionsInput>, EnrollmentUncheckedUpdateWithoutExerciseSubmissionsInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    upsert?: CourseUpsertWithoutReviewsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutReviewsInput, CourseUpdateWithoutReviewsInput>, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type MentorshipCreateNestedManyWithoutProgramInput = {
    create?: XOR<MentorshipCreateWithoutProgramInput, MentorshipUncheckedCreateWithoutProgramInput> | MentorshipCreateWithoutProgramInput[] | MentorshipUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramInput | MentorshipCreateOrConnectWithoutProgramInput[]
    createMany?: MentorshipCreateManyProgramInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<MentorshipCreateWithoutProgramInput, MentorshipUncheckedCreateWithoutProgramInput> | MentorshipCreateWithoutProgramInput[] | MentorshipUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramInput | MentorshipCreateOrConnectWithoutProgramInput[]
    createMany?: MentorshipCreateManyProgramInputEnvelope
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
  }

  export type MentorshipUpdateManyWithoutProgramNestedInput = {
    create?: XOR<MentorshipCreateWithoutProgramInput, MentorshipUncheckedCreateWithoutProgramInput> | MentorshipCreateWithoutProgramInput[] | MentorshipUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramInput | MentorshipCreateOrConnectWithoutProgramInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutProgramInput | MentorshipUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: MentorshipCreateManyProgramInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutProgramInput | MentorshipUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutProgramInput | MentorshipUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type MentorshipUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<MentorshipCreateWithoutProgramInput, MentorshipUncheckedCreateWithoutProgramInput> | MentorshipCreateWithoutProgramInput[] | MentorshipUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MentorshipCreateOrConnectWithoutProgramInput | MentorshipCreateOrConnectWithoutProgramInput[]
    upsert?: MentorshipUpsertWithWhereUniqueWithoutProgramInput | MentorshipUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: MentorshipCreateManyProgramInputEnvelope
    set?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    disconnect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    delete?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    connect?: MentorshipWhereUniqueInput | MentorshipWhereUniqueInput[]
    update?: MentorshipUpdateWithWhereUniqueWithoutProgramInput | MentorshipUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: MentorshipUpdateManyWithWhereWithoutProgramInput | MentorshipUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMenteeRelationshipsInput = {
    create?: XOR<UserCreateWithoutMenteeRelationshipsInput, UserUncheckedCreateWithoutMenteeRelationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenteeRelationshipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMentorRelationshipsInput = {
    create?: XOR<UserCreateWithoutMentorRelationshipsInput, UserUncheckedCreateWithoutMentorRelationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorRelationshipsInput
    connect?: UserWhereUniqueInput
  }

  export type MentorshipProgramCreateNestedOneWithoutRelationshipsInput = {
    create?: XOR<MentorshipProgramCreateWithoutRelationshipsInput, MentorshipProgramUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: MentorshipProgramCreateOrConnectWithoutRelationshipsInput
    connect?: MentorshipProgramWhereUniqueInput
  }

  export type MentorshipSessionCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<MentorshipSessionCreateWithoutRelationshipInput, MentorshipSessionUncheckedCreateWithoutRelationshipInput> | MentorshipSessionCreateWithoutRelationshipInput[] | MentorshipSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MentorshipSessionCreateOrConnectWithoutRelationshipInput | MentorshipSessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: MentorshipSessionCreateManyRelationshipInputEnvelope
    connect?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
  }

  export type MentorshipSessionUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<MentorshipSessionCreateWithoutRelationshipInput, MentorshipSessionUncheckedCreateWithoutRelationshipInput> | MentorshipSessionCreateWithoutRelationshipInput[] | MentorshipSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MentorshipSessionCreateOrConnectWithoutRelationshipInput | MentorshipSessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: MentorshipSessionCreateManyRelationshipInputEnvelope
    connect?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
  }

  export type EnumStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.StatusType
  }

  export type UserUpdateOneRequiredWithoutMenteeRelationshipsNestedInput = {
    create?: XOR<UserCreateWithoutMenteeRelationshipsInput, UserUncheckedCreateWithoutMenteeRelationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenteeRelationshipsInput
    upsert?: UserUpsertWithoutMenteeRelationshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMenteeRelationshipsInput, UserUpdateWithoutMenteeRelationshipsInput>, UserUncheckedUpdateWithoutMenteeRelationshipsInput>
  }

  export type UserUpdateOneRequiredWithoutMentorRelationshipsNestedInput = {
    create?: XOR<UserCreateWithoutMentorRelationshipsInput, UserUncheckedCreateWithoutMentorRelationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorRelationshipsInput
    upsert?: UserUpsertWithoutMentorRelationshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentorRelationshipsInput, UserUpdateWithoutMentorRelationshipsInput>, UserUncheckedUpdateWithoutMentorRelationshipsInput>
  }

  export type MentorshipProgramUpdateOneWithoutRelationshipsNestedInput = {
    create?: XOR<MentorshipProgramCreateWithoutRelationshipsInput, MentorshipProgramUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: MentorshipProgramCreateOrConnectWithoutRelationshipsInput
    upsert?: MentorshipProgramUpsertWithoutRelationshipsInput
    disconnect?: MentorshipProgramWhereInput | boolean
    delete?: MentorshipProgramWhereInput | boolean
    connect?: MentorshipProgramWhereUniqueInput
    update?: XOR<XOR<MentorshipProgramUpdateToOneWithWhereWithoutRelationshipsInput, MentorshipProgramUpdateWithoutRelationshipsInput>, MentorshipProgramUncheckedUpdateWithoutRelationshipsInput>
  }

  export type MentorshipSessionUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<MentorshipSessionCreateWithoutRelationshipInput, MentorshipSessionUncheckedCreateWithoutRelationshipInput> | MentorshipSessionCreateWithoutRelationshipInput[] | MentorshipSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MentorshipSessionCreateOrConnectWithoutRelationshipInput | MentorshipSessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: MentorshipSessionUpsertWithWhereUniqueWithoutRelationshipInput | MentorshipSessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: MentorshipSessionCreateManyRelationshipInputEnvelope
    set?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    disconnect?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    delete?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    connect?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    update?: MentorshipSessionUpdateWithWhereUniqueWithoutRelationshipInput | MentorshipSessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: MentorshipSessionUpdateManyWithWhereWithoutRelationshipInput | MentorshipSessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: MentorshipSessionScalarWhereInput | MentorshipSessionScalarWhereInput[]
  }

  export type MentorshipSessionUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<MentorshipSessionCreateWithoutRelationshipInput, MentorshipSessionUncheckedCreateWithoutRelationshipInput> | MentorshipSessionCreateWithoutRelationshipInput[] | MentorshipSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MentorshipSessionCreateOrConnectWithoutRelationshipInput | MentorshipSessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: MentorshipSessionUpsertWithWhereUniqueWithoutRelationshipInput | MentorshipSessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: MentorshipSessionCreateManyRelationshipInputEnvelope
    set?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    disconnect?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    delete?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    connect?: MentorshipSessionWhereUniqueInput | MentorshipSessionWhereUniqueInput[]
    update?: MentorshipSessionUpdateWithWhereUniqueWithoutRelationshipInput | MentorshipSessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: MentorshipSessionUpdateManyWithWhereWithoutRelationshipInput | MentorshipSessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: MentorshipSessionScalarWhereInput | MentorshipSessionScalarWhereInput[]
  }

  export type MentorshipCreateNestedOneWithoutSessionsInput = {
    create?: XOR<MentorshipCreateWithoutSessionsInput, MentorshipUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutSessionsInput
    connect?: MentorshipWhereUniqueInput
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type MentorshipUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<MentorshipCreateWithoutSessionsInput, MentorshipUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: MentorshipCreateOrConnectWithoutSessionsInput
    upsert?: MentorshipUpsertWithoutSessionsInput
    connect?: MentorshipWhereUniqueInput
    update?: XOR<XOR<MentorshipUpdateToOneWithWhereWithoutSessionsInput, MentorshipUpdateWithoutSessionsInput>, MentorshipUncheckedUpdateWithoutSessionsInput>
  }

  export type EventRegistrationCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EventRegistrationUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventRegistrationsInput = {
    create?: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRegistrationsInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    upsert?: EventUpsertWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRegistrationsInput, EventUpdateWithoutRegistrationsInput>, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type UserUpdateOneRequiredWithoutEventRegistrationsNestedInput = {
    create?: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRegistrationsInput
    upsert?: UserUpsertWithoutEventRegistrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventRegistrationsInput, UserUpdateWithoutEventRegistrationsInput>, UserUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type UserCreateNestedOneWithoutCreatedCommunitiesInput = {
    create?: XOR<UserCreateWithoutCreatedCommunitiesInput, UserUncheckedCreateWithoutCreatedCommunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCommunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityMemberCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedCommunitiesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCommunitiesInput, UserUncheckedCreateWithoutCreatedCommunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCommunitiesInput
    upsert?: UserUpsertWithoutCreatedCommunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCommunitiesInput, UserUpdateWithoutCreatedCommunitiesInput>, UserUncheckedUpdateWithoutCreatedCommunitiesInput>
  }

  export type CommunityMemberUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput | CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput | CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutCommunityInput | CommunityMemberUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput | CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput | CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutCommunityInput | CommunityMemberUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommunityCreateNestedOneWithoutMembersInput = {
    create?: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutMembersInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityMembershipsInput = {
    create?: XOR<UserCreateWithoutCommunityMembershipsInput, UserUncheckedCreateWithoutCommunityMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCommunityRoleFieldUpdateOperationsInput = {
    set?: $Enums.CommunityRole
  }

  export type CommunityUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutMembersInput
    upsert?: CommunityUpsertWithoutMembersInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutMembersInput, CommunityUpdateWithoutMembersInput>, CommunityUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutCommunityMembershipsInput, UserUncheckedCreateWithoutCommunityMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityMembershipsInput
    upsert?: UserUpsertWithoutCommunityMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunityMembershipsInput, UserUpdateWithoutCommunityMembershipsInput>, UserUncheckedUpdateWithoutCommunityMembershipsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutPostsInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput
    connect?: CommunityWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type CommunityUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput
    upsert?: CommunityUpsertWithoutPostsInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutPostsInput, CommunityUpdateWithoutPostsInput>, CommunityUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutCreatedProjectsInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    upsert?: UserUpsertWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProjectsInput, UserUpdateWithoutCreatedProjectsInput>, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectRole
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    upsert?: UserUpsertWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembershipsInput, UserUpdateWithoutProjectMembershipsInput>, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type SponsorshipCreateNestedManyWithoutSponsorInput = {
    create?: XOR<SponsorshipCreateWithoutSponsorInput, SponsorshipUncheckedCreateWithoutSponsorInput> | SponsorshipCreateWithoutSponsorInput[] | SponsorshipUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorshipCreateOrConnectWithoutSponsorInput | SponsorshipCreateOrConnectWithoutSponsorInput[]
    createMany?: SponsorshipCreateManySponsorInputEnvelope
    connect?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
  }

  export type SponsorshipUncheckedCreateNestedManyWithoutSponsorInput = {
    create?: XOR<SponsorshipCreateWithoutSponsorInput, SponsorshipUncheckedCreateWithoutSponsorInput> | SponsorshipCreateWithoutSponsorInput[] | SponsorshipUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorshipCreateOrConnectWithoutSponsorInput | SponsorshipCreateOrConnectWithoutSponsorInput[]
    createMany?: SponsorshipCreateManySponsorInputEnvelope
    connect?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
  }

  export type SponsorshipUpdateManyWithoutSponsorNestedInput = {
    create?: XOR<SponsorshipCreateWithoutSponsorInput, SponsorshipUncheckedCreateWithoutSponsorInput> | SponsorshipCreateWithoutSponsorInput[] | SponsorshipUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorshipCreateOrConnectWithoutSponsorInput | SponsorshipCreateOrConnectWithoutSponsorInput[]
    upsert?: SponsorshipUpsertWithWhereUniqueWithoutSponsorInput | SponsorshipUpsertWithWhereUniqueWithoutSponsorInput[]
    createMany?: SponsorshipCreateManySponsorInputEnvelope
    set?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    disconnect?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    delete?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    connect?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    update?: SponsorshipUpdateWithWhereUniqueWithoutSponsorInput | SponsorshipUpdateWithWhereUniqueWithoutSponsorInput[]
    updateMany?: SponsorshipUpdateManyWithWhereWithoutSponsorInput | SponsorshipUpdateManyWithWhereWithoutSponsorInput[]
    deleteMany?: SponsorshipScalarWhereInput | SponsorshipScalarWhereInput[]
  }

  export type SponsorshipUncheckedUpdateManyWithoutSponsorNestedInput = {
    create?: XOR<SponsorshipCreateWithoutSponsorInput, SponsorshipUncheckedCreateWithoutSponsorInput> | SponsorshipCreateWithoutSponsorInput[] | SponsorshipUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorshipCreateOrConnectWithoutSponsorInput | SponsorshipCreateOrConnectWithoutSponsorInput[]
    upsert?: SponsorshipUpsertWithWhereUniqueWithoutSponsorInput | SponsorshipUpsertWithWhereUniqueWithoutSponsorInput[]
    createMany?: SponsorshipCreateManySponsorInputEnvelope
    set?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    disconnect?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    delete?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    connect?: SponsorshipWhereUniqueInput | SponsorshipWhereUniqueInput[]
    update?: SponsorshipUpdateWithWhereUniqueWithoutSponsorInput | SponsorshipUpdateWithWhereUniqueWithoutSponsorInput[]
    updateMany?: SponsorshipUpdateManyWithWhereWithoutSponsorInput | SponsorshipUpdateManyWithWhereWithoutSponsorInput[]
    deleteMany?: SponsorshipScalarWhereInput | SponsorshipScalarWhereInput[]
  }

  export type SponsorCreateNestedOneWithoutSponsorshipsInput = {
    create?: XOR<SponsorCreateWithoutSponsorshipsInput, SponsorUncheckedCreateWithoutSponsorshipsInput>
    connectOrCreate?: SponsorCreateOrConnectWithoutSponsorshipsInput
    connect?: SponsorWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumSponsorshipTypeFieldUpdateOperationsInput = {
    set?: $Enums.SponsorshipType
  }

  export type SponsorUpdateOneRequiredWithoutSponsorshipsNestedInput = {
    create?: XOR<SponsorCreateWithoutSponsorshipsInput, SponsorUncheckedCreateWithoutSponsorshipsInput>
    connectOrCreate?: SponsorCreateOrConnectWithoutSponsorshipsInput
    upsert?: SponsorUpsertWithoutSponsorshipsInput
    connect?: SponsorWhereUniqueInput
    update?: XOR<XOR<SponsorUpdateToOneWithWhereWithoutSponsorshipsInput, SponsorUpdateWithoutSponsorshipsInput>, SponsorUncheckedUpdateWithoutSponsorshipsInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementUpsertWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementUpdateWithoutUserAchievementsInput>, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutUploadedResourcesInput = {
    create?: XOR<UserCreateWithoutUploadedResourcesInput, UserUncheckedCreateWithoutUploadedResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type UserUpdateOneRequiredWithoutUploadedResourcesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedResourcesInput, UserUncheckedCreateWithoutUploadedResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedResourcesInput
    upsert?: UserUpsertWithoutUploadedResourcesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedResourcesInput, UserUpdateWithoutUploadedResourcesInput>, UserUncheckedUpdateWithoutUploadedResourcesInput>
  }

  export type CourseCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<CourseCreateWithoutAssessmentsInput, CourseUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutAssessmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type AssessmentQuestionCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
  }

  export type UserAssessmentAttemptCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutAssessmentInput, UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput> | UserAssessmentAttemptCreateWithoutAssessmentInput[] | UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput | UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput[]
    createMany?: UserAssessmentAttemptCreateManyAssessmentInputEnvelope
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
  }

  export type AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
  }

  export type UserAssessmentAttemptUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutAssessmentInput, UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput> | UserAssessmentAttemptCreateWithoutAssessmentInput[] | UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput | UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput[]
    createMany?: UserAssessmentAttemptCreateManyAssessmentInputEnvelope
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<CourseCreateWithoutAssessmentsInput, CourseUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutAssessmentsInput
    upsert?: CourseUpsertWithoutAssessmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutAssessmentsInput, CourseUpdateWithoutAssessmentsInput>, CourseUncheckedUpdateWithoutAssessmentsInput>
  }

  export type AssessmentQuestionUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    set?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    disconnect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    delete?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    update?: AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput | AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
  }

  export type UserAssessmentAttemptUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutAssessmentInput, UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput> | UserAssessmentAttemptCreateWithoutAssessmentInput[] | UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput | UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput[]
    upsert?: UserAssessmentAttemptUpsertWithWhereUniqueWithoutAssessmentInput | UserAssessmentAttemptUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: UserAssessmentAttemptCreateManyAssessmentInputEnvelope
    set?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    disconnect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    delete?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    update?: UserAssessmentAttemptUpdateWithWhereUniqueWithoutAssessmentInput | UserAssessmentAttemptUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: UserAssessmentAttemptUpdateManyWithWhereWithoutAssessmentInput | UserAssessmentAttemptUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: UserAssessmentAttemptScalarWhereInput | UserAssessmentAttemptScalarWhereInput[]
  }

  export type AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    set?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    disconnect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    delete?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    update?: AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput | AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
  }

  export type UserAssessmentAttemptUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<UserAssessmentAttemptCreateWithoutAssessmentInput, UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput> | UserAssessmentAttemptCreateWithoutAssessmentInput[] | UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput | UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput[]
    upsert?: UserAssessmentAttemptUpsertWithWhereUniqueWithoutAssessmentInput | UserAssessmentAttemptUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: UserAssessmentAttemptCreateManyAssessmentInputEnvelope
    set?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    disconnect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    delete?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    connect?: UserAssessmentAttemptWhereUniqueInput | UserAssessmentAttemptWhereUniqueInput[]
    update?: UserAssessmentAttemptUpdateWithWhereUniqueWithoutAssessmentInput | UserAssessmentAttemptUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: UserAssessmentAttemptUpdateManyWithWhereWithoutAssessmentInput | UserAssessmentAttemptUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: UserAssessmentAttemptScalarWhereInput | UserAssessmentAttemptScalarWhereInput[]
  }

  export type AssessmentCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<AssessmentCreateWithoutQuestionsInput, AssessmentUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutQuestionsInput
    connect?: AssessmentWhereUniqueInput
  }

  export type AssessmentUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<AssessmentCreateWithoutQuestionsInput, AssessmentUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutQuestionsInput
    upsert?: AssessmentUpsertWithoutQuestionsInput
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutQuestionsInput, AssessmentUpdateWithoutQuestionsInput>, AssessmentUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserCreateNestedOneWithoutAssessmentAttemptsInput = {
    create?: XOR<UserCreateWithoutAssessmentAttemptsInput, UserUncheckedCreateWithoutAssessmentAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssessmentAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type AssessmentCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<AssessmentCreateWithoutAttemptsInput, AssessmentUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAttemptsInput
    connect?: AssessmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAssessmentAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutAssessmentAttemptsInput, UserUncheckedCreateWithoutAssessmentAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssessmentAttemptsInput
    upsert?: UserUpsertWithoutAssessmentAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssessmentAttemptsInput, UserUpdateWithoutAssessmentAttemptsInput>, UserUncheckedUpdateWithoutAssessmentAttemptsInput>
  }

  export type AssessmentUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<AssessmentCreateWithoutAttemptsInput, AssessmentUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAttemptsInput
    upsert?: AssessmentUpsertWithoutAttemptsInput
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutAttemptsInput, AssessmentUpdateWithoutAttemptsInput>, AssessmentUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserCreateNestedOneWithoutProvidedFeedbackInput = {
    create?: XOR<UserCreateWithoutProvidedFeedbackInput, UserUncheckedCreateWithoutProvidedFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutProvidedFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedbackTargetFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackTarget
  }

  export type UserUpdateOneRequiredWithoutProvidedFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutProvidedFeedbackInput, UserUncheckedCreateWithoutProvidedFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutProvidedFeedbackInput
    upsert?: UserUpsertWithoutProvidedFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProvidedFeedbackInput, UserUpdateWithoutProvidedFeedbackInput>, UserUncheckedUpdateWithoutProvidedFeedbackInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type NestedEnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type NestedEnumDifficultyLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDifficultyLevelNullableFilter<$PrismaModel> | $Enums.DifficultyLevel | null
  }

  export type NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDifficultyLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusFilter<$PrismaModel> | $Enums.EnrollmentStatus
  }

  export type NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeFilter<$PrismaModel> | $Enums.ExerciseType
  }

  export type NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeFilter<$PrismaModel>
  }

  export type NestedEnumStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeFilter<$PrismaModel> | $Enums.StatusType
  }

  export type NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommunityRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunityRole | EnumCommunityRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunityRoleFilter<$PrismaModel> | $Enums.CommunityRole
  }

  export type NestedEnumCommunityRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunityRole | EnumCommunityRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunityRole[] | ListEnumCommunityRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunityRoleWithAggregatesFilter<$PrismaModel> | $Enums.CommunityRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunityRoleFilter<$PrismaModel>
    _max?: NestedEnumCommunityRoleFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumSponsorshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsorshipType | EnumSponsorshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsorshipTypeFilter<$PrismaModel> | $Enums.SponsorshipType
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumSponsorshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsorshipType | EnumSponsorshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsorshipType[] | ListEnumSponsorshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsorshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.SponsorshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSponsorshipTypeFilter<$PrismaModel>
    _max?: NestedEnumSponsorshipTypeFilter<$PrismaModel>
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackTarget | EnumFeedbackTargetFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTargetFilter<$PrismaModel> | $Enums.FeedbackTarget
  }

  export type NestedEnumFeedbackTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackTarget | EnumFeedbackTargetFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackTarget[] | ListEnumFeedbackTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTargetWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTargetFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTargetFilter<$PrismaModel>
  }

  export type CourseReviewCreateWithoutUserInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    course: CourseCreateNestedOneWithoutReviewsInput
  }

  export type CourseReviewUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
  }

  export type CourseReviewCreateOrConnectWithoutUserInput = {
    where: CourseReviewWhereUniqueInput
    create: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput>
  }

  export type CourseReviewCreateManyUserInputEnvelope = {
    data: CourseReviewCreateManyUserInput | CourseReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutUserInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillCreateWithoutUserInput = {
    proficiencyLevel: number
    acquiredDate?: Date | string | null
    skill: SkillCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillUncheckedCreateWithoutUserInput = {
    id?: number
    skillId: number
    proficiencyLevel: number
    acquiredDate?: Date | string | null
  }

  export type UserSkillCreateOrConnectWithoutUserInput = {
    where: UserSkillWhereUniqueInput
    create: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput>
  }

  export type UserSkillCreateManyUserInputEnvelope = {
    data: UserSkillCreateManyUserInput | UserSkillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipCreateWithoutMenteeInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    mentor: UserCreateNestedOneWithoutMentorRelationshipsInput
    program?: MentorshipProgramCreateNestedOneWithoutRelationshipsInput
    sessions?: MentorshipSessionCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipUncheckedCreateWithoutMenteeInput = {
    id?: number
    mentorId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    sessions?: MentorshipSessionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipCreateOrConnectWithoutMenteeInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutMenteeInput, MentorshipUncheckedCreateWithoutMenteeInput>
  }

  export type MentorshipCreateManyMenteeInputEnvelope = {
    data: MentorshipCreateManyMenteeInput | MentorshipCreateManyMenteeInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipCreateWithoutMentorInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    mentee: UserCreateNestedOneWithoutMenteeRelationshipsInput
    program?: MentorshipProgramCreateNestedOneWithoutRelationshipsInput
    sessions?: MentorshipSessionCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipUncheckedCreateWithoutMentorInput = {
    id?: number
    menteeId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    sessions?: MentorshipSessionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipCreateOrConnectWithoutMentorInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput>
  }

  export type MentorshipCreateManyMentorInputEnvelope = {
    data: MentorshipCreateManyMentorInput | MentorshipCreateManyMentorInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutInstructorInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutInstructorInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutInstructorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutInstructorInput, CourseUncheckedCreateWithoutInstructorInput>
  }

  export type CourseCreateManyInstructorInputEnvelope = {
    data: CourseCreateManyInstructorInput | CourseCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type EventRegistrationCreateWithoutUserInput = {
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
    event: EventCreateNestedOneWithoutRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutUserInput = {
    id?: number
    eventId: number
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
  }

  export type EventRegistrationCreateOrConnectWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput>
  }

  export type EventRegistrationCreateManyUserInputEnvelope = {
    data: EventRegistrationCreateManyUserInput | EventRegistrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCreateWithoutCreatorInput = {
    name: string
    description: string
    thumbnail?: string | null
    createdAt?: Date | string
    isPrivate?: boolean
    members?: CommunityMemberCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutCreatorInput = {
    id?: number
    name: string
    description: string
    thumbnail?: string | null
    createdAt?: Date | string
    isPrivate?: boolean
    members?: CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutCreatorInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutCreatorInput, CommunityUncheckedCreateWithoutCreatorInput>
  }

  export type CommunityCreateManyCreatorInputEnvelope = {
    data: CommunityCreateManyCreatorInput | CommunityCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommunityMemberCreateWithoutUserInput = {
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
    community: CommunityCreateNestedOneWithoutMembersInput
  }

  export type CommunityMemberUncheckedCreateWithoutUserInput = {
    id?: number
    communityId: number
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
  }

  export type CommunityMemberCreateOrConnectWithoutUserInput = {
    where: CommunityMemberWhereUniqueInput
    create: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput>
  }

  export type CommunityMemberCreateManyUserInputEnvelope = {
    data: CommunityMemberCreateManyUserInput | CommunityMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: number
    communityId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    content: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCreatorInput = {
    title: string
    description: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectCreateManyCreatorInputEnvelope = {
    data: ProjectCreateManyCreatorInput | ProjectCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    role: $Enums.ProjectRole
    joinedDate?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    role: $Enums.ProjectRole
    joinedDate?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    earnedDate?: Date | string
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: number
    achievementId: number
    earnedDate?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    type: $Enums.NotificationType
    actionUrl?: string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    type: $Enums.NotificationType
    actionUrl?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutUploaderInput = {
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploadDate?: Date | string
    isApproved?: boolean
  }

  export type ResourceUncheckedCreateWithoutUploaderInput = {
    id?: number
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploadDate?: Date | string
    isApproved?: boolean
  }

  export type ResourceCreateOrConnectWithoutUploaderInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutUploaderInput, ResourceUncheckedCreateWithoutUploaderInput>
  }

  export type ResourceCreateManyUploaderInputEnvelope = {
    data: ResourceCreateManyUploaderInput | ResourceCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type UserAssessmentAttemptCreateWithoutUserInput = {
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
    assessment: AssessmentCreateNestedOneWithoutAttemptsInput
  }

  export type UserAssessmentAttemptUncheckedCreateWithoutUserInput = {
    id?: number
    assessmentId: number
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
  }

  export type UserAssessmentAttemptCreateOrConnectWithoutUserInput = {
    where: UserAssessmentAttemptWhereUniqueInput
    create: XOR<UserAssessmentAttemptCreateWithoutUserInput, UserAssessmentAttemptUncheckedCreateWithoutUserInput>
  }

  export type UserAssessmentAttemptCreateManyUserInputEnvelope = {
    data: UserAssessmentAttemptCreateManyUserInput | UserAssessmentAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutProviderInput = {
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUncheckedCreateWithoutProviderInput = {
    id?: number
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutProviderInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutProviderInput, FeedbackUncheckedCreateWithoutProviderInput>
  }

  export type FeedbackCreateManyProviderInputEnvelope = {
    data: FeedbackCreateManyProviderInput | FeedbackCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardInteractionCreateWithoutUserInput = {
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
    flashcard: FlashcardCreateNestedOneWithoutUserInteractionsInput
  }

  export type FlashcardInteractionUncheckedCreateWithoutUserInput = {
    id?: number
    flashcardId: number
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
  }

  export type FlashcardInteractionCreateOrConnectWithoutUserInput = {
    where: FlashcardInteractionWhereUniqueInput
    create: XOR<FlashcardInteractionCreateWithoutUserInput, FlashcardInteractionUncheckedCreateWithoutUserInput>
  }

  export type FlashcardInteractionCreateManyUserInputEnvelope = {
    data: FlashcardInteractionCreateManyUserInput | FlashcardInteractionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardCreateWithoutUserInput = {
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    course?: CourseCreateNestedOneWithoutFlashcardsInput
    module?: CourseModuleCreateNestedOneWithoutFlashcardsInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUncheckedCreateWithoutUserInput = {
    id?: number
    courseId?: number | null
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardCreateOrConnectWithoutUserInput = {
    where: FlashcardWhereUniqueInput
    create: XOR<FlashcardCreateWithoutUserInput, FlashcardUncheckedCreateWithoutUserInput>
  }

  export type FlashcardCreateManyUserInputEnvelope = {
    data: FlashcardCreateManyUserInput | FlashcardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardCollectionCreateWithoutUserInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    isPublic?: boolean
    cards?: FlashcardCollectionItemCreateNestedManyWithoutCollectionInput
  }

  export type FlashcardCollectionUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    isPublic?: boolean
    cards?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type FlashcardCollectionCreateOrConnectWithoutUserInput = {
    where: FlashcardCollectionWhereUniqueInput
    create: XOR<FlashcardCollectionCreateWithoutUserInput, FlashcardCollectionUncheckedCreateWithoutUserInput>
  }

  export type FlashcardCollectionCreateManyUserInputEnvelope = {
    data: FlashcardCollectionCreateManyUserInput | FlashcardCollectionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotSessionCreateWithoutUserInput = {
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ChatbotMessageCreateNestedManyWithoutSessionInput
    analytics?: ChatbotSessionAnalyticsCreateNestedOneWithoutSessionInput
  }

  export type ChatbotSessionUncheckedCreateWithoutUserInput = {
    id?: number
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ChatbotMessageUncheckedCreateNestedManyWithoutSessionInput
    analytics?: ChatbotSessionAnalyticsUncheckedCreateNestedOneWithoutSessionInput
  }

  export type ChatbotSessionCreateOrConnectWithoutUserInput = {
    where: ChatbotSessionWhereUniqueInput
    create: XOR<ChatbotSessionCreateWithoutUserInput, ChatbotSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatbotSessionCreateManyUserInputEnvelope = {
    data: ChatbotSessionCreateManyUserInput | ChatbotSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotFeedbackCreateWithoutUserInput = {
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    message: ChatbotMessageCreateNestedOneWithoutFeedbackInput
  }

  export type ChatbotFeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    messageId: number
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
  }

  export type ChatbotFeedbackCreateOrConnectWithoutUserInput = {
    where: ChatbotFeedbackWhereUniqueInput
    create: XOR<ChatbotFeedbackCreateWithoutUserInput, ChatbotFeedbackUncheckedCreateWithoutUserInput>
  }

  export type ChatbotFeedbackCreateManyUserInputEnvelope = {
    data: ChatbotFeedbackCreateManyUserInput | ChatbotFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedAnswerCreateWithoutUserInput = {
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    course?: CourseCreateNestedOneWithoutSavedAnswersInput
  }

  export type SavedAnswerUncheckedCreateWithoutUserInput = {
    id?: number
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    courseId?: number | null
  }

  export type SavedAnswerCreateOrConnectWithoutUserInput = {
    where: SavedAnswerWhereUniqueInput
    create: XOR<SavedAnswerCreateWithoutUserInput, SavedAnswerUncheckedCreateWithoutUserInput>
  }

  export type SavedAnswerCreateManyUserInputEnvelope = {
    data: SavedAnswerCreateManyUserInput | SavedAnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseReviewWhereUniqueInput
    update: XOR<CourseReviewUpdateWithoutUserInput, CourseReviewUncheckedUpdateWithoutUserInput>
    create: XOR<CourseReviewCreateWithoutUserInput, CourseReviewUncheckedCreateWithoutUserInput>
  }

  export type CourseReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseReviewWhereUniqueInput
    data: XOR<CourseReviewUpdateWithoutUserInput, CourseReviewUncheckedUpdateWithoutUserInput>
  }

  export type CourseReviewUpdateManyWithWhereWithoutUserInput = {
    where: CourseReviewScalarWhereInput
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseReviewScalarWhereInput = {
    AND?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
    OR?: CourseReviewScalarWhereInput[]
    NOT?: CourseReviewScalarWhereInput | CourseReviewScalarWhereInput[]
    id?: IntFilter<"CourseReview"> | number
    courseId?: IntFilter<"CourseReview"> | number
    userId?: IntFilter<"CourseReview"> | number
    rating?: IntFilter<"CourseReview"> | number
    comment?: StringNullableFilter<"CourseReview"> | string | null
    createdAt?: DateTimeFilter<"CourseReview"> | Date | string
    updatedAt?: DateTimeFilter<"CourseReview"> | Date | string
    isPublished?: BoolFilter<"CourseReview"> | boolean
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: IntFilter<"Enrollment"> | number
    userId?: IntFilter<"Enrollment"> | number
    courseId?: IntFilter<"Enrollment"> | number
    enrollmentDate?: DateTimeFilter<"Enrollment"> | Date | string
    status?: EnumEnrollmentStatusFilter<"Enrollment"> | $Enums.EnrollmentStatus
    completionDate?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    progressPercentage?: IntFilter<"Enrollment"> | number
    lastAccessedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    unenrollmentDate?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    unenrollmentReason?: StringNullableFilter<"Enrollment"> | string | null
  }

  export type UserSkillUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSkillWhereUniqueInput
    update: XOR<UserSkillUpdateWithoutUserInput, UserSkillUncheckedUpdateWithoutUserInput>
    create: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput>
  }

  export type UserSkillUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSkillWhereUniqueInput
    data: XOR<UserSkillUpdateWithoutUserInput, UserSkillUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillUpdateManyWithWhereWithoutUserInput = {
    where: UserSkillScalarWhereInput
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSkillScalarWhereInput = {
    AND?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
    OR?: UserSkillScalarWhereInput[]
    NOT?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
    id?: IntFilter<"UserSkill"> | number
    userId?: IntFilter<"UserSkill"> | number
    skillId?: IntFilter<"UserSkill"> | number
    proficiencyLevel?: IntFilter<"UserSkill"> | number
    acquiredDate?: DateTimeNullableFilter<"UserSkill"> | Date | string | null
  }

  export type MentorshipUpsertWithWhereUniqueWithoutMenteeInput = {
    where: MentorshipWhereUniqueInput
    update: XOR<MentorshipUpdateWithoutMenteeInput, MentorshipUncheckedUpdateWithoutMenteeInput>
    create: XOR<MentorshipCreateWithoutMenteeInput, MentorshipUncheckedCreateWithoutMenteeInput>
  }

  export type MentorshipUpdateWithWhereUniqueWithoutMenteeInput = {
    where: MentorshipWhereUniqueInput
    data: XOR<MentorshipUpdateWithoutMenteeInput, MentorshipUncheckedUpdateWithoutMenteeInput>
  }

  export type MentorshipUpdateManyWithWhereWithoutMenteeInput = {
    where: MentorshipScalarWhereInput
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyWithoutMenteeInput>
  }

  export type MentorshipScalarWhereInput = {
    AND?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
    OR?: MentorshipScalarWhereInput[]
    NOT?: MentorshipScalarWhereInput | MentorshipScalarWhereInput[]
    id?: IntFilter<"Mentorship"> | number
    mentorId?: IntFilter<"Mentorship"> | number
    menteeId?: IntFilter<"Mentorship"> | number
    programId?: IntNullableFilter<"Mentorship"> | number | null
    startDate?: DateTimeFilter<"Mentorship"> | Date | string
    endDate?: DateTimeNullableFilter<"Mentorship"> | Date | string | null
    status?: EnumStatusTypeFilter<"Mentorship"> | $Enums.StatusType
  }

  export type MentorshipUpsertWithWhereUniqueWithoutMentorInput = {
    where: MentorshipWhereUniqueInput
    update: XOR<MentorshipUpdateWithoutMentorInput, MentorshipUncheckedUpdateWithoutMentorInput>
    create: XOR<MentorshipCreateWithoutMentorInput, MentorshipUncheckedCreateWithoutMentorInput>
  }

  export type MentorshipUpdateWithWhereUniqueWithoutMentorInput = {
    where: MentorshipWhereUniqueInput
    data: XOR<MentorshipUpdateWithoutMentorInput, MentorshipUncheckedUpdateWithoutMentorInput>
  }

  export type MentorshipUpdateManyWithWhereWithoutMentorInput = {
    where: MentorshipScalarWhereInput
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyWithoutMentorInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutInstructorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutInstructorInput, CourseUncheckedUpdateWithoutInstructorInput>
    create: XOR<CourseCreateWithoutInstructorInput, CourseUncheckedCreateWithoutInstructorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutInstructorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutInstructorInput, CourseUncheckedUpdateWithoutInstructorInput>
  }

  export type CourseUpdateManyWithWhereWithoutInstructorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutInstructorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    overview?: StringNullableFilter<"Course"> | string | null
    thumbnail?: StringNullableFilter<"Course"> | string | null
    coverImage?: StringNullableFilter<"Course"> | string | null
    type?: EnumCourseTypeFilter<"Course"> | $Enums.CourseType
    difficulty?: EnumDifficultyLevelNullableFilter<"Course"> | $Enums.DifficultyLevel | null
    instructorId?: IntNullableFilter<"Course"> | number | null
    durationHours?: IntNullableFilter<"Course"> | number | null
    isFeatured?: BoolFilter<"Course"> | boolean
    isPublished?: BoolFilter<"Course"> | boolean
    startDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    enrollmentLimit?: IntNullableFilter<"Course"> | number | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutUserInput, EventRegistrationUncheckedUpdateWithoutUserInput>
    create: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutUserInput, EventRegistrationUncheckedUpdateWithoutUserInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutUserInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutUserInput>
  }

  export type EventRegistrationScalarWhereInput = {
    AND?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    OR?: EventRegistrationScalarWhereInput[]
    NOT?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    id?: IntFilter<"EventRegistration"> | number
    eventId?: IntFilter<"EventRegistration"> | number
    userId?: IntFilter<"EventRegistration"> | number
    registrationDate?: DateTimeFilter<"EventRegistration"> | Date | string
    attendanceConfirmed?: BoolFilter<"EventRegistration"> | boolean
  }

  export type CommunityUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CommunityWhereUniqueInput
    update: XOR<CommunityUpdateWithoutCreatorInput, CommunityUncheckedUpdateWithoutCreatorInput>
    create: XOR<CommunityCreateWithoutCreatorInput, CommunityUncheckedCreateWithoutCreatorInput>
  }

  export type CommunityUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CommunityWhereUniqueInput
    data: XOR<CommunityUpdateWithoutCreatorInput, CommunityUncheckedUpdateWithoutCreatorInput>
  }

  export type CommunityUpdateManyWithWhereWithoutCreatorInput = {
    where: CommunityScalarWhereInput
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CommunityScalarWhereInput = {
    AND?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
    OR?: CommunityScalarWhereInput[]
    NOT?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
    id?: IntFilter<"Community"> | number
    name?: StringFilter<"Community"> | string
    description?: StringFilter<"Community"> | string
    thumbnail?: StringNullableFilter<"Community"> | string | null
    creatorId?: IntFilter<"Community"> | number
    createdAt?: DateTimeFilter<"Community"> | Date | string
    isPrivate?: BoolFilter<"Community"> | boolean
  }

  export type CommunityMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityMemberWhereUniqueInput
    update: XOR<CommunityMemberUpdateWithoutUserInput, CommunityMemberUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput>
  }

  export type CommunityMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityMemberWhereUniqueInput
    data: XOR<CommunityMemberUpdateWithoutUserInput, CommunityMemberUncheckedUpdateWithoutUserInput>
  }

  export type CommunityMemberUpdateManyWithWhereWithoutUserInput = {
    where: CommunityMemberScalarWhereInput
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type CommunityMemberScalarWhereInput = {
    AND?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
    OR?: CommunityMemberScalarWhereInput[]
    NOT?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
    id?: IntFilter<"CommunityMember"> | number
    communityId?: IntFilter<"CommunityMember"> | number
    userId?: IntFilter<"CommunityMember"> | number
    joinedDate?: DateTimeFilter<"CommunityMember"> | Date | string
    role?: EnumCommunityRoleFilter<"CommunityMember"> | $Enums.CommunityRole
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    authorId?: IntFilter<"Post"> | number
    communityId?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    creatorId?: IntFilter<"Project"> | number
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    githubUrl?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    thumbnail?: StringNullableFilter<"Project"> | string | null
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedDate?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: IntFilter<"UserAchievement"> | number
    userId?: IntFilter<"UserAchievement"> | number
    achievementId?: IntFilter<"UserAchievement"> | number
    earnedDate?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    actionUrl?: StringNullableFilter<"Notification"> | string | null
  }

  export type ResourceUpsertWithWhereUniqueWithoutUploaderInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutUploaderInput, ResourceUncheckedUpdateWithoutUploaderInput>
    create: XOR<ResourceCreateWithoutUploaderInput, ResourceUncheckedCreateWithoutUploaderInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutUploaderInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutUploaderInput, ResourceUncheckedUpdateWithoutUploaderInput>
  }

  export type ResourceUpdateManyWithWhereWithoutUploaderInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutUploaderInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: IntFilter<"Resource"> | number
    title?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    fileUrl?: StringFilter<"Resource"> | string
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    uploaderId?: IntFilter<"Resource"> | number
    uploadDate?: DateTimeFilter<"Resource"> | Date | string
    isApproved?: BoolFilter<"Resource"> | boolean
  }

  export type UserAssessmentAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAssessmentAttemptWhereUniqueInput
    update: XOR<UserAssessmentAttemptUpdateWithoutUserInput, UserAssessmentAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<UserAssessmentAttemptCreateWithoutUserInput, UserAssessmentAttemptUncheckedCreateWithoutUserInput>
  }

  export type UserAssessmentAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAssessmentAttemptWhereUniqueInput
    data: XOR<UserAssessmentAttemptUpdateWithoutUserInput, UserAssessmentAttemptUncheckedUpdateWithoutUserInput>
  }

  export type UserAssessmentAttemptUpdateManyWithWhereWithoutUserInput = {
    where: UserAssessmentAttemptScalarWhereInput
    data: XOR<UserAssessmentAttemptUpdateManyMutationInput, UserAssessmentAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAssessmentAttemptScalarWhereInput = {
    AND?: UserAssessmentAttemptScalarWhereInput | UserAssessmentAttemptScalarWhereInput[]
    OR?: UserAssessmentAttemptScalarWhereInput[]
    NOT?: UserAssessmentAttemptScalarWhereInput | UserAssessmentAttemptScalarWhereInput[]
    id?: IntFilter<"UserAssessmentAttempt"> | number
    userId?: IntFilter<"UserAssessmentAttempt"> | number
    assessmentId?: IntFilter<"UserAssessmentAttempt"> | number
    score?: IntFilter<"UserAssessmentAttempt"> | number
    passed?: BoolFilter<"UserAssessmentAttempt"> | boolean
    attemptDate?: DateTimeFilter<"UserAssessmentAttempt"> | Date | string
    attemptNumber?: IntFilter<"UserAssessmentAttempt"> | number
    answers?: StringNullableFilter<"UserAssessmentAttempt"> | string | null
  }

  export type FeedbackUpsertWithWhereUniqueWithoutProviderInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutProviderInput, FeedbackUncheckedUpdateWithoutProviderInput>
    create: XOR<FeedbackCreateWithoutProviderInput, FeedbackUncheckedCreateWithoutProviderInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutProviderInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutProviderInput, FeedbackUncheckedUpdateWithoutProviderInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutProviderInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutProviderInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    providerId?: IntFilter<"Feedback"> | number
    targetId?: IntFilter<"Feedback"> | number
    targetType?: EnumFeedbackTargetFilter<"Feedback"> | $Enums.FeedbackTarget
    rating?: IntFilter<"Feedback"> | number
    comment?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type FlashcardInteractionUpsertWithWhereUniqueWithoutUserInput = {
    where: FlashcardInteractionWhereUniqueInput
    update: XOR<FlashcardInteractionUpdateWithoutUserInput, FlashcardInteractionUncheckedUpdateWithoutUserInput>
    create: XOR<FlashcardInteractionCreateWithoutUserInput, FlashcardInteractionUncheckedCreateWithoutUserInput>
  }

  export type FlashcardInteractionUpdateWithWhereUniqueWithoutUserInput = {
    where: FlashcardInteractionWhereUniqueInput
    data: XOR<FlashcardInteractionUpdateWithoutUserInput, FlashcardInteractionUncheckedUpdateWithoutUserInput>
  }

  export type FlashcardInteractionUpdateManyWithWhereWithoutUserInput = {
    where: FlashcardInteractionScalarWhereInput
    data: XOR<FlashcardInteractionUpdateManyMutationInput, FlashcardInteractionUncheckedUpdateManyWithoutUserInput>
  }

  export type FlashcardInteractionScalarWhereInput = {
    AND?: FlashcardInteractionScalarWhereInput | FlashcardInteractionScalarWhereInput[]
    OR?: FlashcardInteractionScalarWhereInput[]
    NOT?: FlashcardInteractionScalarWhereInput | FlashcardInteractionScalarWhereInput[]
    id?: IntFilter<"FlashcardInteraction"> | number
    flashcardId?: IntFilter<"FlashcardInteraction"> | number
    userId?: IntFilter<"FlashcardInteraction"> | number
    correct?: BoolFilter<"FlashcardInteraction"> | boolean
    responseTime?: IntNullableFilter<"FlashcardInteraction"> | number | null
    interactionDate?: DateTimeFilter<"FlashcardInteraction"> | Date | string
  }

  export type FlashcardUpsertWithWhereUniqueWithoutUserInput = {
    where: FlashcardWhereUniqueInput
    update: XOR<FlashcardUpdateWithoutUserInput, FlashcardUncheckedUpdateWithoutUserInput>
    create: XOR<FlashcardCreateWithoutUserInput, FlashcardUncheckedCreateWithoutUserInput>
  }

  export type FlashcardUpdateWithWhereUniqueWithoutUserInput = {
    where: FlashcardWhereUniqueInput
    data: XOR<FlashcardUpdateWithoutUserInput, FlashcardUncheckedUpdateWithoutUserInput>
  }

  export type FlashcardUpdateManyWithWhereWithoutUserInput = {
    where: FlashcardScalarWhereInput
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyWithoutUserInput>
  }

  export type FlashcardScalarWhereInput = {
    AND?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
    OR?: FlashcardScalarWhereInput[]
    NOT?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
    id?: IntFilter<"Flashcard"> | number
    userId?: IntFilter<"Flashcard"> | number
    courseId?: IntNullableFilter<"Flashcard"> | number | null
    moduleId?: IntNullableFilter<"Flashcard"> | number | null
    question?: StringFilter<"Flashcard"> | string
    answer?: StringFilter<"Flashcard"> | string
    difficultyLevel?: IntFilter<"Flashcard"> | number
    tags?: StringNullableFilter<"Flashcard"> | string | null
    aiGenerated?: BoolFilter<"Flashcard"> | boolean
    createdAt?: DateTimeFilter<"Flashcard"> | Date | string
    lastReviewed?: DateTimeNullableFilter<"Flashcard"> | Date | string | null
    timesReviewed?: IntFilter<"Flashcard"> | number
    confidenceLevel?: IntNullableFilter<"Flashcard"> | number | null
    aiModel?: StringNullableFilter<"Flashcard"> | string | null
    generationPrompt?: StringNullableFilter<"Flashcard"> | string | null
    sourceContentSnippet?: StringNullableFilter<"Flashcard"> | string | null
  }

  export type FlashcardCollectionUpsertWithWhereUniqueWithoutUserInput = {
    where: FlashcardCollectionWhereUniqueInput
    update: XOR<FlashcardCollectionUpdateWithoutUserInput, FlashcardCollectionUncheckedUpdateWithoutUserInput>
    create: XOR<FlashcardCollectionCreateWithoutUserInput, FlashcardCollectionUncheckedCreateWithoutUserInput>
  }

  export type FlashcardCollectionUpdateWithWhereUniqueWithoutUserInput = {
    where: FlashcardCollectionWhereUniqueInput
    data: XOR<FlashcardCollectionUpdateWithoutUserInput, FlashcardCollectionUncheckedUpdateWithoutUserInput>
  }

  export type FlashcardCollectionUpdateManyWithWhereWithoutUserInput = {
    where: FlashcardCollectionScalarWhereInput
    data: XOR<FlashcardCollectionUpdateManyMutationInput, FlashcardCollectionUncheckedUpdateManyWithoutUserInput>
  }

  export type FlashcardCollectionScalarWhereInput = {
    AND?: FlashcardCollectionScalarWhereInput | FlashcardCollectionScalarWhereInput[]
    OR?: FlashcardCollectionScalarWhereInput[]
    NOT?: FlashcardCollectionScalarWhereInput | FlashcardCollectionScalarWhereInput[]
    id?: IntFilter<"FlashcardCollection"> | number
    name?: StringFilter<"FlashcardCollection"> | string
    description?: StringNullableFilter<"FlashcardCollection"> | string | null
    userId?: IntFilter<"FlashcardCollection"> | number
    createdAt?: DateTimeFilter<"FlashcardCollection"> | Date | string
    isPublic?: BoolFilter<"FlashcardCollection"> | boolean
  }

  export type ChatbotSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatbotSessionWhereUniqueInput
    update: XOR<ChatbotSessionUpdateWithoutUserInput, ChatbotSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ChatbotSessionCreateWithoutUserInput, ChatbotSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatbotSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatbotSessionWhereUniqueInput
    data: XOR<ChatbotSessionUpdateWithoutUserInput, ChatbotSessionUncheckedUpdateWithoutUserInput>
  }

  export type ChatbotSessionUpdateManyWithWhereWithoutUserInput = {
    where: ChatbotSessionScalarWhereInput
    data: XOR<ChatbotSessionUpdateManyMutationInput, ChatbotSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatbotSessionScalarWhereInput = {
    AND?: ChatbotSessionScalarWhereInput | ChatbotSessionScalarWhereInput[]
    OR?: ChatbotSessionScalarWhereInput[]
    NOT?: ChatbotSessionScalarWhereInput | ChatbotSessionScalarWhereInput[]
    id?: IntFilter<"ChatbotSession"> | number
    userId?: IntFilter<"ChatbotSession"> | number
    title?: StringNullableFilter<"ChatbotSession"> | string | null
    createdAt?: DateTimeFilter<"ChatbotSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatbotSession"> | Date | string
    isActive?: BoolFilter<"ChatbotSession"> | boolean
  }

  export type ChatbotFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatbotFeedbackWhereUniqueInput
    update: XOR<ChatbotFeedbackUpdateWithoutUserInput, ChatbotFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<ChatbotFeedbackCreateWithoutUserInput, ChatbotFeedbackUncheckedCreateWithoutUserInput>
  }

  export type ChatbotFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatbotFeedbackWhereUniqueInput
    data: XOR<ChatbotFeedbackUpdateWithoutUserInput, ChatbotFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type ChatbotFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: ChatbotFeedbackScalarWhereInput
    data: XOR<ChatbotFeedbackUpdateManyMutationInput, ChatbotFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatbotFeedbackScalarWhereInput = {
    AND?: ChatbotFeedbackScalarWhereInput | ChatbotFeedbackScalarWhereInput[]
    OR?: ChatbotFeedbackScalarWhereInput[]
    NOT?: ChatbotFeedbackScalarWhereInput | ChatbotFeedbackScalarWhereInput[]
    id?: IntFilter<"ChatbotFeedback"> | number
    messageId?: IntFilter<"ChatbotFeedback"> | number
    userId?: IntFilter<"ChatbotFeedback"> | number
    rating?: IntNullableFilter<"ChatbotFeedback"> | number | null
    feedback?: StringNullableFilter<"ChatbotFeedback"> | string | null
    createdAt?: DateTimeFilter<"ChatbotFeedback"> | Date | string
  }

  export type SavedAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedAnswerWhereUniqueInput
    update: XOR<SavedAnswerUpdateWithoutUserInput, SavedAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<SavedAnswerCreateWithoutUserInput, SavedAnswerUncheckedCreateWithoutUserInput>
  }

  export type SavedAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedAnswerWhereUniqueInput
    data: XOR<SavedAnswerUpdateWithoutUserInput, SavedAnswerUncheckedUpdateWithoutUserInput>
  }

  export type SavedAnswerUpdateManyWithWhereWithoutUserInput = {
    where: SavedAnswerScalarWhereInput
    data: XOR<SavedAnswerUpdateManyMutationInput, SavedAnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedAnswerScalarWhereInput = {
    AND?: SavedAnswerScalarWhereInput | SavedAnswerScalarWhereInput[]
    OR?: SavedAnswerScalarWhereInput[]
    NOT?: SavedAnswerScalarWhereInput | SavedAnswerScalarWhereInput[]
    id?: IntFilter<"SavedAnswer"> | number
    question?: StringFilter<"SavedAnswer"> | string
    answer?: StringFilter<"SavedAnswer"> | string
    category?: StringNullableFilter<"SavedAnswer"> | string | null
    createdAt?: DateTimeFilter<"SavedAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"SavedAnswer"> | Date | string
    isPublic?: BoolFilter<"SavedAnswer"> | boolean
    userId?: IntNullableFilter<"SavedAnswer"> | number | null
    courseId?: IntNullableFilter<"SavedAnswer"> | number | null
  }

  export type UserCreateWithoutFlashcardsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlashcardsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlashcardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlashcardsInput, UserUncheckedCreateWithoutFlashcardsInput>
  }

  export type CourseCreateWithoutFlashcardsInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutFlashcardsInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFlashcardsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFlashcardsInput, CourseUncheckedCreateWithoutFlashcardsInput>
  }

  export type CourseModuleCreateWithoutFlashcardsInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutFlashcardsInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutFlashcardsInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutFlashcardsInput, CourseModuleUncheckedCreateWithoutFlashcardsInput>
  }

  export type FlashcardInteractionCreateWithoutFlashcardInput = {
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
    user: UserCreateNestedOneWithoutUserInteractionsInput
  }

  export type FlashcardInteractionUncheckedCreateWithoutFlashcardInput = {
    id?: number
    userId: number
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
  }

  export type FlashcardInteractionCreateOrConnectWithoutFlashcardInput = {
    where: FlashcardInteractionWhereUniqueInput
    create: XOR<FlashcardInteractionCreateWithoutFlashcardInput, FlashcardInteractionUncheckedCreateWithoutFlashcardInput>
  }

  export type FlashcardInteractionCreateManyFlashcardInputEnvelope = {
    data: FlashcardInteractionCreateManyFlashcardInput | FlashcardInteractionCreateManyFlashcardInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardCollectionItemCreateWithoutFlashcardInput = {
    addedAt?: Date | string
    collection: FlashcardCollectionCreateNestedOneWithoutCardsInput
  }

  export type FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput = {
    id?: number
    collectionId: number
    addedAt?: Date | string
  }

  export type FlashcardCollectionItemCreateOrConnectWithoutFlashcardInput = {
    where: FlashcardCollectionItemWhereUniqueInput
    create: XOR<FlashcardCollectionItemCreateWithoutFlashcardInput, FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput>
  }

  export type FlashcardCollectionItemCreateManyFlashcardInputEnvelope = {
    data: FlashcardCollectionItemCreateManyFlashcardInput | FlashcardCollectionItemCreateManyFlashcardInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFlashcardsInput = {
    update: XOR<UserUpdateWithoutFlashcardsInput, UserUncheckedUpdateWithoutFlashcardsInput>
    create: XOR<UserCreateWithoutFlashcardsInput, UserUncheckedCreateWithoutFlashcardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlashcardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlashcardsInput, UserUncheckedUpdateWithoutFlashcardsInput>
  }

  export type UserUpdateWithoutFlashcardsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlashcardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutFlashcardsInput = {
    update: XOR<CourseUpdateWithoutFlashcardsInput, CourseUncheckedUpdateWithoutFlashcardsInput>
    create: XOR<CourseCreateWithoutFlashcardsInput, CourseUncheckedCreateWithoutFlashcardsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFlashcardsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFlashcardsInput, CourseUncheckedUpdateWithoutFlashcardsInput>
  }

  export type CourseUpdateWithoutFlashcardsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutFlashcardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseModuleUpsertWithoutFlashcardsInput = {
    update: XOR<CourseModuleUpdateWithoutFlashcardsInput, CourseModuleUncheckedUpdateWithoutFlashcardsInput>
    create: XOR<CourseModuleCreateWithoutFlashcardsInput, CourseModuleUncheckedCreateWithoutFlashcardsInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutFlashcardsInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutFlashcardsInput, CourseModuleUncheckedUpdateWithoutFlashcardsInput>
  }

  export type CourseModuleUpdateWithoutFlashcardsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutFlashcardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type FlashcardInteractionUpsertWithWhereUniqueWithoutFlashcardInput = {
    where: FlashcardInteractionWhereUniqueInput
    update: XOR<FlashcardInteractionUpdateWithoutFlashcardInput, FlashcardInteractionUncheckedUpdateWithoutFlashcardInput>
    create: XOR<FlashcardInteractionCreateWithoutFlashcardInput, FlashcardInteractionUncheckedCreateWithoutFlashcardInput>
  }

  export type FlashcardInteractionUpdateWithWhereUniqueWithoutFlashcardInput = {
    where: FlashcardInteractionWhereUniqueInput
    data: XOR<FlashcardInteractionUpdateWithoutFlashcardInput, FlashcardInteractionUncheckedUpdateWithoutFlashcardInput>
  }

  export type FlashcardInteractionUpdateManyWithWhereWithoutFlashcardInput = {
    where: FlashcardInteractionScalarWhereInput
    data: XOR<FlashcardInteractionUpdateManyMutationInput, FlashcardInteractionUncheckedUpdateManyWithoutFlashcardInput>
  }

  export type FlashcardCollectionItemUpsertWithWhereUniqueWithoutFlashcardInput = {
    where: FlashcardCollectionItemWhereUniqueInput
    update: XOR<FlashcardCollectionItemUpdateWithoutFlashcardInput, FlashcardCollectionItemUncheckedUpdateWithoutFlashcardInput>
    create: XOR<FlashcardCollectionItemCreateWithoutFlashcardInput, FlashcardCollectionItemUncheckedCreateWithoutFlashcardInput>
  }

  export type FlashcardCollectionItemUpdateWithWhereUniqueWithoutFlashcardInput = {
    where: FlashcardCollectionItemWhereUniqueInput
    data: XOR<FlashcardCollectionItemUpdateWithoutFlashcardInput, FlashcardCollectionItemUncheckedUpdateWithoutFlashcardInput>
  }

  export type FlashcardCollectionItemUpdateManyWithWhereWithoutFlashcardInput = {
    where: FlashcardCollectionItemScalarWhereInput
    data: XOR<FlashcardCollectionItemUpdateManyMutationInput, FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardInput>
  }

  export type FlashcardCollectionItemScalarWhereInput = {
    AND?: FlashcardCollectionItemScalarWhereInput | FlashcardCollectionItemScalarWhereInput[]
    OR?: FlashcardCollectionItemScalarWhereInput[]
    NOT?: FlashcardCollectionItemScalarWhereInput | FlashcardCollectionItemScalarWhereInput[]
    id?: IntFilter<"FlashcardCollectionItem"> | number
    collectionId?: IntFilter<"FlashcardCollectionItem"> | number
    flashcardId?: IntFilter<"FlashcardCollectionItem"> | number
    addedAt?: DateTimeFilter<"FlashcardCollectionItem"> | Date | string
  }

  export type FlashcardCreateWithoutUserInteractionsInput = {
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    user: UserCreateNestedOneWithoutFlashcardsInput
    course?: CourseCreateNestedOneWithoutFlashcardsInput
    module?: CourseModuleCreateNestedOneWithoutFlashcardsInput
    collections?: FlashcardCollectionItemCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUncheckedCreateWithoutUserInteractionsInput = {
    id?: number
    userId: number
    courseId?: number | null
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    collections?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardCreateOrConnectWithoutUserInteractionsInput = {
    where: FlashcardWhereUniqueInput
    create: XOR<FlashcardCreateWithoutUserInteractionsInput, FlashcardUncheckedCreateWithoutUserInteractionsInput>
  }

  export type UserCreateWithoutUserInteractionsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserInteractionsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserInteractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserInteractionsInput, UserUncheckedCreateWithoutUserInteractionsInput>
  }

  export type FlashcardUpsertWithoutUserInteractionsInput = {
    update: XOR<FlashcardUpdateWithoutUserInteractionsInput, FlashcardUncheckedUpdateWithoutUserInteractionsInput>
    create: XOR<FlashcardCreateWithoutUserInteractionsInput, FlashcardUncheckedCreateWithoutUserInteractionsInput>
    where?: FlashcardWhereInput
  }

  export type FlashcardUpdateToOneWithWhereWithoutUserInteractionsInput = {
    where?: FlashcardWhereInput
    data: XOR<FlashcardUpdateWithoutUserInteractionsInput, FlashcardUncheckedUpdateWithoutUserInteractionsInput>
  }

  export type FlashcardUpdateWithoutUserInteractionsInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFlashcardsNestedInput
    course?: CourseUpdateOneWithoutFlashcardsNestedInput
    module?: CourseModuleUpdateOneWithoutFlashcardsNestedInput
    collections?: FlashcardCollectionItemUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateWithoutUserInteractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    collections?: FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardNestedInput
  }

  export type UserUpsertWithoutUserInteractionsInput = {
    update: XOR<UserUpdateWithoutUserInteractionsInput, UserUncheckedUpdateWithoutUserInteractionsInput>
    create: XOR<UserCreateWithoutUserInteractionsInput, UserUncheckedCreateWithoutUserInteractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserInteractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserInteractionsInput, UserUncheckedUpdateWithoutUserInteractionsInput>
  }

  export type UserUpdateWithoutUserInteractionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserInteractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFlashcardCollectionsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlashcardCollectionsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlashcardCollectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlashcardCollectionsInput, UserUncheckedCreateWithoutFlashcardCollectionsInput>
  }

  export type FlashcardCollectionItemCreateWithoutCollectionInput = {
    addedAt?: Date | string
    flashcard: FlashcardCreateNestedOneWithoutCollectionsInput
  }

  export type FlashcardCollectionItemUncheckedCreateWithoutCollectionInput = {
    id?: number
    flashcardId: number
    addedAt?: Date | string
  }

  export type FlashcardCollectionItemCreateOrConnectWithoutCollectionInput = {
    where: FlashcardCollectionItemWhereUniqueInput
    create: XOR<FlashcardCollectionItemCreateWithoutCollectionInput, FlashcardCollectionItemUncheckedCreateWithoutCollectionInput>
  }

  export type FlashcardCollectionItemCreateManyCollectionInputEnvelope = {
    data: FlashcardCollectionItemCreateManyCollectionInput | FlashcardCollectionItemCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFlashcardCollectionsInput = {
    update: XOR<UserUpdateWithoutFlashcardCollectionsInput, UserUncheckedUpdateWithoutFlashcardCollectionsInput>
    create: XOR<UserCreateWithoutFlashcardCollectionsInput, UserUncheckedCreateWithoutFlashcardCollectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlashcardCollectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlashcardCollectionsInput, UserUncheckedUpdateWithoutFlashcardCollectionsInput>
  }

  export type UserUpdateWithoutFlashcardCollectionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlashcardCollectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FlashcardCollectionItemUpsertWithWhereUniqueWithoutCollectionInput = {
    where: FlashcardCollectionItemWhereUniqueInput
    update: XOR<FlashcardCollectionItemUpdateWithoutCollectionInput, FlashcardCollectionItemUncheckedUpdateWithoutCollectionInput>
    create: XOR<FlashcardCollectionItemCreateWithoutCollectionInput, FlashcardCollectionItemUncheckedCreateWithoutCollectionInput>
  }

  export type FlashcardCollectionItemUpdateWithWhereUniqueWithoutCollectionInput = {
    where: FlashcardCollectionItemWhereUniqueInput
    data: XOR<FlashcardCollectionItemUpdateWithoutCollectionInput, FlashcardCollectionItemUncheckedUpdateWithoutCollectionInput>
  }

  export type FlashcardCollectionItemUpdateManyWithWhereWithoutCollectionInput = {
    where: FlashcardCollectionItemScalarWhereInput
    data: XOR<FlashcardCollectionItemUpdateManyMutationInput, FlashcardCollectionItemUncheckedUpdateManyWithoutCollectionInput>
  }

  export type FlashcardCollectionCreateWithoutCardsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    isPublic?: boolean
    user: UserCreateNestedOneWithoutFlashcardCollectionsInput
  }

  export type FlashcardCollectionUncheckedCreateWithoutCardsInput = {
    id?: number
    name: string
    description?: string | null
    userId: number
    createdAt?: Date | string
    isPublic?: boolean
  }

  export type FlashcardCollectionCreateOrConnectWithoutCardsInput = {
    where: FlashcardCollectionWhereUniqueInput
    create: XOR<FlashcardCollectionCreateWithoutCardsInput, FlashcardCollectionUncheckedCreateWithoutCardsInput>
  }

  export type FlashcardCreateWithoutCollectionsInput = {
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    user: UserCreateNestedOneWithoutFlashcardsInput
    course?: CourseCreateNestedOneWithoutFlashcardsInput
    module?: CourseModuleCreateNestedOneWithoutFlashcardsInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUncheckedCreateWithoutCollectionsInput = {
    id?: number
    userId: number
    courseId?: number | null
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardCreateOrConnectWithoutCollectionsInput = {
    where: FlashcardWhereUniqueInput
    create: XOR<FlashcardCreateWithoutCollectionsInput, FlashcardUncheckedCreateWithoutCollectionsInput>
  }

  export type FlashcardCollectionUpsertWithoutCardsInput = {
    update: XOR<FlashcardCollectionUpdateWithoutCardsInput, FlashcardCollectionUncheckedUpdateWithoutCardsInput>
    create: XOR<FlashcardCollectionCreateWithoutCardsInput, FlashcardCollectionUncheckedCreateWithoutCardsInput>
    where?: FlashcardCollectionWhereInput
  }

  export type FlashcardCollectionUpdateToOneWithWhereWithoutCardsInput = {
    where?: FlashcardCollectionWhereInput
    data: XOR<FlashcardCollectionUpdateWithoutCardsInput, FlashcardCollectionUncheckedUpdateWithoutCardsInput>
  }

  export type FlashcardCollectionUpdateWithoutCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutFlashcardCollectionsNestedInput
  }

  export type FlashcardCollectionUncheckedUpdateWithoutCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlashcardUpsertWithoutCollectionsInput = {
    update: XOR<FlashcardUpdateWithoutCollectionsInput, FlashcardUncheckedUpdateWithoutCollectionsInput>
    create: XOR<FlashcardCreateWithoutCollectionsInput, FlashcardUncheckedCreateWithoutCollectionsInput>
    where?: FlashcardWhereInput
  }

  export type FlashcardUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: FlashcardWhereInput
    data: XOR<FlashcardUpdateWithoutCollectionsInput, FlashcardUncheckedUpdateWithoutCollectionsInput>
  }

  export type FlashcardUpdateWithoutCollectionsInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFlashcardsNestedInput
    course?: CourseUpdateOneWithoutFlashcardsNestedInput
    module?: CourseModuleUpdateOneWithoutFlashcardsNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateWithoutCollectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutFlashcardNestedInput
  }

  export type UserCreateWithoutChatbotSessionsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatbotSessionsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatbotSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatbotSessionsInput, UserUncheckedCreateWithoutChatbotSessionsInput>
  }

  export type ChatbotMessageCreateWithoutSessionInput = {
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    course?: CourseCreateNestedOneWithoutChatbotMessagesInput
    module?: CourseModuleCreateNestedOneWithoutChatbotMessagesInput
    feedback?: ChatbotFeedbackCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageUncheckedCreateWithoutSessionInput = {
    id?: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    feedback?: ChatbotFeedbackUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageCreateOrConnectWithoutSessionInput = {
    where: ChatbotMessageWhereUniqueInput
    create: XOR<ChatbotMessageCreateWithoutSessionInput, ChatbotMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatbotMessageCreateManySessionInputEnvelope = {
    data: ChatbotMessageCreateManySessionInput | ChatbotMessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotSessionAnalyticsCreateWithoutSessionInput = {
    messageCount?: number
    userMessageCount?: number
    aiMessageCount?: number
    averageUserMessageLength?: number | null
    averageAiResponseLength?: number | null
    topicsDiscussed?: string | null
  }

  export type ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput = {
    id?: number
    messageCount?: number
    userMessageCount?: number
    aiMessageCount?: number
    averageUserMessageLength?: number | null
    averageAiResponseLength?: number | null
    topicsDiscussed?: string | null
  }

  export type ChatbotSessionAnalyticsCreateOrConnectWithoutSessionInput = {
    where: ChatbotSessionAnalyticsWhereUniqueInput
    create: XOR<ChatbotSessionAnalyticsCreateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutChatbotSessionsInput = {
    update: XOR<UserUpdateWithoutChatbotSessionsInput, UserUncheckedUpdateWithoutChatbotSessionsInput>
    create: XOR<UserCreateWithoutChatbotSessionsInput, UserUncheckedCreateWithoutChatbotSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatbotSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatbotSessionsInput, UserUncheckedUpdateWithoutChatbotSessionsInput>
  }

  export type UserUpdateWithoutChatbotSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatbotSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatbotMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: ChatbotMessageWhereUniqueInput
    update: XOR<ChatbotMessageUpdateWithoutSessionInput, ChatbotMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<ChatbotMessageCreateWithoutSessionInput, ChatbotMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatbotMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: ChatbotMessageWhereUniqueInput
    data: XOR<ChatbotMessageUpdateWithoutSessionInput, ChatbotMessageUncheckedUpdateWithoutSessionInput>
  }

  export type ChatbotMessageUpdateManyWithWhereWithoutSessionInput = {
    where: ChatbotMessageScalarWhereInput
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type ChatbotMessageScalarWhereInput = {
    AND?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
    OR?: ChatbotMessageScalarWhereInput[]
    NOT?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
    id?: IntFilter<"ChatbotMessage"> | number
    sessionId?: IntFilter<"ChatbotMessage"> | number
    content?: StringFilter<"ChatbotMessage"> | string
    role?: EnumMessageRoleFilter<"ChatbotMessage"> | $Enums.MessageRole
    timestamp?: DateTimeFilter<"ChatbotMessage"> | Date | string
    referencedContent?: StringNullableFilter<"ChatbotMessage"> | string | null
    courseId?: IntNullableFilter<"ChatbotMessage"> | number | null
    moduleId?: IntNullableFilter<"ChatbotMessage"> | number | null
    model?: StringNullableFilter<"ChatbotMessage"> | string | null
    promptTokens?: IntNullableFilter<"ChatbotMessage"> | number | null
    completionTokens?: IntNullableFilter<"ChatbotMessage"> | number | null
  }

  export type ChatbotSessionAnalyticsUpsertWithoutSessionInput = {
    update: XOR<ChatbotSessionAnalyticsUpdateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedUpdateWithoutSessionInput>
    create: XOR<ChatbotSessionAnalyticsCreateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedCreateWithoutSessionInput>
    where?: ChatbotSessionAnalyticsWhereInput
  }

  export type ChatbotSessionAnalyticsUpdateToOneWithWhereWithoutSessionInput = {
    where?: ChatbotSessionAnalyticsWhereInput
    data: XOR<ChatbotSessionAnalyticsUpdateWithoutSessionInput, ChatbotSessionAnalyticsUncheckedUpdateWithoutSessionInput>
  }

  export type ChatbotSessionAnalyticsUpdateWithoutSessionInput = {
    messageCount?: IntFieldUpdateOperationsInput | number
    userMessageCount?: IntFieldUpdateOperationsInput | number
    aiMessageCount?: IntFieldUpdateOperationsInput | number
    averageUserMessageLength?: NullableIntFieldUpdateOperationsInput | number | null
    averageAiResponseLength?: NullableIntFieldUpdateOperationsInput | number | null
    topicsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatbotSessionAnalyticsUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageCount?: IntFieldUpdateOperationsInput | number
    userMessageCount?: IntFieldUpdateOperationsInput | number
    aiMessageCount?: IntFieldUpdateOperationsInput | number
    averageUserMessageLength?: NullableIntFieldUpdateOperationsInput | number | null
    averageAiResponseLength?: NullableIntFieldUpdateOperationsInput | number | null
    topicsDiscussed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatbotSessionCreateWithoutMessagesInput = {
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutChatbotSessionsInput
    analytics?: ChatbotSessionAnalyticsCreateNestedOneWithoutSessionInput
  }

  export type ChatbotSessionUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    analytics?: ChatbotSessionAnalyticsUncheckedCreateNestedOneWithoutSessionInput
  }

  export type ChatbotSessionCreateOrConnectWithoutMessagesInput = {
    where: ChatbotSessionWhereUniqueInput
    create: XOR<ChatbotSessionCreateWithoutMessagesInput, ChatbotSessionUncheckedCreateWithoutMessagesInput>
  }

  export type CourseCreateWithoutChatbotMessagesInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutChatbotMessagesInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutChatbotMessagesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutChatbotMessagesInput, CourseUncheckedCreateWithoutChatbotMessagesInput>
  }

  export type CourseModuleCreateWithoutChatbotMessagesInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutChatbotMessagesInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutChatbotMessagesInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutChatbotMessagesInput, CourseModuleUncheckedCreateWithoutChatbotMessagesInput>
  }

  export type ChatbotFeedbackCreateWithoutMessageInput = {
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutChatbotFeedbackInput
  }

  export type ChatbotFeedbackUncheckedCreateWithoutMessageInput = {
    id?: number
    userId: number
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
  }

  export type ChatbotFeedbackCreateOrConnectWithoutMessageInput = {
    where: ChatbotFeedbackWhereUniqueInput
    create: XOR<ChatbotFeedbackCreateWithoutMessageInput, ChatbotFeedbackUncheckedCreateWithoutMessageInput>
  }

  export type ChatbotSessionUpsertWithoutMessagesInput = {
    update: XOR<ChatbotSessionUpdateWithoutMessagesInput, ChatbotSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatbotSessionCreateWithoutMessagesInput, ChatbotSessionUncheckedCreateWithoutMessagesInput>
    where?: ChatbotSessionWhereInput
  }

  export type ChatbotSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatbotSessionWhereInput
    data: XOR<ChatbotSessionUpdateWithoutMessagesInput, ChatbotSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatbotSessionUpdateWithoutMessagesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutChatbotSessionsNestedInput
    analytics?: ChatbotSessionAnalyticsUpdateOneWithoutSessionNestedInput
  }

  export type ChatbotSessionUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    analytics?: ChatbotSessionAnalyticsUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type CourseUpsertWithoutChatbotMessagesInput = {
    update: XOR<CourseUpdateWithoutChatbotMessagesInput, CourseUncheckedUpdateWithoutChatbotMessagesInput>
    create: XOR<CourseCreateWithoutChatbotMessagesInput, CourseUncheckedCreateWithoutChatbotMessagesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutChatbotMessagesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutChatbotMessagesInput, CourseUncheckedUpdateWithoutChatbotMessagesInput>
  }

  export type CourseUpdateWithoutChatbotMessagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutChatbotMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseModuleUpsertWithoutChatbotMessagesInput = {
    update: XOR<CourseModuleUpdateWithoutChatbotMessagesInput, CourseModuleUncheckedUpdateWithoutChatbotMessagesInput>
    create: XOR<CourseModuleCreateWithoutChatbotMessagesInput, CourseModuleUncheckedCreateWithoutChatbotMessagesInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutChatbotMessagesInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutChatbotMessagesInput, CourseModuleUncheckedUpdateWithoutChatbotMessagesInput>
  }

  export type CourseModuleUpdateWithoutChatbotMessagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutChatbotMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ChatbotFeedbackUpsertWithoutMessageInput = {
    update: XOR<ChatbotFeedbackUpdateWithoutMessageInput, ChatbotFeedbackUncheckedUpdateWithoutMessageInput>
    create: XOR<ChatbotFeedbackCreateWithoutMessageInput, ChatbotFeedbackUncheckedCreateWithoutMessageInput>
    where?: ChatbotFeedbackWhereInput
  }

  export type ChatbotFeedbackUpdateToOneWithWhereWithoutMessageInput = {
    where?: ChatbotFeedbackWhereInput
    data: XOR<ChatbotFeedbackUpdateWithoutMessageInput, ChatbotFeedbackUncheckedUpdateWithoutMessageInput>
  }

  export type ChatbotFeedbackUpdateWithoutMessageInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatbotFeedbackNestedInput
  }

  export type ChatbotFeedbackUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotMessageCreateWithoutFeedbackInput = {
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    session: ChatbotSessionCreateNestedOneWithoutMessagesInput
    course?: CourseCreateNestedOneWithoutChatbotMessagesInput
    module?: CourseModuleCreateNestedOneWithoutChatbotMessagesInput
  }

  export type ChatbotMessageUncheckedCreateWithoutFeedbackInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
  }

  export type ChatbotMessageCreateOrConnectWithoutFeedbackInput = {
    where: ChatbotMessageWhereUniqueInput
    create: XOR<ChatbotMessageCreateWithoutFeedbackInput, ChatbotMessageUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutChatbotFeedbackInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatbotFeedbackInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatbotFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatbotFeedbackInput, UserUncheckedCreateWithoutChatbotFeedbackInput>
  }

  export type ChatbotMessageUpsertWithoutFeedbackInput = {
    update: XOR<ChatbotMessageUpdateWithoutFeedbackInput, ChatbotMessageUncheckedUpdateWithoutFeedbackInput>
    create: XOR<ChatbotMessageCreateWithoutFeedbackInput, ChatbotMessageUncheckedCreateWithoutFeedbackInput>
    where?: ChatbotMessageWhereInput
  }

  export type ChatbotMessageUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: ChatbotMessageWhereInput
    data: XOR<ChatbotMessageUpdateWithoutFeedbackInput, ChatbotMessageUncheckedUpdateWithoutFeedbackInput>
  }

  export type ChatbotMessageUpdateWithoutFeedbackInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    session?: ChatbotSessionUpdateOneRequiredWithoutMessagesNestedInput
    course?: CourseUpdateOneWithoutChatbotMessagesNestedInput
    module?: CourseModuleUpdateOneWithoutChatbotMessagesNestedInput
  }

  export type ChatbotMessageUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutChatbotFeedbackInput = {
    update: XOR<UserUpdateWithoutChatbotFeedbackInput, UserUncheckedUpdateWithoutChatbotFeedbackInput>
    create: XOR<UserCreateWithoutChatbotFeedbackInput, UserUncheckedCreateWithoutChatbotFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatbotFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatbotFeedbackInput, UserUncheckedUpdateWithoutChatbotFeedbackInput>
  }

  export type UserUpdateWithoutChatbotFeedbackInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatbotFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatbotSessionCreateWithoutAnalyticsInput = {
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutChatbotSessionsInput
    messages?: ChatbotMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatbotSessionUncheckedCreateWithoutAnalyticsInput = {
    id?: number
    userId: number
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ChatbotMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatbotSessionCreateOrConnectWithoutAnalyticsInput = {
    where: ChatbotSessionWhereUniqueInput
    create: XOR<ChatbotSessionCreateWithoutAnalyticsInput, ChatbotSessionUncheckedCreateWithoutAnalyticsInput>
  }

  export type ChatbotSessionUpsertWithoutAnalyticsInput = {
    update: XOR<ChatbotSessionUpdateWithoutAnalyticsInput, ChatbotSessionUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<ChatbotSessionCreateWithoutAnalyticsInput, ChatbotSessionUncheckedCreateWithoutAnalyticsInput>
    where?: ChatbotSessionWhereInput
  }

  export type ChatbotSessionUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: ChatbotSessionWhereInput
    data: XOR<ChatbotSessionUpdateWithoutAnalyticsInput, ChatbotSessionUncheckedUpdateWithoutAnalyticsInput>
  }

  export type ChatbotSessionUpdateWithoutAnalyticsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutChatbotSessionsNestedInput
    messages?: ChatbotMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatbotSessionUncheckedUpdateWithoutAnalyticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatbotMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutSavedAnswersInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedAnswersInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedAnswersInput, UserUncheckedCreateWithoutSavedAnswersInput>
  }

  export type CourseCreateWithoutSavedAnswersInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSavedAnswersInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSavedAnswersInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSavedAnswersInput, CourseUncheckedCreateWithoutSavedAnswersInput>
  }

  export type UserUpsertWithoutSavedAnswersInput = {
    update: XOR<UserUpdateWithoutSavedAnswersInput, UserUncheckedUpdateWithoutSavedAnswersInput>
    create: XOR<UserCreateWithoutSavedAnswersInput, UserUncheckedCreateWithoutSavedAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedAnswersInput, UserUncheckedUpdateWithoutSavedAnswersInput>
  }

  export type UserUpdateWithoutSavedAnswersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutSavedAnswersInput = {
    update: XOR<CourseUpdateWithoutSavedAnswersInput, CourseUncheckedUpdateWithoutSavedAnswersInput>
    create: XOR<CourseCreateWithoutSavedAnswersInput, CourseUncheckedCreateWithoutSavedAnswersInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSavedAnswersInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSavedAnswersInput, CourseUncheckedUpdateWithoutSavedAnswersInput>
  }

  export type CourseUpdateWithoutSavedAnswersInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSavedAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserSkillCreateWithoutSkillInput = {
    proficiencyLevel: number
    acquiredDate?: Date | string | null
    user: UserCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillUncheckedCreateWithoutSkillInput = {
    id?: number
    userId: number
    proficiencyLevel: number
    acquiredDate?: Date | string | null
  }

  export type UserSkillCreateOrConnectWithoutSkillInput = {
    where: UserSkillWhereUniqueInput
    create: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillCreateManySkillInputEnvelope = {
    data: UserSkillCreateManySkillInput | UserSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: UserSkillWhereUniqueInput
    update: XOR<UserSkillUpdateWithoutSkillInput, UserSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: UserSkillWhereUniqueInput
    data: XOR<UserSkillUpdateWithoutSkillInput, UserSkillUncheckedUpdateWithoutSkillInput>
  }

  export type UserSkillUpdateManyWithWhereWithoutSkillInput = {
    where: UserSkillScalarWhereInput
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type UserCreateWithoutUserSkillsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSkillsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSkillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
  }

  export type SkillCreateWithoutUserSkillsInput = {
    name: string
    category: string
    description?: string | null
    icon?: string | null
  }

  export type SkillUncheckedCreateWithoutUserSkillsInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    icon?: string | null
  }

  export type SkillCreateOrConnectWithoutUserSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
  }

  export type UserUpsertWithoutUserSkillsInput = {
    update: XOR<UserUpdateWithoutUserSkillsInput, UserUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSkillsInput, UserUncheckedUpdateWithoutUserSkillsInput>
  }

  export type UserUpdateWithoutUserSkillsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SkillUpsertWithoutUserSkillsInput = {
    update: XOR<SkillUpdateWithoutUserSkillsInput, SkillUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutUserSkillsInput, SkillUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillUpdateWithoutUserSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SkillUncheckedUpdateWithoutUserSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutInstructedCoursesInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstructedCoursesInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstructedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstructedCoursesInput, UserUncheckedCreateWithoutInstructedCoursesInput>
  }

  export type CourseModuleCreateWithoutCourseInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleCreateManyCourseInputEnvelope = {
    data: CourseModuleCreateManyCourseInput | CourseModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    user: UserCreateNestedOneWithoutEnrollmentsInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LearningOutcomeCreateWithoutCourseInput = {
    description: string
    orderNumber: number
  }

  export type LearningOutcomeUncheckedCreateWithoutCourseInput = {
    id?: number
    description: string
    orderNumber: number
  }

  export type LearningOutcomeCreateOrConnectWithoutCourseInput = {
    where: LearningOutcomeWhereUniqueInput
    create: XOR<LearningOutcomeCreateWithoutCourseInput, LearningOutcomeUncheckedCreateWithoutCourseInput>
  }

  export type LearningOutcomeCreateManyCourseInputEnvelope = {
    data: LearningOutcomeCreateManyCourseInput | LearningOutcomeCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseRequirementCreateWithoutCourseInput = {
    description: string
    orderNumber: number
  }

  export type CourseRequirementUncheckedCreateWithoutCourseInput = {
    id?: number
    description: string
    orderNumber: number
  }

  export type CourseRequirementCreateOrConnectWithoutCourseInput = {
    where: CourseRequirementWhereUniqueInput
    create: XOR<CourseRequirementCreateWithoutCourseInput, CourseRequirementUncheckedCreateWithoutCourseInput>
  }

  export type CourseRequirementCreateManyCourseInputEnvelope = {
    data: CourseRequirementCreateManyCourseInput | CourseRequirementCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentCreateWithoutCourseInput = {
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    questions?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    attempts?: UserAssessmentAttemptCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    questions?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    attempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutCourseInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutCourseInput, AssessmentUncheckedCreateWithoutCourseInput>
  }

  export type AssessmentCreateManyCourseInputEnvelope = {
    data: AssessmentCreateManyCourseInput | AssessmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardCreateWithoutCourseInput = {
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    user: UserCreateNestedOneWithoutFlashcardsInput
    module?: CourseModuleCreateNestedOneWithoutFlashcardsInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardCreateOrConnectWithoutCourseInput = {
    where: FlashcardWhereUniqueInput
    create: XOR<FlashcardCreateWithoutCourseInput, FlashcardUncheckedCreateWithoutCourseInput>
  }

  export type FlashcardCreateManyCourseInputEnvelope = {
    data: FlashcardCreateManyCourseInput | FlashcardCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotMessageCreateWithoutCourseInput = {
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    session: ChatbotSessionCreateNestedOneWithoutMessagesInput
    module?: CourseModuleCreateNestedOneWithoutChatbotMessagesInput
    feedback?: ChatbotFeedbackCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageUncheckedCreateWithoutCourseInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    feedback?: ChatbotFeedbackUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageCreateOrConnectWithoutCourseInput = {
    where: ChatbotMessageWhereUniqueInput
    create: XOR<ChatbotMessageCreateWithoutCourseInput, ChatbotMessageUncheckedCreateWithoutCourseInput>
  }

  export type ChatbotMessageCreateManyCourseInputEnvelope = {
    data: ChatbotMessageCreateManyCourseInput | ChatbotMessageCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type SavedAnswerCreateWithoutCourseInput = {
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    user?: UserCreateNestedOneWithoutSavedAnswersInput
  }

  export type SavedAnswerUncheckedCreateWithoutCourseInput = {
    id?: number
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    userId?: number | null
  }

  export type SavedAnswerCreateOrConnectWithoutCourseInput = {
    where: SavedAnswerWhereUniqueInput
    create: XOR<SavedAnswerCreateWithoutCourseInput, SavedAnswerUncheckedCreateWithoutCourseInput>
  }

  export type SavedAnswerCreateManyCourseInputEnvelope = {
    data: SavedAnswerCreateManyCourseInput | SavedAnswerCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseTagsCreateWithoutCourseInput = {
    name: string
  }

  export type CourseTagsUncheckedCreateWithoutCourseInput = {
    id?: number
    name: string
  }

  export type CourseTagsCreateOrConnectWithoutCourseInput = {
    where: CourseTagsWhereUniqueInput
    create: XOR<CourseTagsCreateWithoutCourseInput, CourseTagsUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagsCreateManyCourseInputEnvelope = {
    data: CourseTagsCreateManyCourseInput | CourseTagsCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseReviewCreateWithoutCourseInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type CourseReviewUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
  }

  export type CourseReviewCreateOrConnectWithoutCourseInput = {
    where: CourseReviewWhereUniqueInput
    create: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput>
  }

  export type CourseReviewCreateManyCourseInputEnvelope = {
    data: CourseReviewCreateManyCourseInput | CourseReviewCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInstructedCoursesInput = {
    update: XOR<UserUpdateWithoutInstructedCoursesInput, UserUncheckedUpdateWithoutInstructedCoursesInput>
    create: XOR<UserCreateWithoutInstructedCoursesInput, UserUncheckedCreateWithoutInstructedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstructedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstructedCoursesInput, UserUncheckedUpdateWithoutInstructedCoursesInput>
  }

  export type UserUpdateWithoutInstructedCoursesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstructedCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    update: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    data: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
  }

  export type CourseModuleUpdateManyWithWhereWithoutCourseInput = {
    where: CourseModuleScalarWhereInput
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseModuleScalarWhereInput = {
    AND?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    OR?: CourseModuleScalarWhereInput[]
    NOT?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    id?: IntFilter<"CourseModule"> | number
    courseId?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    description?: StringFilter<"CourseModule"> | string
    orderNumber?: IntFilter<"CourseModule"> | number
    isPublished?: BoolFilter<"CourseModule"> | boolean
    estimatedHours?: IntNullableFilter<"CourseModule"> | number | null
    unlockCondition?: StringNullableFilter<"CourseModule"> | string | null
    thumbnail?: StringNullableFilter<"CourseModule"> | string | null
    createdAt?: DateTimeFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeFilter<"CourseModule"> | Date | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type LearningOutcomeUpsertWithWhereUniqueWithoutCourseInput = {
    where: LearningOutcomeWhereUniqueInput
    update: XOR<LearningOutcomeUpdateWithoutCourseInput, LearningOutcomeUncheckedUpdateWithoutCourseInput>
    create: XOR<LearningOutcomeCreateWithoutCourseInput, LearningOutcomeUncheckedCreateWithoutCourseInput>
  }

  export type LearningOutcomeUpdateWithWhereUniqueWithoutCourseInput = {
    where: LearningOutcomeWhereUniqueInput
    data: XOR<LearningOutcomeUpdateWithoutCourseInput, LearningOutcomeUncheckedUpdateWithoutCourseInput>
  }

  export type LearningOutcomeUpdateManyWithWhereWithoutCourseInput = {
    where: LearningOutcomeScalarWhereInput
    data: XOR<LearningOutcomeUpdateManyMutationInput, LearningOutcomeUncheckedUpdateManyWithoutCourseInput>
  }

  export type LearningOutcomeScalarWhereInput = {
    AND?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
    OR?: LearningOutcomeScalarWhereInput[]
    NOT?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
    id?: IntFilter<"LearningOutcome"> | number
    courseId?: IntFilter<"LearningOutcome"> | number
    description?: StringFilter<"LearningOutcome"> | string
    orderNumber?: IntFilter<"LearningOutcome"> | number
  }

  export type CourseRequirementUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseRequirementWhereUniqueInput
    update: XOR<CourseRequirementUpdateWithoutCourseInput, CourseRequirementUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseRequirementCreateWithoutCourseInput, CourseRequirementUncheckedCreateWithoutCourseInput>
  }

  export type CourseRequirementUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseRequirementWhereUniqueInput
    data: XOR<CourseRequirementUpdateWithoutCourseInput, CourseRequirementUncheckedUpdateWithoutCourseInput>
  }

  export type CourseRequirementUpdateManyWithWhereWithoutCourseInput = {
    where: CourseRequirementScalarWhereInput
    data: XOR<CourseRequirementUpdateManyMutationInput, CourseRequirementUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseRequirementScalarWhereInput = {
    AND?: CourseRequirementScalarWhereInput | CourseRequirementScalarWhereInput[]
    OR?: CourseRequirementScalarWhereInput[]
    NOT?: CourseRequirementScalarWhereInput | CourseRequirementScalarWhereInput[]
    id?: IntFilter<"CourseRequirement"> | number
    courseId?: IntFilter<"CourseRequirement"> | number
    description?: StringFilter<"CourseRequirement"> | string
    orderNumber?: IntFilter<"CourseRequirement"> | number
  }

  export type AssessmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: AssessmentWhereUniqueInput
    update: XOR<AssessmentUpdateWithoutCourseInput, AssessmentUncheckedUpdateWithoutCourseInput>
    create: XOR<AssessmentCreateWithoutCourseInput, AssessmentUncheckedCreateWithoutCourseInput>
  }

  export type AssessmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: AssessmentWhereUniqueInput
    data: XOR<AssessmentUpdateWithoutCourseInput, AssessmentUncheckedUpdateWithoutCourseInput>
  }

  export type AssessmentUpdateManyWithWhereWithoutCourseInput = {
    where: AssessmentScalarWhereInput
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type AssessmentScalarWhereInput = {
    AND?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    OR?: AssessmentScalarWhereInput[]
    NOT?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    id?: IntFilter<"Assessment"> | number
    courseId?: IntFilter<"Assessment"> | number
    title?: StringFilter<"Assessment"> | string
    description?: StringFilter<"Assessment"> | string
    totalPoints?: IntFilter<"Assessment"> | number
    passingPoints?: IntFilter<"Assessment"> | number
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
  }

  export type FlashcardUpsertWithWhereUniqueWithoutCourseInput = {
    where: FlashcardWhereUniqueInput
    update: XOR<FlashcardUpdateWithoutCourseInput, FlashcardUncheckedUpdateWithoutCourseInput>
    create: XOR<FlashcardCreateWithoutCourseInput, FlashcardUncheckedCreateWithoutCourseInput>
  }

  export type FlashcardUpdateWithWhereUniqueWithoutCourseInput = {
    where: FlashcardWhereUniqueInput
    data: XOR<FlashcardUpdateWithoutCourseInput, FlashcardUncheckedUpdateWithoutCourseInput>
  }

  export type FlashcardUpdateManyWithWhereWithoutCourseInput = {
    where: FlashcardScalarWhereInput
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyWithoutCourseInput>
  }

  export type ChatbotMessageUpsertWithWhereUniqueWithoutCourseInput = {
    where: ChatbotMessageWhereUniqueInput
    update: XOR<ChatbotMessageUpdateWithoutCourseInput, ChatbotMessageUncheckedUpdateWithoutCourseInput>
    create: XOR<ChatbotMessageCreateWithoutCourseInput, ChatbotMessageUncheckedCreateWithoutCourseInput>
  }

  export type ChatbotMessageUpdateWithWhereUniqueWithoutCourseInput = {
    where: ChatbotMessageWhereUniqueInput
    data: XOR<ChatbotMessageUpdateWithoutCourseInput, ChatbotMessageUncheckedUpdateWithoutCourseInput>
  }

  export type ChatbotMessageUpdateManyWithWhereWithoutCourseInput = {
    where: ChatbotMessageScalarWhereInput
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyWithoutCourseInput>
  }

  export type SavedAnswerUpsertWithWhereUniqueWithoutCourseInput = {
    where: SavedAnswerWhereUniqueInput
    update: XOR<SavedAnswerUpdateWithoutCourseInput, SavedAnswerUncheckedUpdateWithoutCourseInput>
    create: XOR<SavedAnswerCreateWithoutCourseInput, SavedAnswerUncheckedCreateWithoutCourseInput>
  }

  export type SavedAnswerUpdateWithWhereUniqueWithoutCourseInput = {
    where: SavedAnswerWhereUniqueInput
    data: XOR<SavedAnswerUpdateWithoutCourseInput, SavedAnswerUncheckedUpdateWithoutCourseInput>
  }

  export type SavedAnswerUpdateManyWithWhereWithoutCourseInput = {
    where: SavedAnswerScalarWhereInput
    data: XOR<SavedAnswerUpdateManyMutationInput, SavedAnswerUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTagsUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseTagsWhereUniqueInput
    update: XOR<CourseTagsUpdateWithoutCourseInput, CourseTagsUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseTagsCreateWithoutCourseInput, CourseTagsUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagsUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseTagsWhereUniqueInput
    data: XOR<CourseTagsUpdateWithoutCourseInput, CourseTagsUncheckedUpdateWithoutCourseInput>
  }

  export type CourseTagsUpdateManyWithWhereWithoutCourseInput = {
    where: CourseTagsScalarWhereInput
    data: XOR<CourseTagsUpdateManyMutationInput, CourseTagsUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTagsScalarWhereInput = {
    AND?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
    OR?: CourseTagsScalarWhereInput[]
    NOT?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
    id?: IntFilter<"CourseTags"> | number
    courseId?: IntFilter<"CourseTags"> | number
    name?: StringFilter<"CourseTags"> | string
  }

  export type CourseReviewUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseReviewWhereUniqueInput
    update: XOR<CourseReviewUpdateWithoutCourseInput, CourseReviewUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseReviewCreateWithoutCourseInput, CourseReviewUncheckedCreateWithoutCourseInput>
  }

  export type CourseReviewUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseReviewWhereUniqueInput
    data: XOR<CourseReviewUpdateWithoutCourseInput, CourseReviewUncheckedUpdateWithoutCourseInput>
  }

  export type CourseReviewUpdateManyWithWhereWithoutCourseInput = {
    where: CourseReviewScalarWhereInput
    data: XOR<CourseReviewUpdateManyMutationInput, CourseReviewUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutTagsInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTagsInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTagsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
  }

  export type CourseUpsertWithoutTagsInput = {
    update: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTagsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type CourseUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutLearningOutcomesInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLearningOutcomesInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLearningOutcomesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLearningOutcomesInput, CourseUncheckedCreateWithoutLearningOutcomesInput>
  }

  export type CourseUpsertWithoutLearningOutcomesInput = {
    update: XOR<CourseUpdateWithoutLearningOutcomesInput, CourseUncheckedUpdateWithoutLearningOutcomesInput>
    create: XOR<CourseCreateWithoutLearningOutcomesInput, CourseUncheckedCreateWithoutLearningOutcomesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLearningOutcomesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLearningOutcomesInput, CourseUncheckedUpdateWithoutLearningOutcomesInput>
  }

  export type CourseUpdateWithoutLearningOutcomesInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLearningOutcomesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutRequirementsInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutRequirementsInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutRequirementsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutRequirementsInput, CourseUncheckedCreateWithoutRequirementsInput>
  }

  export type CourseUpsertWithoutRequirementsInput = {
    update: XOR<CourseUpdateWithoutRequirementsInput, CourseUncheckedUpdateWithoutRequirementsInput>
    create: XOR<CourseCreateWithoutRequirementsInput, CourseUncheckedCreateWithoutRequirementsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutRequirementsInput, CourseUncheckedUpdateWithoutRequirementsInput>
  }

  export type CourseUpdateWithoutRequirementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutRequirementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutModulesInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type ContentUnitCreateWithoutModuleInput = {
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UnitProgressCreateNestedManyWithoutUnitInput
    attachments?: UnitAttachmentCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitUncheckedCreateWithoutModuleInput = {
    id?: number
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UnitProgressUncheckedCreateNestedManyWithoutUnitInput
    attachments?: UnitAttachmentUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitCreateOrConnectWithoutModuleInput = {
    where: ContentUnitWhereUniqueInput
    create: XOR<ContentUnitCreateWithoutModuleInput, ContentUnitUncheckedCreateWithoutModuleInput>
  }

  export type ContentUnitCreateManyModuleInputEnvelope = {
    data: ContentUnitCreateManyModuleInput | ContentUnitCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutModuleInput = {
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutModuleInput = {
    id?: number
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutModuleInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutModuleInput, QuizUncheckedCreateWithoutModuleInput>
  }

  export type QuizCreateManyModuleInputEnvelope = {
    data: QuizCreateManyModuleInput | QuizCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutModuleInput = {
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
    submissions?: ExerciseSubmissionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutModuleInput = {
    id?: number
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
    submissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutModuleInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutModuleInput, ExerciseUncheckedCreateWithoutModuleInput>
  }

  export type ExerciseCreateManyModuleInputEnvelope = {
    data: ExerciseCreateManyModuleInput | ExerciseCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleProgressCreateWithoutModuleInput = {
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
    enrollment: EnrollmentCreateNestedOneWithoutModuleProgressInput
  }

  export type ModuleProgressUncheckedCreateWithoutModuleInput = {
    id?: number
    enrollmentId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
  }

  export type ModuleProgressCreateOrConnectWithoutModuleInput = {
    where: ModuleProgressWhereUniqueInput
    create: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput>
  }

  export type ModuleProgressCreateManyModuleInputEnvelope = {
    data: ModuleProgressCreateManyModuleInput | ModuleProgressCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardCreateWithoutModuleInput = {
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    user: UserCreateNestedOneWithoutFlashcardsInput
    course?: CourseCreateNestedOneWithoutFlashcardsInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardUncheckedCreateWithoutModuleInput = {
    id?: number
    userId: number
    courseId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutFlashcardInput
    collections?: FlashcardCollectionItemUncheckedCreateNestedManyWithoutFlashcardInput
  }

  export type FlashcardCreateOrConnectWithoutModuleInput = {
    where: FlashcardWhereUniqueInput
    create: XOR<FlashcardCreateWithoutModuleInput, FlashcardUncheckedCreateWithoutModuleInput>
  }

  export type FlashcardCreateManyModuleInputEnvelope = {
    data: FlashcardCreateManyModuleInput | FlashcardCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotMessageCreateWithoutModuleInput = {
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    session: ChatbotSessionCreateNestedOneWithoutMessagesInput
    course?: CourseCreateNestedOneWithoutChatbotMessagesInput
    feedback?: ChatbotFeedbackCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageUncheckedCreateWithoutModuleInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
    feedback?: ChatbotFeedbackUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChatbotMessageCreateOrConnectWithoutModuleInput = {
    where: ChatbotMessageWhereUniqueInput
    create: XOR<ChatbotMessageCreateWithoutModuleInput, ChatbotMessageUncheckedCreateWithoutModuleInput>
  }

  export type ChatbotMessageCreateManyModuleInputEnvelope = {
    data: ChatbotMessageCreateManyModuleInput | ChatbotMessageCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ContentUnitUpsertWithWhereUniqueWithoutModuleInput = {
    where: ContentUnitWhereUniqueInput
    update: XOR<ContentUnitUpdateWithoutModuleInput, ContentUnitUncheckedUpdateWithoutModuleInput>
    create: XOR<ContentUnitCreateWithoutModuleInput, ContentUnitUncheckedCreateWithoutModuleInput>
  }

  export type ContentUnitUpdateWithWhereUniqueWithoutModuleInput = {
    where: ContentUnitWhereUniqueInput
    data: XOR<ContentUnitUpdateWithoutModuleInput, ContentUnitUncheckedUpdateWithoutModuleInput>
  }

  export type ContentUnitUpdateManyWithWhereWithoutModuleInput = {
    where: ContentUnitScalarWhereInput
    data: XOR<ContentUnitUpdateManyMutationInput, ContentUnitUncheckedUpdateManyWithoutModuleInput>
  }

  export type ContentUnitScalarWhereInput = {
    AND?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
    OR?: ContentUnitScalarWhereInput[]
    NOT?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
    id?: IntFilter<"ContentUnit"> | number
    moduleId?: IntFilter<"ContentUnit"> | number
    title?: StringFilter<"ContentUnit"> | string
    description?: StringNullableFilter<"ContentUnit"> | string | null
    contentType?: EnumContentTypeFilter<"ContentUnit"> | $Enums.ContentType
    orderNumber?: IntFilter<"ContentUnit"> | number
    estimatedMinutes?: IntNullableFilter<"ContentUnit"> | number | null
    isRequired?: BoolFilter<"ContentUnit"> | boolean
    textContent?: StringNullableFilter<"ContentUnit"> | string | null
    videoUrl?: StringNullableFilter<"ContentUnit"> | string | null
    audioUrl?: StringNullableFilter<"ContentUnit"> | string | null
    fileUrl?: StringNullableFilter<"ContentUnit"> | string | null
    externalUrl?: StringNullableFilter<"ContentUnit"> | string | null
    createdAt?: DateTimeFilter<"ContentUnit"> | Date | string
    updatedAt?: DateTimeFilter<"ContentUnit"> | Date | string
  }

  export type QuizUpsertWithWhereUniqueWithoutModuleInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutModuleInput, QuizUncheckedUpdateWithoutModuleInput>
    create: XOR<QuizCreateWithoutModuleInput, QuizUncheckedCreateWithoutModuleInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutModuleInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutModuleInput, QuizUncheckedUpdateWithoutModuleInput>
  }

  export type QuizUpdateManyWithWhereWithoutModuleInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutModuleInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: IntFilter<"Quiz"> | number
    moduleId?: IntFilter<"Quiz"> | number
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    passingScore?: IntFilter<"Quiz"> | number
    allowRetakes?: BoolFilter<"Quiz"> | boolean
    maxAttempts?: IntNullableFilter<"Quiz"> | number | null
    randomizeQuestions?: BoolFilter<"Quiz"> | boolean
    showCorrectAnswers?: BoolFilter<"Quiz"> | boolean
    orderNumber?: IntFilter<"Quiz"> | number
    isPublished?: BoolFilter<"Quiz"> | boolean
  }

  export type ExerciseUpsertWithWhereUniqueWithoutModuleInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutModuleInput, ExerciseUncheckedUpdateWithoutModuleInput>
    create: XOR<ExerciseCreateWithoutModuleInput, ExerciseUncheckedCreateWithoutModuleInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutModuleInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutModuleInput, ExerciseUncheckedUpdateWithoutModuleInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutModuleInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutModuleInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: IntFilter<"Exercise"> | number
    moduleId?: IntFilter<"Exercise"> | number
    title?: StringFilter<"Exercise"> | string
    description?: StringFilter<"Exercise"> | string
    instructions?: StringFilter<"Exercise"> | string
    exerciseType?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    orderNumber?: IntFilter<"Exercise"> | number
    dueDate?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    allowLateSubmissions?: BoolFilter<"Exercise"> | boolean
    maxScore?: IntFilter<"Exercise"> | number
  }

  export type ModuleProgressUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleProgressWhereUniqueInput
    update: XOR<ModuleProgressUpdateWithoutModuleInput, ModuleProgressUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput>
  }

  export type ModuleProgressUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleProgressWhereUniqueInput
    data: XOR<ModuleProgressUpdateWithoutModuleInput, ModuleProgressUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleProgressUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleProgressScalarWhereInput
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleProgressScalarWhereInput = {
    AND?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
    OR?: ModuleProgressScalarWhereInput[]
    NOT?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
    id?: IntFilter<"ModuleProgress"> | number
    enrollmentId?: IntFilter<"ModuleProgress"> | number
    moduleId?: IntFilter<"ModuleProgress"> | number
    userId?: IntFilter<"ModuleProgress"> | number
    startedAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    progressPercentage?: IntFilter<"ModuleProgress"> | number
  }

  export type FlashcardUpsertWithWhereUniqueWithoutModuleInput = {
    where: FlashcardWhereUniqueInput
    update: XOR<FlashcardUpdateWithoutModuleInput, FlashcardUncheckedUpdateWithoutModuleInput>
    create: XOR<FlashcardCreateWithoutModuleInput, FlashcardUncheckedCreateWithoutModuleInput>
  }

  export type FlashcardUpdateWithWhereUniqueWithoutModuleInput = {
    where: FlashcardWhereUniqueInput
    data: XOR<FlashcardUpdateWithoutModuleInput, FlashcardUncheckedUpdateWithoutModuleInput>
  }

  export type FlashcardUpdateManyWithWhereWithoutModuleInput = {
    where: FlashcardScalarWhereInput
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyWithoutModuleInput>
  }

  export type ChatbotMessageUpsertWithWhereUniqueWithoutModuleInput = {
    where: ChatbotMessageWhereUniqueInput
    update: XOR<ChatbotMessageUpdateWithoutModuleInput, ChatbotMessageUncheckedUpdateWithoutModuleInput>
    create: XOR<ChatbotMessageCreateWithoutModuleInput, ChatbotMessageUncheckedCreateWithoutModuleInput>
  }

  export type ChatbotMessageUpdateWithWhereUniqueWithoutModuleInput = {
    where: ChatbotMessageWhereUniqueInput
    data: XOR<ChatbotMessageUpdateWithoutModuleInput, ChatbotMessageUncheckedUpdateWithoutModuleInput>
  }

  export type ChatbotMessageUpdateManyWithWhereWithoutModuleInput = {
    where: ChatbotMessageScalarWhereInput
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyWithoutModuleInput>
  }

  export type CourseModuleCreateWithoutUnitsInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutUnitsInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutUnitsInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutUnitsInput, CourseModuleUncheckedCreateWithoutUnitsInput>
  }

  export type UnitProgressCreateWithoutUnitInput = {
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
    enrollment: EnrollmentCreateNestedOneWithoutUnitProgressInput
  }

  export type UnitProgressUncheckedCreateWithoutUnitInput = {
    id?: number
    enrollmentId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
  }

  export type UnitProgressCreateOrConnectWithoutUnitInput = {
    where: UnitProgressWhereUniqueInput
    create: XOR<UnitProgressCreateWithoutUnitInput, UnitProgressUncheckedCreateWithoutUnitInput>
  }

  export type UnitProgressCreateManyUnitInputEnvelope = {
    data: UnitProgressCreateManyUnitInput | UnitProgressCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitAttachmentCreateWithoutUnitInput = {
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
  }

  export type UnitAttachmentUncheckedCreateWithoutUnitInput = {
    id?: number
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
  }

  export type UnitAttachmentCreateOrConnectWithoutUnitInput = {
    where: UnitAttachmentWhereUniqueInput
    create: XOR<UnitAttachmentCreateWithoutUnitInput, UnitAttachmentUncheckedCreateWithoutUnitInput>
  }

  export type UnitAttachmentCreateManyUnitInputEnvelope = {
    data: UnitAttachmentCreateManyUnitInput | UnitAttachmentCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleUpsertWithoutUnitsInput = {
    update: XOR<CourseModuleUpdateWithoutUnitsInput, CourseModuleUncheckedUpdateWithoutUnitsInput>
    create: XOR<CourseModuleCreateWithoutUnitsInput, CourseModuleUncheckedCreateWithoutUnitsInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutUnitsInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutUnitsInput, CourseModuleUncheckedUpdateWithoutUnitsInput>
  }

  export type CourseModuleUpdateWithoutUnitsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type UnitProgressUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitProgressWhereUniqueInput
    update: XOR<UnitProgressUpdateWithoutUnitInput, UnitProgressUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitProgressCreateWithoutUnitInput, UnitProgressUncheckedCreateWithoutUnitInput>
  }

  export type UnitProgressUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitProgressWhereUniqueInput
    data: XOR<UnitProgressUpdateWithoutUnitInput, UnitProgressUncheckedUpdateWithoutUnitInput>
  }

  export type UnitProgressUpdateManyWithWhereWithoutUnitInput = {
    where: UnitProgressScalarWhereInput
    data: XOR<UnitProgressUpdateManyMutationInput, UnitProgressUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitProgressScalarWhereInput = {
    AND?: UnitProgressScalarWhereInput | UnitProgressScalarWhereInput[]
    OR?: UnitProgressScalarWhereInput[]
    NOT?: UnitProgressScalarWhereInput | UnitProgressScalarWhereInput[]
    id?: IntFilter<"UnitProgress"> | number
    enrollmentId?: IntFilter<"UnitProgress"> | number
    unitId?: IntFilter<"UnitProgress"> | number
    userId?: IntFilter<"UnitProgress"> | number
    startedAt?: DateTimeFilter<"UnitProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"UnitProgress"> | Date | string | null
    timeSpentMinutes?: IntFilter<"UnitProgress"> | number
    lastPosition?: StringNullableFilter<"UnitProgress"> | string | null
  }

  export type UnitAttachmentUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitAttachmentWhereUniqueInput
    update: XOR<UnitAttachmentUpdateWithoutUnitInput, UnitAttachmentUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitAttachmentCreateWithoutUnitInput, UnitAttachmentUncheckedCreateWithoutUnitInput>
  }

  export type UnitAttachmentUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitAttachmentWhereUniqueInput
    data: XOR<UnitAttachmentUpdateWithoutUnitInput, UnitAttachmentUncheckedUpdateWithoutUnitInput>
  }

  export type UnitAttachmentUpdateManyWithWhereWithoutUnitInput = {
    where: UnitAttachmentScalarWhereInput
    data: XOR<UnitAttachmentUpdateManyMutationInput, UnitAttachmentUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitAttachmentScalarWhereInput = {
    AND?: UnitAttachmentScalarWhereInput | UnitAttachmentScalarWhereInput[]
    OR?: UnitAttachmentScalarWhereInput[]
    NOT?: UnitAttachmentScalarWhereInput | UnitAttachmentScalarWhereInput[]
    id?: IntFilter<"UnitAttachment"> | number
    unitId?: IntFilter<"UnitAttachment"> | number
    title?: StringFilter<"UnitAttachment"> | string
    description?: StringNullableFilter<"UnitAttachment"> | string | null
    fileUrl?: StringFilter<"UnitAttachment"> | string
    fileType?: StringFilter<"UnitAttachment"> | string
  }

  export type ContentUnitCreateWithoutAttachmentsInput = {
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    module: CourseModuleCreateNestedOneWithoutUnitsInput
    progress?: UnitProgressCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UnitProgressUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitCreateOrConnectWithoutAttachmentsInput = {
    where: ContentUnitWhereUniqueInput
    create: XOR<ContentUnitCreateWithoutAttachmentsInput, ContentUnitUncheckedCreateWithoutAttachmentsInput>
  }

  export type ContentUnitUpsertWithoutAttachmentsInput = {
    update: XOR<ContentUnitUpdateWithoutAttachmentsInput, ContentUnitUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ContentUnitCreateWithoutAttachmentsInput, ContentUnitUncheckedCreateWithoutAttachmentsInput>
    where?: ContentUnitWhereInput
  }

  export type ContentUnitUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ContentUnitWhereInput
    data: XOR<ContentUnitUpdateWithoutAttachmentsInput, ContentUnitUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ContentUnitUpdateWithoutAttachmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: CourseModuleUpdateOneRequiredWithoutUnitsNestedInput
    progress?: UnitProgressUpdateManyWithoutUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UnitProgressUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserCreateWithoutEnrollmentsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ModuleProgressCreateWithoutEnrollmentInput = {
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
    module: CourseModuleCreateNestedOneWithoutUserProgressInput
  }

  export type ModuleProgressUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    moduleId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
  }

  export type ModuleProgressCreateOrConnectWithoutEnrollmentInput = {
    where: ModuleProgressWhereUniqueInput
    create: XOR<ModuleProgressCreateWithoutEnrollmentInput, ModuleProgressUncheckedCreateWithoutEnrollmentInput>
  }

  export type ModuleProgressCreateManyEnrollmentInputEnvelope = {
    data: ModuleProgressCreateManyEnrollmentInput | ModuleProgressCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type UnitProgressCreateWithoutEnrollmentInput = {
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
    unit: ContentUnitCreateNestedOneWithoutProgressInput
  }

  export type UnitProgressUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    unitId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
  }

  export type UnitProgressCreateOrConnectWithoutEnrollmentInput = {
    where: UnitProgressWhereUniqueInput
    create: XOR<UnitProgressCreateWithoutEnrollmentInput, UnitProgressUncheckedCreateWithoutEnrollmentInput>
  }

  export type UnitProgressCreateManyEnrollmentInputEnvelope = {
    data: UnitProgressCreateManyEnrollmentInput | UnitProgressCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutEnrollmentInput = {
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    answers?: QuestionAnswerCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    quizId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    answers?: QuestionAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutEnrollmentInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutEnrollmentInput, QuizAttemptUncheckedCreateWithoutEnrollmentInput>
  }

  export type QuizAttemptCreateManyEnrollmentInputEnvelope = {
    data: QuizAttemptCreateManyEnrollmentInput | QuizAttemptCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseSubmissionCreateWithoutEnrollmentInput = {
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
    exercise: ExerciseCreateNestedOneWithoutSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    exerciseId: number
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
  }

  export type ExerciseSubmissionCreateOrConnectWithoutEnrollmentInput = {
    where: ExerciseSubmissionWhereUniqueInput
    create: XOR<ExerciseSubmissionCreateWithoutEnrollmentInput, ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput>
  }

  export type ExerciseSubmissionCreateManyEnrollmentInputEnvelope = {
    data: ExerciseSubmissionCreateManyEnrollmentInput | ExerciseSubmissionCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ModuleProgressUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: ModuleProgressWhereUniqueInput
    update: XOR<ModuleProgressUpdateWithoutEnrollmentInput, ModuleProgressUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<ModuleProgressCreateWithoutEnrollmentInput, ModuleProgressUncheckedCreateWithoutEnrollmentInput>
  }

  export type ModuleProgressUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: ModuleProgressWhereUniqueInput
    data: XOR<ModuleProgressUpdateWithoutEnrollmentInput, ModuleProgressUncheckedUpdateWithoutEnrollmentInput>
  }

  export type ModuleProgressUpdateManyWithWhereWithoutEnrollmentInput = {
    where: ModuleProgressScalarWhereInput
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type UnitProgressUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: UnitProgressWhereUniqueInput
    update: XOR<UnitProgressUpdateWithoutEnrollmentInput, UnitProgressUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<UnitProgressCreateWithoutEnrollmentInput, UnitProgressUncheckedCreateWithoutEnrollmentInput>
  }

  export type UnitProgressUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: UnitProgressWhereUniqueInput
    data: XOR<UnitProgressUpdateWithoutEnrollmentInput, UnitProgressUncheckedUpdateWithoutEnrollmentInput>
  }

  export type UnitProgressUpdateManyWithWhereWithoutEnrollmentInput = {
    where: UnitProgressScalarWhereInput
    data: XOR<UnitProgressUpdateManyMutationInput, UnitProgressUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutEnrollmentInput, QuizAttemptUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<QuizAttemptCreateWithoutEnrollmentInput, QuizAttemptUncheckedCreateWithoutEnrollmentInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutEnrollmentInput, QuizAttemptUncheckedUpdateWithoutEnrollmentInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutEnrollmentInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    enrollmentId?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    userId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    score?: IntNullableFilter<"QuizAttempt"> | number | null
    percentage?: FloatNullableFilter<"QuizAttempt"> | number | null
    passed?: BoolNullableFilter<"QuizAttempt"> | boolean | null
    attemptNumber?: IntFilter<"QuizAttempt"> | number
  }

  export type ExerciseSubmissionUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: ExerciseSubmissionWhereUniqueInput
    update: XOR<ExerciseSubmissionUpdateWithoutEnrollmentInput, ExerciseSubmissionUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<ExerciseSubmissionCreateWithoutEnrollmentInput, ExerciseSubmissionUncheckedCreateWithoutEnrollmentInput>
  }

  export type ExerciseSubmissionUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: ExerciseSubmissionWhereUniqueInput
    data: XOR<ExerciseSubmissionUpdateWithoutEnrollmentInput, ExerciseSubmissionUncheckedUpdateWithoutEnrollmentInput>
  }

  export type ExerciseSubmissionUpdateManyWithWhereWithoutEnrollmentInput = {
    where: ExerciseSubmissionScalarWhereInput
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type ExerciseSubmissionScalarWhereInput = {
    AND?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
    OR?: ExerciseSubmissionScalarWhereInput[]
    NOT?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
    id?: IntFilter<"ExerciseSubmission"> | number
    exerciseId?: IntFilter<"ExerciseSubmission"> | number
    enrollmentId?: IntFilter<"ExerciseSubmission"> | number
    userId?: IntFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeFilter<"ExerciseSubmission"> | Date | string
    content?: StringNullableFilter<"ExerciseSubmission"> | string | null
    fileUrl?: StringNullableFilter<"ExerciseSubmission"> | string | null
    score?: IntNullableFilter<"ExerciseSubmission"> | number | null
    feedback?: StringNullableFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"ExerciseSubmission"> | Date | string | null
    gradedBy?: IntNullableFilter<"ExerciseSubmission"> | number | null
  }

  export type EnrollmentCreateWithoutModuleProgressInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentsInput
    unitProgress?: UnitProgressCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutModuleProgressInput = {
    id?: number
    userId: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    unitProgress?: UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutModuleProgressInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutModuleProgressInput, EnrollmentUncheckedCreateWithoutModuleProgressInput>
  }

  export type CourseModuleCreateWithoutUserProgressInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutUserProgressInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutUserProgressInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutUserProgressInput, CourseModuleUncheckedCreateWithoutUserProgressInput>
  }

  export type EnrollmentUpsertWithoutModuleProgressInput = {
    update: XOR<EnrollmentUpdateWithoutModuleProgressInput, EnrollmentUncheckedUpdateWithoutModuleProgressInput>
    create: XOR<EnrollmentCreateWithoutModuleProgressInput, EnrollmentUncheckedCreateWithoutModuleProgressInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutModuleProgressInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutModuleProgressInput, EnrollmentUncheckedUpdateWithoutModuleProgressInput>
  }

  export type EnrollmentUpdateWithoutModuleProgressInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    unitProgress?: UnitProgressUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutModuleProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    unitProgress?: UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type CourseModuleUpsertWithoutUserProgressInput = {
    update: XOR<CourseModuleUpdateWithoutUserProgressInput, CourseModuleUncheckedUpdateWithoutUserProgressInput>
    create: XOR<CourseModuleCreateWithoutUserProgressInput, CourseModuleUncheckedCreateWithoutUserProgressInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutUserProgressInput, CourseModuleUncheckedUpdateWithoutUserProgressInput>
  }

  export type CourseModuleUpdateWithoutUserProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutUserProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type EnrollmentCreateWithoutUnitProgressInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentsInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutUnitProgressInput = {
    id?: number
    userId: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutUnitProgressInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUnitProgressInput, EnrollmentUncheckedCreateWithoutUnitProgressInput>
  }

  export type ContentUnitCreateWithoutProgressInput = {
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    module: CourseModuleCreateNestedOneWithoutUnitsInput
    attachments?: UnitAttachmentCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitUncheckedCreateWithoutProgressInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: UnitAttachmentUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ContentUnitCreateOrConnectWithoutProgressInput = {
    where: ContentUnitWhereUniqueInput
    create: XOR<ContentUnitCreateWithoutProgressInput, ContentUnitUncheckedCreateWithoutProgressInput>
  }

  export type EnrollmentUpsertWithoutUnitProgressInput = {
    update: XOR<EnrollmentUpdateWithoutUnitProgressInput, EnrollmentUncheckedUpdateWithoutUnitProgressInput>
    create: XOR<EnrollmentCreateWithoutUnitProgressInput, EnrollmentUncheckedCreateWithoutUnitProgressInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutUnitProgressInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutUnitProgressInput, EnrollmentUncheckedUpdateWithoutUnitProgressInput>
  }

  export type EnrollmentUpdateWithoutUnitProgressInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUnitProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type ContentUnitUpsertWithoutProgressInput = {
    update: XOR<ContentUnitUpdateWithoutProgressInput, ContentUnitUncheckedUpdateWithoutProgressInput>
    create: XOR<ContentUnitCreateWithoutProgressInput, ContentUnitUncheckedCreateWithoutProgressInput>
    where?: ContentUnitWhereInput
  }

  export type ContentUnitUpdateToOneWithWhereWithoutProgressInput = {
    where?: ContentUnitWhereInput
    data: XOR<ContentUnitUpdateWithoutProgressInput, ContentUnitUncheckedUpdateWithoutProgressInput>
  }

  export type ContentUnitUpdateWithoutProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: CourseModuleUpdateOneRequiredWithoutUnitsNestedInput
    attachments?: UnitAttachmentUpdateManyWithoutUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateWithoutProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: UnitAttachmentUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type CourseModuleCreateWithoutQuizzesInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    exercises?: ExerciseCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutQuizzesInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutQuizzesInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutQuizzesInput, CourseModuleUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
    answers?: QuestionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: number
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
    answers?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutQuizInput = {
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    enrollment: EnrollmentCreateNestedOneWithoutQuizAttemptsInput
    answers?: QuestionAnswerCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutQuizInput = {
    id?: number
    enrollmentId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    answers?: QuestionAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptCreateManyQuizInputEnvelope = {
    data: QuizAttemptCreateManyQuizInput | QuizAttemptCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleUpsertWithoutQuizzesInput = {
    update: XOR<CourseModuleUpdateWithoutQuizzesInput, CourseModuleUncheckedUpdateWithoutQuizzesInput>
    create: XOR<CourseModuleCreateWithoutQuizzesInput, CourseModuleUncheckedCreateWithoutQuizzesInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutQuizzesInput, CourseModuleUncheckedUpdateWithoutQuizzesInput>
  }

  export type CourseModuleUpdateWithoutQuizzesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: IntFilter<"QuizQuestion"> | number
    quizId?: IntFilter<"QuizQuestion"> | number
    questionText?: StringFilter<"QuizQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"QuizQuestion"> | $Enums.QuestionType
    points?: IntFilter<"QuizQuestion"> | number
    orderNumber?: IntFilter<"QuizQuestion"> | number
    options?: StringNullableFilter<"QuizQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"QuizQuestion"> | string | null
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutQuizInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizCreateWithoutQuestionsInput = {
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    module: CourseModuleCreateNestedOneWithoutQuizzesInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionAnswerCreateWithoutQuestionInput = {
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
    attempt: QuizAttemptCreateNestedOneWithoutAnswersInput
  }

  export type QuestionAnswerUncheckedCreateWithoutQuestionInput = {
    id?: number
    attemptId: number
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
  }

  export type QuestionAnswerCreateOrConnectWithoutQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionAnswerCreateManyQuestionInputEnvelope = {
    data: QuestionAnswerCreateManyQuestionInput | QuestionAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    module?: CourseModuleUpdateOneRequiredWithoutQuizzesNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutQuestionInput, QuestionAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutQuestionInput, QuestionAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionAnswerScalarWhereInput = {
    AND?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
    OR?: QuestionAnswerScalarWhereInput[]
    NOT?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
    id?: IntFilter<"QuestionAnswer"> | number
    attemptId?: IntFilter<"QuestionAnswer"> | number
    questionId?: IntFilter<"QuestionAnswer"> | number
    userAnswer?: StringNullableFilter<"QuestionAnswer"> | string | null
    isCorrect?: BoolNullableFilter<"QuestionAnswer"> | boolean | null
    pointsAwarded?: IntNullableFilter<"QuestionAnswer"> | number | null
  }

  export type EnrollmentCreateWithoutQuizAttemptsInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentsInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutQuizAttemptsInput = {
    id?: number
    userId: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutQuizAttemptsInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutQuizAttemptsInput, EnrollmentUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type QuizCreateWithoutAttemptsInput = {
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    module: CourseModuleCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutAttemptsInput = {
    id?: number
    moduleId: number
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutAttemptsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
  }

  export type QuestionAnswerCreateWithoutAttemptInput = {
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuestionAnswerUncheckedCreateWithoutAttemptInput = {
    id?: number
    questionId: number
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
  }

  export type QuestionAnswerCreateOrConnectWithoutAttemptInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutAttemptInput, QuestionAnswerUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionAnswerCreateManyAttemptInputEnvelope = {
    data: QuestionAnswerCreateManyAttemptInput | QuestionAnswerCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentUpsertWithoutQuizAttemptsInput = {
    update: XOR<EnrollmentUpdateWithoutQuizAttemptsInput, EnrollmentUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<EnrollmentCreateWithoutQuizAttemptsInput, EnrollmentUncheckedCreateWithoutQuizAttemptsInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutQuizAttemptsInput, EnrollmentUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type EnrollmentUpdateWithoutQuizAttemptsInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type QuizUpsertWithoutAttemptsInput = {
    update: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    module?: CourseModuleUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutAttemptInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutAttemptInput, QuestionAnswerUncheckedUpdateWithoutAttemptInput>
    create: XOR<QuestionAnswerCreateWithoutAttemptInput, QuestionAnswerUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutAttemptInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutAttemptInput, QuestionAnswerUncheckedUpdateWithoutAttemptInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutAttemptInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutAttemptInput>
  }

  export type QuizAttemptCreateWithoutAnswersInput = {
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
    enrollment: EnrollmentCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutAnswersInput = {
    id?: number
    enrollmentId: number
    quizId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
  }

  export type QuizAttemptCreateOrConnectWithoutAnswersInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
  }

  export type QuizQuestionCreateWithoutAnswersInput = {
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateWithoutAnswersInput = {
    id?: number
    quizId: number
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
  }

  export type QuizQuestionCreateOrConnectWithoutAnswersInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuizAttemptUpsertWithoutAnswersInput = {
    update: XOR<QuizAttemptUpdateWithoutAnswersInput, QuizAttemptUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
    where?: QuizAttemptWhereInput
  }

  export type QuizAttemptUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizAttemptWhereInput
    data: XOR<QuizAttemptUpdateWithoutAnswersInput, QuizAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizAttemptUpdateWithoutAnswersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    enrollment?: EnrollmentUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionUpsertWithoutAnswersInput = {
    update: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionUpdateWithoutAnswersInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseModuleCreateWithoutExercisesInput = {
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    units?: ContentUnitCreateNestedManyWithoutModuleInput
    quizzes?: QuizCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutExercisesInput = {
    id?: number
    courseId: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ContentUnitUncheckedCreateNestedManyWithoutModuleInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutModuleInput
    userProgress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutModuleInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutExercisesInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutExercisesInput, CourseModuleUncheckedCreateWithoutExercisesInput>
  }

  export type ExerciseSubmissionCreateWithoutExerciseInput = {
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
    enrollment: EnrollmentCreateNestedOneWithoutExerciseSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateWithoutExerciseInput = {
    id?: number
    enrollmentId: number
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
  }

  export type ExerciseSubmissionCreateOrConnectWithoutExerciseInput = {
    where: ExerciseSubmissionWhereUniqueInput
    create: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseSubmissionCreateManyExerciseInputEnvelope = {
    data: ExerciseSubmissionCreateManyExerciseInput | ExerciseSubmissionCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleUpsertWithoutExercisesInput = {
    update: XOR<CourseModuleUpdateWithoutExercisesInput, CourseModuleUncheckedUpdateWithoutExercisesInput>
    create: XOR<CourseModuleCreateWithoutExercisesInput, CourseModuleUncheckedCreateWithoutExercisesInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutExercisesInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutExercisesInput, CourseModuleUncheckedUpdateWithoutExercisesInput>
  }

  export type CourseModuleUpdateWithoutExercisesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseSubmissionWhereUniqueInput
    update: XOR<ExerciseSubmissionUpdateWithoutExerciseInput, ExerciseSubmissionUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseSubmissionWhereUniqueInput
    data: XOR<ExerciseSubmissionUpdateWithoutExerciseInput, ExerciseSubmissionUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseSubmissionScalarWhereInput
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExerciseCreateWithoutSubmissionsInput = {
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
    module: CourseModuleCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutSubmissionsInput = {
    id?: number
    moduleId: number
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
  }

  export type ExerciseCreateOrConnectWithoutSubmissionsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
  }

  export type EnrollmentCreateWithoutExerciseSubmissionsInput = {
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentsInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutExerciseSubmissionsInput = {
    id?: number
    userId: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    unitProgress?: UnitProgressUncheckedCreateNestedManyWithoutEnrollmentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutExerciseSubmissionsInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutExerciseSubmissionsInput, EnrollmentUncheckedCreateWithoutExerciseSubmissionsInput>
  }

  export type ExerciseUpsertWithoutSubmissionsInput = {
    update: XOR<ExerciseUpdateWithoutSubmissionsInput, ExerciseUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutSubmissionsInput, ExerciseUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ExerciseUpdateWithoutSubmissionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
    module?: CourseModuleUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type EnrollmentUpsertWithoutExerciseSubmissionsInput = {
    update: XOR<EnrollmentUpdateWithoutExerciseSubmissionsInput, EnrollmentUncheckedUpdateWithoutExerciseSubmissionsInput>
    create: XOR<EnrollmentCreateWithoutExerciseSubmissionsInput, EnrollmentUncheckedCreateWithoutExerciseSubmissionsInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutExerciseSubmissionsInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutExerciseSubmissionsInput, EnrollmentUncheckedUpdateWithoutExerciseSubmissionsInput>
  }

  export type EnrollmentUpdateWithoutExerciseSubmissionsInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutExerciseSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type CourseCreateWithoutReviewsInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    assessments?: AssessmentCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutReviewsInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    assessments?: AssessmentUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutReviewsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutReviewsInput = {
    update: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type MentorshipCreateWithoutProgramInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    mentee: UserCreateNestedOneWithoutMenteeRelationshipsInput
    mentor: UserCreateNestedOneWithoutMentorRelationshipsInput
    sessions?: MentorshipSessionCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipUncheckedCreateWithoutProgramInput = {
    id?: number
    mentorId: number
    menteeId: number
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    sessions?: MentorshipSessionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type MentorshipCreateOrConnectWithoutProgramInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutProgramInput, MentorshipUncheckedCreateWithoutProgramInput>
  }

  export type MentorshipCreateManyProgramInputEnvelope = {
    data: MentorshipCreateManyProgramInput | MentorshipCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type MentorshipUpsertWithWhereUniqueWithoutProgramInput = {
    where: MentorshipWhereUniqueInput
    update: XOR<MentorshipUpdateWithoutProgramInput, MentorshipUncheckedUpdateWithoutProgramInput>
    create: XOR<MentorshipCreateWithoutProgramInput, MentorshipUncheckedCreateWithoutProgramInput>
  }

  export type MentorshipUpdateWithWhereUniqueWithoutProgramInput = {
    where: MentorshipWhereUniqueInput
    data: XOR<MentorshipUpdateWithoutProgramInput, MentorshipUncheckedUpdateWithoutProgramInput>
  }

  export type MentorshipUpdateManyWithWhereWithoutProgramInput = {
    where: MentorshipScalarWhereInput
    data: XOR<MentorshipUpdateManyMutationInput, MentorshipUncheckedUpdateManyWithoutProgramInput>
  }

  export type UserCreateWithoutMenteeRelationshipsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMenteeRelationshipsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMenteeRelationshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMenteeRelationshipsInput, UserUncheckedCreateWithoutMenteeRelationshipsInput>
  }

  export type UserCreateWithoutMentorRelationshipsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentorRelationshipsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentorRelationshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentorRelationshipsInput, UserUncheckedCreateWithoutMentorRelationshipsInput>
  }

  export type MentorshipProgramCreateWithoutRelationshipsInput = {
    title: string
    description: string
    startDate: Date | string
    endDate?: Date | string | null
    maxMentees: number
    isActive?: boolean
  }

  export type MentorshipProgramUncheckedCreateWithoutRelationshipsInput = {
    id?: number
    title: string
    description: string
    startDate: Date | string
    endDate?: Date | string | null
    maxMentees: number
    isActive?: boolean
  }

  export type MentorshipProgramCreateOrConnectWithoutRelationshipsInput = {
    where: MentorshipProgramWhereUniqueInput
    create: XOR<MentorshipProgramCreateWithoutRelationshipsInput, MentorshipProgramUncheckedCreateWithoutRelationshipsInput>
  }

  export type MentorshipSessionCreateWithoutRelationshipInput = {
    sessionDate: Date | string
    durationMinutes: number
    notes?: string | null
    status: $Enums.SessionStatus
    feedback?: string | null
  }

  export type MentorshipSessionUncheckedCreateWithoutRelationshipInput = {
    id?: number
    sessionDate: Date | string
    durationMinutes: number
    notes?: string | null
    status: $Enums.SessionStatus
    feedback?: string | null
  }

  export type MentorshipSessionCreateOrConnectWithoutRelationshipInput = {
    where: MentorshipSessionWhereUniqueInput
    create: XOR<MentorshipSessionCreateWithoutRelationshipInput, MentorshipSessionUncheckedCreateWithoutRelationshipInput>
  }

  export type MentorshipSessionCreateManyRelationshipInputEnvelope = {
    data: MentorshipSessionCreateManyRelationshipInput | MentorshipSessionCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMenteeRelationshipsInput = {
    update: XOR<UserUpdateWithoutMenteeRelationshipsInput, UserUncheckedUpdateWithoutMenteeRelationshipsInput>
    create: XOR<UserCreateWithoutMenteeRelationshipsInput, UserUncheckedCreateWithoutMenteeRelationshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMenteeRelationshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMenteeRelationshipsInput, UserUncheckedUpdateWithoutMenteeRelationshipsInput>
  }

  export type UserUpdateWithoutMenteeRelationshipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMenteeRelationshipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMentorRelationshipsInput = {
    update: XOR<UserUpdateWithoutMentorRelationshipsInput, UserUncheckedUpdateWithoutMentorRelationshipsInput>
    create: XOR<UserCreateWithoutMentorRelationshipsInput, UserUncheckedCreateWithoutMentorRelationshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentorRelationshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentorRelationshipsInput, UserUncheckedUpdateWithoutMentorRelationshipsInput>
  }

  export type UserUpdateWithoutMentorRelationshipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentorRelationshipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MentorshipProgramUpsertWithoutRelationshipsInput = {
    update: XOR<MentorshipProgramUpdateWithoutRelationshipsInput, MentorshipProgramUncheckedUpdateWithoutRelationshipsInput>
    create: XOR<MentorshipProgramCreateWithoutRelationshipsInput, MentorshipProgramUncheckedCreateWithoutRelationshipsInput>
    where?: MentorshipProgramWhereInput
  }

  export type MentorshipProgramUpdateToOneWithWhereWithoutRelationshipsInput = {
    where?: MentorshipProgramWhereInput
    data: XOR<MentorshipProgramUpdateWithoutRelationshipsInput, MentorshipProgramUncheckedUpdateWithoutRelationshipsInput>
  }

  export type MentorshipProgramUpdateWithoutRelationshipsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorshipProgramUncheckedUpdateWithoutRelationshipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxMentees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorshipSessionUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: MentorshipSessionWhereUniqueInput
    update: XOR<MentorshipSessionUpdateWithoutRelationshipInput, MentorshipSessionUncheckedUpdateWithoutRelationshipInput>
    create: XOR<MentorshipSessionCreateWithoutRelationshipInput, MentorshipSessionUncheckedCreateWithoutRelationshipInput>
  }

  export type MentorshipSessionUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: MentorshipSessionWhereUniqueInput
    data: XOR<MentorshipSessionUpdateWithoutRelationshipInput, MentorshipSessionUncheckedUpdateWithoutRelationshipInput>
  }

  export type MentorshipSessionUpdateManyWithWhereWithoutRelationshipInput = {
    where: MentorshipSessionScalarWhereInput
    data: XOR<MentorshipSessionUpdateManyMutationInput, MentorshipSessionUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type MentorshipSessionScalarWhereInput = {
    AND?: MentorshipSessionScalarWhereInput | MentorshipSessionScalarWhereInput[]
    OR?: MentorshipSessionScalarWhereInput[]
    NOT?: MentorshipSessionScalarWhereInput | MentorshipSessionScalarWhereInput[]
    id?: IntFilter<"MentorshipSession"> | number
    relationshipId?: IntFilter<"MentorshipSession"> | number
    sessionDate?: DateTimeFilter<"MentorshipSession"> | Date | string
    durationMinutes?: IntFilter<"MentorshipSession"> | number
    notes?: StringNullableFilter<"MentorshipSession"> | string | null
    status?: EnumSessionStatusFilter<"MentorshipSession"> | $Enums.SessionStatus
    feedback?: StringNullableFilter<"MentorshipSession"> | string | null
  }

  export type MentorshipCreateWithoutSessionsInput = {
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
    mentee: UserCreateNestedOneWithoutMenteeRelationshipsInput
    mentor: UserCreateNestedOneWithoutMentorRelationshipsInput
    program?: MentorshipProgramCreateNestedOneWithoutRelationshipsInput
  }

  export type MentorshipUncheckedCreateWithoutSessionsInput = {
    id?: number
    mentorId: number
    menteeId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
  }

  export type MentorshipCreateOrConnectWithoutSessionsInput = {
    where: MentorshipWhereUniqueInput
    create: XOR<MentorshipCreateWithoutSessionsInput, MentorshipUncheckedCreateWithoutSessionsInput>
  }

  export type MentorshipUpsertWithoutSessionsInput = {
    update: XOR<MentorshipUpdateWithoutSessionsInput, MentorshipUncheckedUpdateWithoutSessionsInput>
    create: XOR<MentorshipCreateWithoutSessionsInput, MentorshipUncheckedCreateWithoutSessionsInput>
    where?: MentorshipWhereInput
  }

  export type MentorshipUpdateToOneWithWhereWithoutSessionsInput = {
    where?: MentorshipWhereInput
    data: XOR<MentorshipUpdateWithoutSessionsInput, MentorshipUncheckedUpdateWithoutSessionsInput>
  }

  export type MentorshipUpdateWithoutSessionsInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    mentee?: UserUpdateOneRequiredWithoutMenteeRelationshipsNestedInput
    mentor?: UserUpdateOneRequiredWithoutMentorRelationshipsNestedInput
    program?: MentorshipProgramUpdateOneWithoutRelationshipsNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type EventRegistrationCreateWithoutEventInput = {
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
    user: UserCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutEventInput = {
    id?: number
    userId: number
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
  }

  export type EventRegistrationCreateOrConnectWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationCreateManyEventInputEnvelope = {
    data: EventRegistrationCreateManyEventInput | EventRegistrationCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutEventInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutRegistrationsInput = {
    title: string
    description: string
    eventDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    virtualLink?: string | null
    isVirtual?: boolean
    maxParticipants?: number | null
    thumbnail?: string | null
    registrationDeadline?: Date | string | null
  }

  export type EventUncheckedCreateWithoutRegistrationsInput = {
    id?: number
    title: string
    description: string
    eventDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    virtualLink?: string | null
    isVirtual?: boolean
    maxParticipants?: number | null
    thumbnail?: string | null
    registrationDeadline?: Date | string | null
  }

  export type EventCreateOrConnectWithoutRegistrationsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
  }

  export type UserCreateWithoutEventRegistrationsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventRegistrationsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventRegistrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
  }

  export type EventUpsertWithoutRegistrationsInput = {
    update: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type EventUpdateWithoutRegistrationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateWithoutRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutEventRegistrationsInput = {
    update: XOR<UserUpdateWithoutEventRegistrationsInput, UserUncheckedUpdateWithoutEventRegistrationsInput>
    create: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventRegistrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventRegistrationsInput, UserUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type UserUpdateWithoutEventRegistrationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedCommunitiesInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedCommunitiesInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedCommunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCommunitiesInput, UserUncheckedCreateWithoutCreatedCommunitiesInput>
  }

  export type CommunityMemberCreateWithoutCommunityInput = {
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
    user: UserCreateNestedOneWithoutCommunityMembershipsInput
  }

  export type CommunityMemberUncheckedCreateWithoutCommunityInput = {
    id?: number
    userId: number
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
  }

  export type CommunityMemberCreateOrConnectWithoutCommunityInput = {
    where: CommunityMemberWhereUniqueInput
    create: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityMemberCreateManyCommunityInputEnvelope = {
    data: CommunityMemberCreateManyCommunityInput | CommunityMemberCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCommunityInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommunityInput = {
    id?: number
    authorId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommunityInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostCreateManyCommunityInputEnvelope = {
    data: PostCreateManyCommunityInput | PostCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedCommunitiesInput = {
    update: XOR<UserUpdateWithoutCreatedCommunitiesInput, UserUncheckedUpdateWithoutCreatedCommunitiesInput>
    create: XOR<UserCreateWithoutCreatedCommunitiesInput, UserUncheckedCreateWithoutCreatedCommunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCommunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCommunitiesInput, UserUncheckedUpdateWithoutCreatedCommunitiesInput>
  }

  export type UserUpdateWithoutCreatedCommunitiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput = {
    where: CommunityMemberWhereUniqueInput
    update: XOR<CommunityMemberUpdateWithoutCommunityInput, CommunityMemberUncheckedUpdateWithoutCommunityInput>
    create: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput = {
    where: CommunityMemberWhereUniqueInput
    data: XOR<CommunityMemberUpdateWithoutCommunityInput, CommunityMemberUncheckedUpdateWithoutCommunityInput>
  }

  export type CommunityMemberUpdateManyWithWhereWithoutCommunityInput = {
    where: CommunityMemberScalarWhereInput
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyWithoutCommunityInput>
  }

  export type PostUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
  }

  export type PostUpdateManyWithWhereWithoutCommunityInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityCreateWithoutMembersInput = {
    name: string
    description: string
    thumbnail?: string | null
    createdAt?: Date | string
    isPrivate?: boolean
    creator: UserCreateNestedOneWithoutCreatedCommunitiesInput
    posts?: PostCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    description: string
    thumbnail?: string | null
    creatorId: number
    createdAt?: Date | string
    isPrivate?: boolean
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutMembersInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutCommunityMembershipsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityMembershipsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityMembershipsInput, UserUncheckedCreateWithoutCommunityMembershipsInput>
  }

  export type CommunityUpsertWithoutMembersInput = {
    update: XOR<CommunityUpdateWithoutMembersInput, CommunityUncheckedUpdateWithoutMembersInput>
    create: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutMembersInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutMembersInput, CommunityUncheckedUpdateWithoutMembersInput>
  }

  export type CommunityUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    creator?: UserUpdateOneRequiredWithoutCreatedCommunitiesNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutCommunityMembershipsInput = {
    update: XOR<UserUpdateWithoutCommunityMembershipsInput, UserUncheckedUpdateWithoutCommunityMembershipsInput>
    create: XOR<UserCreateWithoutCommunityMembershipsInput, UserUncheckedCreateWithoutCommunityMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunityMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunityMembershipsInput, UserUncheckedUpdateWithoutCommunityMembershipsInput>
  }

  export type UserUpdateWithoutCommunityMembershipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type CommunityCreateWithoutPostsInput = {
    name: string
    description: string
    thumbnail?: string | null
    createdAt?: Date | string
    isPrivate?: boolean
    creator: UserCreateNestedOneWithoutCreatedCommunitiesInput
    members?: CommunityMemberCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    description: string
    thumbnail?: string | null
    creatorId: number
    createdAt?: Date | string
    isPrivate?: boolean
    members?: CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPostsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityUpsertWithoutPostsInput = {
    update: XOR<CommunityUpdateWithoutPostsInput, CommunityUncheckedUpdateWithoutPostsInput>
    create: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutPostsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutPostsInput, CommunityUncheckedUpdateWithoutPostsInput>
  }

  export type CommunityUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    creator?: UserUpdateOneRequiredWithoutCreatedCommunitiesNestedInput
    members?: CommunityMemberUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    members?: CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutCommentsInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    community: CommunityCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    authorId: number
    communityId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedProjectsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedProjectsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    role: $Enums.ProjectRole
    joinedDate?: Date | string
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    role: $Enums.ProjectRole
    joinedDate?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedProjectsInput = {
    update: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type UserUpdateWithoutCreatedProjectsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    title: string
    description: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: number
    title: string
    description: string
    creatorId: number
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembershipsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectMembershipsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creatorId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutProjectMembershipsInput = {
    update: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type UserUpdateWithoutProjectMembershipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SponsorshipCreateWithoutSponsorInput = {
    title: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    type: $Enums.SponsorshipType
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type SponsorshipUncheckedCreateWithoutSponsorInput = {
    id?: number
    title: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    type: $Enums.SponsorshipType
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type SponsorshipCreateOrConnectWithoutSponsorInput = {
    where: SponsorshipWhereUniqueInput
    create: XOR<SponsorshipCreateWithoutSponsorInput, SponsorshipUncheckedCreateWithoutSponsorInput>
  }

  export type SponsorshipCreateManySponsorInputEnvelope = {
    data: SponsorshipCreateManySponsorInput | SponsorshipCreateManySponsorInput[]
    skipDuplicates?: boolean
  }

  export type SponsorshipUpsertWithWhereUniqueWithoutSponsorInput = {
    where: SponsorshipWhereUniqueInput
    update: XOR<SponsorshipUpdateWithoutSponsorInput, SponsorshipUncheckedUpdateWithoutSponsorInput>
    create: XOR<SponsorshipCreateWithoutSponsorInput, SponsorshipUncheckedCreateWithoutSponsorInput>
  }

  export type SponsorshipUpdateWithWhereUniqueWithoutSponsorInput = {
    where: SponsorshipWhereUniqueInput
    data: XOR<SponsorshipUpdateWithoutSponsorInput, SponsorshipUncheckedUpdateWithoutSponsorInput>
  }

  export type SponsorshipUpdateManyWithWhereWithoutSponsorInput = {
    where: SponsorshipScalarWhereInput
    data: XOR<SponsorshipUpdateManyMutationInput, SponsorshipUncheckedUpdateManyWithoutSponsorInput>
  }

  export type SponsorshipScalarWhereInput = {
    AND?: SponsorshipScalarWhereInput | SponsorshipScalarWhereInput[]
    OR?: SponsorshipScalarWhereInput[]
    NOT?: SponsorshipScalarWhereInput | SponsorshipScalarWhereInput[]
    id?: IntFilter<"Sponsorship"> | number
    sponsorId?: IntFilter<"Sponsorship"> | number
    title?: StringFilter<"Sponsorship"> | string
    description?: StringFilter<"Sponsorship"> | string
    amount?: DecimalFilter<"Sponsorship"> | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFilter<"Sponsorship"> | $Enums.SponsorshipType
    startDate?: DateTimeFilter<"Sponsorship"> | Date | string
    endDate?: DateTimeNullableFilter<"Sponsorship"> | Date | string | null
  }

  export type SponsorCreateWithoutSponsorshipsInput = {
    organizationName: string
    contactPerson: string
    email: string
    phone?: string | null
    website?: string | null
    logo?: string | null
    description: string
    partnershipStart?: Date | string
  }

  export type SponsorUncheckedCreateWithoutSponsorshipsInput = {
    id?: number
    organizationName: string
    contactPerson: string
    email: string
    phone?: string | null
    website?: string | null
    logo?: string | null
    description: string
    partnershipStart?: Date | string
  }

  export type SponsorCreateOrConnectWithoutSponsorshipsInput = {
    where: SponsorWhereUniqueInput
    create: XOR<SponsorCreateWithoutSponsorshipsInput, SponsorUncheckedCreateWithoutSponsorshipsInput>
  }

  export type SponsorUpsertWithoutSponsorshipsInput = {
    update: XOR<SponsorUpdateWithoutSponsorshipsInput, SponsorUncheckedUpdateWithoutSponsorshipsInput>
    create: XOR<SponsorCreateWithoutSponsorshipsInput, SponsorUncheckedCreateWithoutSponsorshipsInput>
    where?: SponsorWhereInput
  }

  export type SponsorUpdateToOneWithWhereWithoutSponsorshipsInput = {
    where?: SponsorWhereInput
    data: XOR<SponsorUpdateWithoutSponsorshipsInput, SponsorUncheckedUpdateWithoutSponsorshipsInput>
  }

  export type SponsorUpdateWithoutSponsorshipsInput = {
    organizationName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    partnershipStart?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorUncheckedUpdateWithoutSponsorshipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    partnershipStart?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    earnedDate?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: number
    userId: number
    earnedDate?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUserAchievementsInput = {
    title: string
    description: string
    badgeImage: string
    points: number
    category: $Enums.AchievementCategory
  }

  export type AchievementUncheckedCreateWithoutUserAchievementsInput = {
    id?: number
    title: string
    description: string
    badgeImage: string
    points: number
    category: $Enums.AchievementCategory
  }

  export type AchievementCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateWithoutUserAchievementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeImage?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type AchievementUncheckedUpdateWithoutUserAchievementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeImage?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUploadedResourcesInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedResourcesInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedResourcesInput, UserUncheckedCreateWithoutUploadedResourcesInput>
  }

  export type UserUpsertWithoutUploadedResourcesInput = {
    update: XOR<UserUpdateWithoutUploadedResourcesInput, UserUncheckedUpdateWithoutUploadedResourcesInput>
    create: XOR<UserCreateWithoutUploadedResourcesInput, UserUncheckedCreateWithoutUploadedResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedResourcesInput, UserUncheckedUpdateWithoutUploadedResourcesInput>
  }

  export type UserUpdateWithoutUploadedResourcesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseCreateWithoutAssessmentsInput = {
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: UserCreateNestedOneWithoutInstructedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutCourseInput
    tags?: CourseTagsCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutAssessmentsInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    instructorId?: number | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    learningOutcomes?: LearningOutcomeUncheckedCreateNestedManyWithoutCourseInput
    requirements?: CourseRequirementUncheckedCreateNestedManyWithoutCourseInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutCourseInput
    chatbotMessages?: ChatbotMessageUncheckedCreateNestedManyWithoutCourseInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagsUncheckedCreateNestedManyWithoutCourseInput
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAssessmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAssessmentsInput, CourseUncheckedCreateWithoutAssessmentsInput>
  }

  export type AssessmentQuestionCreateWithoutAssessmentInput = {
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
  }

  export type AssessmentQuestionUncheckedCreateWithoutAssessmentInput = {
    id?: number
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
  }

  export type AssessmentQuestionCreateOrConnectWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    create: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionCreateManyAssessmentInputEnvelope = {
    data: AssessmentQuestionCreateManyAssessmentInput | AssessmentQuestionCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type UserAssessmentAttemptCreateWithoutAssessmentInput = {
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
    user: UserCreateNestedOneWithoutAssessmentAttemptsInput
  }

  export type UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput = {
    id?: number
    userId: number
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
  }

  export type UserAssessmentAttemptCreateOrConnectWithoutAssessmentInput = {
    where: UserAssessmentAttemptWhereUniqueInput
    create: XOR<UserAssessmentAttemptCreateWithoutAssessmentInput, UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput>
  }

  export type UserAssessmentAttemptCreateManyAssessmentInputEnvelope = {
    data: UserAssessmentAttemptCreateManyAssessmentInput | UserAssessmentAttemptCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutAssessmentsInput = {
    update: XOR<CourseUpdateWithoutAssessmentsInput, CourseUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<CourseCreateWithoutAssessmentsInput, CourseUncheckedCreateWithoutAssessmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutAssessmentsInput, CourseUncheckedUpdateWithoutAssessmentsInput>
  }

  export type CourseUpdateWithoutAssessmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneWithoutInstructedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutAssessmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    update: XOR<AssessmentQuestionUpdateWithoutAssessmentInput, AssessmentQuestionUncheckedUpdateWithoutAssessmentInput>
    create: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    data: XOR<AssessmentQuestionUpdateWithoutAssessmentInput, AssessmentQuestionUncheckedUpdateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput = {
    where: AssessmentQuestionScalarWhereInput
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type AssessmentQuestionScalarWhereInput = {
    AND?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
    OR?: AssessmentQuestionScalarWhereInput[]
    NOT?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
    id?: IntFilter<"AssessmentQuestion"> | number
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    question?: StringFilter<"AssessmentQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"AssessmentQuestion"> | $Enums.QuestionType
    points?: IntFilter<"AssessmentQuestion"> | number
    orderNumber?: IntFilter<"AssessmentQuestion"> | number
    options?: StringNullableFilter<"AssessmentQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"AssessmentQuestion"> | string | null
  }

  export type UserAssessmentAttemptUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: UserAssessmentAttemptWhereUniqueInput
    update: XOR<UserAssessmentAttemptUpdateWithoutAssessmentInput, UserAssessmentAttemptUncheckedUpdateWithoutAssessmentInput>
    create: XOR<UserAssessmentAttemptCreateWithoutAssessmentInput, UserAssessmentAttemptUncheckedCreateWithoutAssessmentInput>
  }

  export type UserAssessmentAttemptUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: UserAssessmentAttemptWhereUniqueInput
    data: XOR<UserAssessmentAttemptUpdateWithoutAssessmentInput, UserAssessmentAttemptUncheckedUpdateWithoutAssessmentInput>
  }

  export type UserAssessmentAttemptUpdateManyWithWhereWithoutAssessmentInput = {
    where: UserAssessmentAttemptScalarWhereInput
    data: XOR<UserAssessmentAttemptUpdateManyMutationInput, UserAssessmentAttemptUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type AssessmentCreateWithoutQuestionsInput = {
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutAssessmentsInput
    attempts?: UserAssessmentAttemptCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutQuestionsInput = {
    id?: number
    courseId: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    attempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutQuestionsInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutQuestionsInput, AssessmentUncheckedCreateWithoutQuestionsInput>
  }

  export type AssessmentUpsertWithoutQuestionsInput = {
    update: XOR<AssessmentUpdateWithoutQuestionsInput, AssessmentUncheckedUpdateWithoutQuestionsInput>
    create: XOR<AssessmentCreateWithoutQuestionsInput, AssessmentUncheckedCreateWithoutQuestionsInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutQuestionsInput, AssessmentUncheckedUpdateWithoutQuestionsInput>
  }

  export type AssessmentUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutAssessmentsNestedInput
    attempts?: UserAssessmentAttemptUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type UserCreateWithoutAssessmentAttemptsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    providedFeedback?: FeedbackCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssessmentAttemptsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    providedFeedback?: FeedbackUncheckedCreateNestedManyWithoutProviderInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssessmentAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssessmentAttemptsInput, UserUncheckedCreateWithoutAssessmentAttemptsInput>
  }

  export type AssessmentCreateWithoutAttemptsInput = {
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutAssessmentsInput
    questions?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutAttemptsInput = {
    id?: number
    courseId: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
    questions?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutAttemptsInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutAttemptsInput, AssessmentUncheckedCreateWithoutAttemptsInput>
  }

  export type UserUpsertWithoutAssessmentAttemptsInput = {
    update: XOR<UserUpdateWithoutAssessmentAttemptsInput, UserUncheckedUpdateWithoutAssessmentAttemptsInput>
    create: XOR<UserCreateWithoutAssessmentAttemptsInput, UserUncheckedCreateWithoutAssessmentAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssessmentAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssessmentAttemptsInput, UserUncheckedUpdateWithoutAssessmentAttemptsInput>
  }

  export type UserUpdateWithoutAssessmentAttemptsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    providedFeedback?: FeedbackUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssessmentAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    providedFeedback?: FeedbackUncheckedUpdateManyWithoutProviderNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssessmentUpsertWithoutAttemptsInput = {
    update: XOR<AssessmentUpdateWithoutAttemptsInput, AssessmentUncheckedUpdateWithoutAttemptsInput>
    create: XOR<AssessmentCreateWithoutAttemptsInput, AssessmentUncheckedCreateWithoutAttemptsInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutAttemptsInput, AssessmentUncheckedUpdateWithoutAttemptsInput>
  }

  export type AssessmentUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutAssessmentsNestedInput
    questions?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type UserCreateWithoutProvidedFeedbackInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptCreateNestedManyWithoutUserInput
    userInteractions?: FlashcardInteractionCreateNestedManyWithoutUserInput
    flashcards?: FlashcardCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProvidedFeedbackInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    dateOfBirth?: Date | string | null
    age?: number | null
    phone?: string | null
    country?: string | null
    city?: string | null
    bio?: string | null
    profileImage?: string | null
    gender?: $Enums.Gender | null
    isActive?: boolean
    emailVerified?: boolean
    verificationToken?: string | null
    verificationExpires?: Date | string | null
    lastActive?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: CourseReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    menteeRelationships?: MentorshipUncheckedCreateNestedManyWithoutMenteeInput
    mentorRelationships?: MentorshipUncheckedCreateNestedManyWithoutMentorInput
    instructedCourses?: CourseUncheckedCreateNestedManyWithoutInstructorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    createdCommunities?: CommunityUncheckedCreateNestedManyWithoutCreatorInput
    communityMemberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedResources?: ResourceUncheckedCreateNestedManyWithoutUploaderInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedCreateNestedManyWithoutUserInput
    userInteractions?: FlashcardInteractionUncheckedCreateNestedManyWithoutUserInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutUserInput
    flashcardCollections?: FlashcardCollectionUncheckedCreateNestedManyWithoutUserInput
    chatbotSessions?: ChatbotSessionUncheckedCreateNestedManyWithoutUserInput
    chatbotFeedback?: ChatbotFeedbackUncheckedCreateNestedManyWithoutUserInput
    savedAnswers?: SavedAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProvidedFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProvidedFeedbackInput, UserUncheckedCreateWithoutProvidedFeedbackInput>
  }

  export type UserUpsertWithoutProvidedFeedbackInput = {
    update: XOR<UserUpdateWithoutProvidedFeedbackInput, UserUncheckedUpdateWithoutProvidedFeedbackInput>
    create: XOR<UserCreateWithoutProvidedFeedbackInput, UserUncheckedCreateWithoutProvidedFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProvidedFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProvidedFeedbackInput, UserUncheckedUpdateWithoutProvidedFeedbackInput>
  }

  export type UserUpdateWithoutProvidedFeedbackInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUpdateManyWithoutUserNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProvidedFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: CourseReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    menteeRelationships?: MentorshipUncheckedUpdateManyWithoutMenteeNestedInput
    mentorRelationships?: MentorshipUncheckedUpdateManyWithoutMentorNestedInput
    instructedCourses?: CourseUncheckedUpdateManyWithoutInstructorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    createdCommunities?: CommunityUncheckedUpdateManyWithoutCreatorNestedInput
    communityMemberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedResources?: ResourceUncheckedUpdateManyWithoutUploaderNestedInput
    assessmentAttempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutUserNestedInput
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutUserNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutUserNestedInput
    flashcardCollections?: FlashcardCollectionUncheckedUpdateManyWithoutUserNestedInput
    chatbotSessions?: ChatbotSessionUncheckedUpdateManyWithoutUserNestedInput
    chatbotFeedback?: ChatbotFeedbackUncheckedUpdateManyWithoutUserNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseReviewCreateManyUserInput = {
    id?: number
    courseId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
  }

  export type EnrollmentCreateManyUserInput = {
    id?: number
    courseId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
  }

  export type UserSkillCreateManyUserInput = {
    id?: number
    skillId: number
    proficiencyLevel: number
    acquiredDate?: Date | string | null
  }

  export type MentorshipCreateManyMenteeInput = {
    id?: number
    mentorId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
  }

  export type MentorshipCreateManyMentorInput = {
    id?: number
    menteeId: number
    programId?: number | null
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
  }

  export type CourseCreateManyInstructorInput = {
    id?: number
    title: string
    slug: string
    description: string
    overview?: string | null
    thumbnail?: string | null
    coverImage?: string | null
    type: $Enums.CourseType
    difficulty?: $Enums.DifficultyLevel | null
    durationHours?: number | null
    isFeatured?: boolean
    isPublished?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    enrollmentLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventRegistrationCreateManyUserInput = {
    id?: number
    eventId: number
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
  }

  export type CommunityCreateManyCreatorInput = {
    id?: number
    name: string
    description: string
    thumbnail?: string | null
    createdAt?: Date | string
    isPrivate?: boolean
  }

  export type CommunityMemberCreateManyUserInput = {
    id?: number
    communityId: number
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
  }

  export type PostCreateManyAuthorInput = {
    id?: number
    communityId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: number
    postId: number
    content: string
    createdAt?: Date | string
  }

  export type ProjectCreateManyCreatorInput = {
    id?: number
    title: string
    description: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: $Enums.ProjectStatus
    githubUrl?: string | null
    demoUrl?: string | null
    thumbnail?: string | null
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: number
    projectId: number
    role: $Enums.ProjectRole
    joinedDate?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: number
    achievementId: number
    earnedDate?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    type: $Enums.NotificationType
    actionUrl?: string | null
  }

  export type ResourceCreateManyUploaderInput = {
    id?: number
    title: string
    description: string
    fileUrl: string
    type: $Enums.ResourceType
    uploadDate?: Date | string
    isApproved?: boolean
  }

  export type UserAssessmentAttemptCreateManyUserInput = {
    id?: number
    assessmentId: number
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
  }

  export type FeedbackCreateManyProviderInput = {
    id?: number
    targetId: number
    targetType: $Enums.FeedbackTarget
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FlashcardInteractionCreateManyUserInput = {
    id?: number
    flashcardId: number
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
  }

  export type FlashcardCreateManyUserInput = {
    id?: number
    courseId?: number | null
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
  }

  export type FlashcardCollectionCreateManyUserInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    isPublic?: boolean
  }

  export type ChatbotSessionCreateManyUserInput = {
    id?: number
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type ChatbotFeedbackCreateManyUserInput = {
    id?: number
    messageId: number
    rating?: number | null
    feedback?: string | null
    createdAt?: Date | string
  }

  export type SavedAnswerCreateManyUserInput = {
    id?: number
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    courseId?: number | null
  }

  export type CourseReviewUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type CourseReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnrollmentUpdateWithoutUserInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSkillUpdateWithoutUserInput = {
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skill?: SkillUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSkillUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MentorshipUpdateWithoutMenteeInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    mentor?: UserUpdateOneRequiredWithoutMentorRelationshipsNestedInput
    program?: MentorshipProgramUpdateOneWithoutRelationshipsNestedInput
    sessions?: MentorshipSessionUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutMenteeInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    sessions?: MentorshipSessionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateManyWithoutMenteeInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type MentorshipUpdateWithoutMentorInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    mentee?: UserUpdateOneRequiredWithoutMenteeRelationshipsNestedInput
    program?: MentorshipProgramUpdateOneWithoutRelationshipsNestedInput
    sessions?: MentorshipSessionUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutMentorInput = {
    id?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    sessions?: MentorshipSessionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateManyWithoutMentorInput = {
    id?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type CourseUpdateWithoutInstructorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    learningOutcomes?: LearningOutcomeUncheckedUpdateManyWithoutCourseNestedInput
    requirements?: CourseRequirementUncheckedUpdateManyWithoutCourseNestedInput
    assessments?: AssessmentUncheckedUpdateManyWithoutCourseNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutCourseNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutCourseNestedInput
    savedAnswers?: SavedAnswerUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagsUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: CourseReviewUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    difficulty?: NullableEnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel | null
    durationHours?: NullableIntFieldUpdateOperationsInput | number | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUpdateWithoutUserInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    members?: CommunityMemberUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    members?: CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityMemberUpdateWithoutUserInput = {
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
    community?: CommunityUpdateOneRequiredWithoutMembersNestedInput
  }

  export type CommunityMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type CommunityMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type PostUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    achievementId?: IntFieldUpdateOperationsInput | number
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    achievementId?: IntFieldUpdateOperationsInput | number
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResourceUpdateWithoutUploaderInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResourceUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResourceUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAssessmentAttemptUpdateWithoutUserInput = {
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: AssessmentUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type UserAssessmentAttemptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAssessmentAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackUpdateWithoutProviderInput = {
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateWithoutProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumFeedbackTargetFieldUpdateOperationsInput | $Enums.FeedbackTarget
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardInteractionUpdateWithoutUserInput = {
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    flashcard?: FlashcardUpdateOneRequiredWithoutUserInteractionsNestedInput
  }

  export type FlashcardInteractionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardInteractionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardUpdateWithoutUserInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutFlashcardsNestedInput
    module?: CourseModuleUpdateOneWithoutFlashcardsNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlashcardCollectionUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    cards?: FlashcardCollectionItemUpdateManyWithoutCollectionNestedInput
  }

  export type FlashcardCollectionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    cards?: FlashcardCollectionItemUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type FlashcardCollectionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatbotSessionUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatbotMessageUpdateManyWithoutSessionNestedInput
    analytics?: ChatbotSessionAnalyticsUpdateOneWithoutSessionNestedInput
  }

  export type ChatbotSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatbotMessageUncheckedUpdateManyWithoutSessionNestedInput
    analytics?: ChatbotSessionAnalyticsUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type ChatbotSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatbotFeedbackUpdateWithoutUserInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: ChatbotMessageUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type ChatbotFeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedAnswerUpdateWithoutUserInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutSavedAnswersNestedInput
  }

  export type SavedAnswerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SavedAnswerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FlashcardInteractionCreateManyFlashcardInput = {
    id?: number
    userId: number
    correct: boolean
    responseTime?: number | null
    interactionDate?: Date | string
  }

  export type FlashcardCollectionItemCreateManyFlashcardInput = {
    id?: number
    collectionId: number
    addedAt?: Date | string
  }

  export type FlashcardInteractionUpdateWithoutFlashcardInput = {
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserInteractionsNestedInput
  }

  export type FlashcardInteractionUncheckedUpdateWithoutFlashcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardInteractionUncheckedUpdateManyWithoutFlashcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionItemUpdateWithoutFlashcardInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: FlashcardCollectionUpdateOneRequiredWithoutCardsNestedInput
  }

  export type FlashcardCollectionItemUncheckedUpdateWithoutFlashcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    collectionId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    collectionId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionItemCreateManyCollectionInput = {
    id?: number
    flashcardId: number
    addedAt?: Date | string
  }

  export type FlashcardCollectionItemUpdateWithoutCollectionInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flashcard?: FlashcardUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type FlashcardCollectionItemUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCollectionItemUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    flashcardId?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotMessageCreateManySessionInput = {
    id?: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
  }

  export type ChatbotMessageUpdateWithoutSessionInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneWithoutChatbotMessagesNestedInput
    module?: CourseModuleUpdateOneWithoutChatbotMessagesNestedInput
    feedback?: ChatbotFeedbackUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: ChatbotFeedbackUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSkillCreateManySkillInput = {
    id?: number
    userId: number
    proficiencyLevel: number
    acquiredDate?: Date | string | null
  }

  export type UserSkillUpdateWithoutSkillInput = {
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseModuleCreateManyCourseInput = {
    id?: number
    title: string
    description: string
    orderNumber: number
    isPublished?: boolean
    estimatedHours?: number | null
    unlockCondition?: string | null
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: number
    userId: number
    enrollmentDate?: Date | string
    status?: $Enums.EnrollmentStatus
    completionDate?: Date | string | null
    progressPercentage?: number
    lastAccessedAt?: Date | string | null
    unenrollmentDate?: Date | string | null
    unenrollmentReason?: string | null
  }

  export type LearningOutcomeCreateManyCourseInput = {
    id?: number
    description: string
    orderNumber: number
  }

  export type CourseRequirementCreateManyCourseInput = {
    id?: number
    description: string
    orderNumber: number
  }

  export type AssessmentCreateManyCourseInput = {
    id?: number
    title: string
    description: string
    totalPoints: number
    passingPoints: number
    createdAt?: Date | string
  }

  export type FlashcardCreateManyCourseInput = {
    id?: number
    userId: number
    moduleId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
  }

  export type ChatbotMessageCreateManyCourseInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    moduleId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
  }

  export type SavedAnswerCreateManyCourseInput = {
    id?: number
    question: string
    answer: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublic?: boolean
    userId?: number | null
  }

  export type CourseTagsCreateManyCourseInput = {
    id?: number
    name: string
  }

  export type CourseReviewCreateManyCourseInput = {
    id?: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
  }

  export type CourseModuleUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ContentUnitUncheckedUpdateManyWithoutModuleNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutModuleNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutModuleNestedInput
    userProgress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutModuleNestedInput
    chatbotMessages?: ChatbotMessageUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    estimatedHours?: NullableIntFieldUpdateOperationsInput | number | null
    unlockCondition?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    unitProgress?: UnitProgressUncheckedUpdateManyWithoutEnrollmentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutEnrollmentNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unenrollmentReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningOutcomeUpdateWithoutCourseInput = {
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type LearningOutcomeUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type LearningOutcomeUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseRequirementUpdateWithoutCourseInput = {
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseRequirementUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type CourseRequirementUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    attempts?: UserAssessmentAttemptUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    attempts?: UserAssessmentAttemptUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    passingPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardUpdateWithoutCourseInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFlashcardsNestedInput
    module?: CourseModuleUpdateOneWithoutFlashcardsNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatbotMessageUpdateWithoutCourseInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    session?: ChatbotSessionUpdateOneRequiredWithoutMessagesNestedInput
    module?: CourseModuleUpdateOneWithoutChatbotMessagesNestedInput
    feedback?: ChatbotFeedbackUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: ChatbotFeedbackUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SavedAnswerUpdateWithoutCourseInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutSavedAnswersNestedInput
  }

  export type SavedAnswerUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SavedAnswerUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseTagsUpdateWithoutCourseInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagsUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagsUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseReviewUpdateWithoutCourseInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type CourseReviewUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseReviewUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContentUnitCreateManyModuleInput = {
    id?: number
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    orderNumber: number
    estimatedMinutes?: number | null
    isRequired?: boolean
    textContent?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    externalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateManyModuleInput = {
    id?: number
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    allowRetakes?: boolean
    maxAttempts?: number | null
    randomizeQuestions?: boolean
    showCorrectAnswers?: boolean
    orderNumber: number
    isPublished?: boolean
  }

  export type ExerciseCreateManyModuleInput = {
    id?: number
    title: string
    description: string
    instructions: string
    exerciseType: $Enums.ExerciseType
    orderNumber: number
    dueDate?: Date | string | null
    allowLateSubmissions?: boolean
    maxScore?: number
  }

  export type ModuleProgressCreateManyModuleInput = {
    id?: number
    enrollmentId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
  }

  export type FlashcardCreateManyModuleInput = {
    id?: number
    userId: number
    courseId?: number | null
    question: string
    answer: string
    difficultyLevel?: number
    tags?: string | null
    aiGenerated?: boolean
    createdAt?: Date | string
    lastReviewed?: Date | string | null
    timesReviewed?: number
    confidenceLevel?: number | null
    aiModel?: string | null
    generationPrompt?: string | null
    sourceContentSnippet?: string | null
  }

  export type ChatbotMessageCreateManyModuleInput = {
    id?: number
    sessionId: number
    content: string
    role: $Enums.MessageRole
    timestamp?: Date | string
    referencedContent?: string | null
    courseId?: number | null
    model?: string | null
    promptTokens?: number | null
    completionTokens?: number | null
  }

  export type ContentUnitUpdateWithoutModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UnitProgressUpdateManyWithoutUnitNestedInput
    attachments?: UnitAttachmentUpdateManyWithoutUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UnitProgressUncheckedUpdateManyWithoutUnitNestedInput
    attachments?: UnitAttachmentUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    orderNumber?: IntFieldUpdateOperationsInput | number
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: IntFieldUpdateOperationsInput | number
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    showCorrectAnswers?: BoolFieldUpdateOperationsInput | boolean
    orderNumber?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseUpdateWithoutModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
    submissions?: ExerciseSubmissionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
    submissions?: ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    orderNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowLateSubmissions?: BoolFieldUpdateOperationsInput | boolean
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleProgressUpdateWithoutModuleInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    enrollment?: EnrollmentUpdateOneRequiredWithoutModuleProgressNestedInput
  }

  export type ModuleProgressUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleProgressUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type FlashcardUpdateWithoutModuleInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFlashcardsNestedInput
    course?: CourseUpdateOneWithoutFlashcardsNestedInput
    userInteractions?: FlashcardInteractionUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    userInteractions?: FlashcardInteractionUncheckedUpdateManyWithoutFlashcardNestedInput
    collections?: FlashcardCollectionItemUncheckedUpdateManyWithoutFlashcardNestedInput
  }

  export type FlashcardUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timesReviewed?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    generationPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    sourceContentSnippet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatbotMessageUpdateWithoutModuleInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    session?: ChatbotSessionUpdateOneRequiredWithoutMessagesNestedInput
    course?: CourseUpdateOneWithoutChatbotMessagesNestedInput
    feedback?: ChatbotFeedbackUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: ChatbotFeedbackUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    referencedContent?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    completionTokens?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitProgressCreateManyUnitInput = {
    id?: number
    enrollmentId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
  }

  export type UnitAttachmentCreateManyUnitInput = {
    id?: number
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
  }

  export type UnitProgressUpdateWithoutUnitInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: EnrollmentUpdateOneRequiredWithoutUnitProgressNestedInput
  }

  export type UnitProgressUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitProgressUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitAttachmentUpdateWithoutUnitInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type UnitAttachmentUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type UnitAttachmentUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleProgressCreateManyEnrollmentInput = {
    id?: number
    moduleId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    progressPercentage?: number
  }

  export type UnitProgressCreateManyEnrollmentInput = {
    id?: number
    unitId: number
    userId: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpentMinutes?: number
    lastPosition?: string | null
  }

  export type QuizAttemptCreateManyEnrollmentInput = {
    id?: number
    quizId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
  }

  export type ExerciseSubmissionCreateManyEnrollmentInput = {
    id?: number
    exerciseId: number
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
  }

  export type ModuleProgressUpdateWithoutEnrollmentInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    module?: CourseModuleUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type ModuleProgressUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleProgressUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type UnitProgressUpdateWithoutEnrollmentInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: ContentUnitUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UnitProgressUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitProgressUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpentMinutes?: IntFieldUpdateOperationsInput | number
    lastPosition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizAttemptUpdateWithoutEnrollmentInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    answers?: QuestionAnswerUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: QuestionAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
  }

  export type ExerciseSubmissionUpdateWithoutEnrollmentInput = {
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
    exercise?: ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: number
    questionText: string
    questionType: $Enums.QuestionType
    points?: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
    explanation?: string | null
  }

  export type QuizAttemptCreateManyQuizInput = {
    id?: number
    enrollmentId: number
    userId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    percentage?: number | null
    passed?: boolean | null
    attemptNumber?: number
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: QuestionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizAttemptUpdateWithoutQuizInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    enrollment?: EnrollmentUpdateOneRequiredWithoutQuizAttemptsNestedInput
    answers?: QuestionAnswerUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: QuestionAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionAnswerCreateManyQuestionInput = {
    id?: number
    attemptId: number
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
  }

  export type QuestionAnswerUpdateWithoutQuestionInput = {
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAnswerCreateManyAttemptInput = {
    id?: number
    questionId: number
    userAnswer?: string | null
    isCorrect?: boolean | null
    pointsAwarded?: number | null
  }

  export type QuestionAnswerUpdateWithoutAttemptInput = {
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseSubmissionCreateManyExerciseInput = {
    id?: number
    enrollmentId: number
    userId: number
    submittedAt?: Date | string
    content?: string | null
    fileUrl?: string | null
    score?: number | null
    feedback?: string | null
    gradedAt?: Date | string | null
    gradedBy?: number | null
  }

  export type ExerciseSubmissionUpdateWithoutExerciseInput = {
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: EnrollmentUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    enrollmentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MentorshipCreateManyProgramInput = {
    id?: number
    mentorId: number
    menteeId: number
    startDate?: Date | string
    endDate?: Date | string | null
    status: $Enums.StatusType
  }

  export type MentorshipUpdateWithoutProgramInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    mentee?: UserUpdateOneRequiredWithoutMenteeRelationshipsNestedInput
    mentor?: UserUpdateOneRequiredWithoutMentorRelationshipsNestedInput
    sessions?: MentorshipSessionUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    sessions?: MentorshipSessionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type MentorshipUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    mentorId?: IntFieldUpdateOperationsInput | number
    menteeId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type MentorshipSessionCreateManyRelationshipInput = {
    id?: number
    sessionDate: Date | string
    durationMinutes: number
    notes?: string | null
    status: $Enums.SessionStatus
    feedback?: string | null
  }

  export type MentorshipSessionUpdateWithoutRelationshipInput = {
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorshipSessionUncheckedUpdateWithoutRelationshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorshipSessionUncheckedUpdateManyWithoutRelationshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventRegistrationCreateManyEventInput = {
    id?: number
    userId: number
    registrationDate?: Date | string
    attendanceConfirmed?: boolean
  }

  export type EventRegistrationUpdateWithoutEventInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityMemberCreateManyCommunityInput = {
    id?: number
    userId: number
    joinedDate?: Date | string
    role?: $Enums.CommunityRole
  }

  export type PostCreateManyCommunityInput = {
    id?: number
    authorId: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityMemberUpdateWithoutCommunityInput = {
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
    user?: UserUpdateOneRequiredWithoutCommunityMembershipsNestedInput
  }

  export type CommunityMemberUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type CommunityMemberUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumCommunityRoleFieldUpdateOperationsInput | $Enums.CommunityRole
  }

  export type PostUpdateWithoutCommunityInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: number
    userId: number
    role: $Enums.ProjectRole
    joinedDate?: Date | string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorshipCreateManySponsorInput = {
    id?: number
    title: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    type: $Enums.SponsorshipType
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type SponsorshipUpdateWithoutSponsorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorshipUncheckedUpdateWithoutSponsorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorshipUncheckedUpdateManyWithoutSponsorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumSponsorshipTypeFieldUpdateOperationsInput | $Enums.SponsorshipType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: number
    userId: number
    earnedDate?: Date | string
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentQuestionCreateManyAssessmentInput = {
    id?: number
    question: string
    questionType: $Enums.QuestionType
    points: number
    orderNumber: number
    options?: string | null
    correctAnswer?: string | null
  }

  export type UserAssessmentAttemptCreateManyAssessmentInput = {
    id?: number
    userId: number
    score: number
    passed: boolean
    attemptDate?: Date | string
    attemptNumber: number
    answers?: string | null
  }

  export type AssessmentQuestionUpdateWithoutAssessmentInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentQuestionUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentQuestionUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    points?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAssessmentAttemptUpdateWithoutAssessmentInput = {
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAssessmentAttemptsNestedInput
  }

  export type UserAssessmentAttemptUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAssessmentAttemptUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    passed?: BoolFieldUpdateOperationsInput | boolean
    attemptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}